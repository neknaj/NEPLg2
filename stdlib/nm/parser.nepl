//: parser: nm/parser.nepl に関する機能を提供するライブラリ
//:
//: [目的/もくてき]:
//: - このモジュールの公開 API を提供します。
//: - 実装の変更時に最小限の doctest 実行経路を維持します。
//:
//: [注意/ちゅうい]:
//: - 利用時は各関数の「目的」「注意」「計算量」を確認してください。
//:
//: neplg2:test[skip]
//: ```neplg2
//:| #entry main
//:| #target wasi
//: ()
//: ```

#indent 4

#import "alloc/string" as *
#import "alloc/vec" as *
#import "core/option" as *
#import "core/mem" as *
#import "core/math" as *
#import "alloc/collections/stack" as *
#import "core/field" as *

// -----------------------------
// AST
// -----------------------------

pub struct Document:
    nodes <Vec<Node>>

pub struct Heading:
    level <i32>
    inlines <Vec<Inline>>

pub struct NestSection:
    level <i32>
    heading <Heading>
    children <Vec<Node>>

pub struct RubyInfo:
    base <str>
    ruby <str>

pub struct GlossInfo:
    main <str>
    subs <Vec<str>>

pub struct CodeBlockInfo:
    info <str>
    code <str>

pub enum Inline:
    Text <str>
    Ruby <RubyInfo>
    Gloss <GlossInfo>
    Math <str>

pub enum Node:
    Section <NestSection>
    Paragraph <Vec<Inline>>
    Hr
    CodeBlock <CodeBlockInfo>

// Multi-return helpers (no tuple destructuring)
//: FenceRes: 構造体の概要
//:
//: [目的/もくてき]:
//: - FenceRes の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 定義そのものは O(1) です。
struct FenceRes:
    cb <CodeBlockInfo>
    next_i <i32>

//: ParaRes: 構造体の概要
//:
//: [目的/もくてき]:
//: - ParaRes の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 定義そのものは O(1) です。
struct ParaRes:
    inlines <Vec<Inline>>
    next_i <i32>

// -----------------------------
// Small helpers
// -----------------------------

//: is_empty_line: 主な用途
//:
//: [目的/もくてき]:
//: - is_empty_line の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn is_empty_line <(str)*>bool> (s):
    let t <str> str_trim s;
    eq len t 0

//: is_hr_line: 主な用途
//:
//: [目的/もくてき]:
//: - is_hr_line の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn is_hr_line <(str)*>bool> (s):
    let t <str> str_trim s;
    str_eq t "---"

//: is_nest_break_line: 主な用途
//:
//: [目的/もくてき]:
//: - is_nest_break_line の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn is_nest_break_line <(str)*>bool> (s):
    let t <str> str_trim s;
    str_eq t ";;;"

//: is_fence_start: 主な用途
//:
//: [目的/もくてき]:
//: - is_fence_start の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn is_fence_start <(str)*>bool> (s):
    let t <str> str_trim s;
    str_starts_with t "```"

//: is_heading_start: 主な用途
//:
//: [目的/もくてき]:
//: - is_heading_start の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn is_heading_start <(str)*>bool> (s):
    let t <str> str_trim s;
    or str_starts_with t "# " or str_starts_with t "## " or str_starts_with t "### " or str_starts_with t "#### " or str_starts_with t "##### " str_starts_with t "###### "

//: trim_cr: 主な用途
//:
//: [目的/もくてき]:
//: - trim_cr の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn trim_cr <(str)*>str> (s):
    let n <i32> len s;
    if:
        le n 0
        then s
        else:
            let last <i32> load_u8 add s add 4 sub n 1;
            if:
                eq last 13
                then str_slice s 0 sub n 1
                else s

//: safe_line: 主な用途
//:
//: [目的/もくてき]:
//: - safe_line の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn safe_line <(i32, i32)*>str> (lines_mem, i):
    let lines <Vec<str>> load<Vec<str>> lines_mem;
    match vec_get<str> lines i:
        Option::Some s:
            trim_cr s
        Option::None:
            ""

//: close_one_section: 主な用途
//:
//: [目的/もくてき]:
//: - close_one_section の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn close_one_section <(i32, Vec<Node>)*>Vec<Node>> (stk, root):
    match stack_pop<NestSection> stk:
        Option::Some sec:
            let node <Node> Node::Section sec;
            // Append to parent if exists, else to root
            match stack_peek<NestSection> stk:
                Option::Some top:
                    let parent_level <i32> get top "level";
                    let parent_heading <Heading> get top "heading";
                    match stack_pop<NestSection> stk:
                        Option::Some parent:
                            let kids <Vec<Node>> vec_push<Node> get parent "children" node;
                            let parent2 <NestSection> NestSection parent_level parent_heading kids;
                            stack_push<NestSection> stk parent2;
                            root
                        Option::None:
                            vec_push<Node> root node
                Option::None:
                    vec_push<Node> root node
        Option::None:
            root

//: close_to_level: 主な用途
//:
//: [目的/もくてき]:
//: - close_to_level の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn close_to_level <(i32, Vec<Node>, i32)*>Vec<Node>> (stk, root, new_level):
    // Close while top.level >= new_level
    let mut r <Vec<Node>> root;
    let mut done <bool> false;
    while not done:
        do:
            match stack_peek<NestSection> stk:
                Option::Some top:
                    if:
                        ge get top "level" new_level
                        then:
                            set r close_one_section stk r;
                            ()
                        else:
                            set done true;
                            ()
                Option::None:
                    set done true;
                    ()
    r

//: close_all_sections: 主な用途
//:
//: [目的/もくてき]:
//: - close_all_sections の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn close_all_sections <(i32, Vec<Node>)*>Vec<Node>> (stk, root):
    let mut r <Vec<Node>> root;
    let mut done <bool> false;
    while not done:
        do:
            match stack_peek<NestSection> stk:
                Option::Some _:
                    set r close_one_section stk r;
                    ()
                Option::None:
                    set done true;
                    ()
    r

//: parse_heading: 主な用途
//:
//: [目的/もくてき]:
//: - parse_heading の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn parse_heading <(str)*>Option<Heading>> (line):
    let t <str> str_trim line;

    if:
        str_starts_with t "###### "
        then:
            let txt <str> str_slice t 7 len t;
            Option::Some Heading 6 parse_inlines txt
        else:
            if:
                str_starts_with t "##### "
                then:
                    let txt <str> str_slice t 6 len t;
                    Option::Some Heading 5 parse_inlines txt
                else:
                    if:
                        str_starts_with t "#### "
                        then:
                            let txt <str> str_slice t 5 len t;
                            Option::Some Heading 4 parse_inlines txt
                        else:
                            if:
                                str_starts_with t "### "
                                then:
                                    let txt <str> str_slice t 4 len t;
                                    Option::Some Heading 3 parse_inlines txt
                                else:
                                    if:
                                        str_starts_with t "## "
                                        then:
                                            let txt <str> str_slice t 3 len t;
                                            Option::Some Heading 2 parse_inlines txt
                                        else:
                                            if:
                                                str_starts_with t "# "
                                                then:
                                                    let txt <str> str_slice t 2 len t;
                                                    Option::Some Heading 1 parse_inlines txt
                                                else:
                                                    Option::None

//: parse_fence: 主な用途
//:
//: [目的/もくてき]:
//: - parse_fence の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn parse_fence <(i32, i32, i32)*>FenceRes> (lines_mem, nlines, i0):
    let t0 <str> str_trim safe_line lines_mem i0;
    let info0 <str> str_slice t0 3 len t0;
    let info <str> str_trim info0;

    let mut sb <StringBuilder> string_builder_new;
    let mut i <i32> add i0 1;

    let mut done <bool> false;
    while not done:
        do:
            if:
                ge i nlines
                then:
                    set done true;
                    ()
                else:
                    let li <str> str_trim safe_line lines_mem i;
                    if:
                        str_starts_with li "```"
                        then:
                            set i add i 1;
                            set done true;
                            ()
                        else:
                            set sb sb_append sb safe_line lines_mem i;
                            set sb sb_append sb "\n";
                            set i add i 1;
                            ()
    let code <str> sb_build sb;
    let cb <CodeBlockInfo> CodeBlockInfo info code;
    FenceRes cb i

//: parse_paragraph: 主な用途
//:
//: [目的/もくてき]:
//: - parse_paragraph の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn parse_paragraph <(i32, i32, i32)*>ParaRes> (lines_mem, nlines, i0):
    let mut sb <StringBuilder> string_builder_new;
    let mut i <i32> i0;

    let mut done <bool> false;
    while not done:
        do:
            if:
                ge i nlines
                then:
                    set done true;
                    ()
                else:
                    let raw <str> safe_line lines_mem i;
                    let t <str> str_trim raw;

                    if:
                        eq len t 0
                        then:
                            set done true;
                            ()
                        else:
                            if:
                                or is_heading_start t or is_hr_line t or is_nest_break_line t is_fence_start t
                                then:
                                    set done true;
                                    ()
                                else:
                                    set sb sb_append sb raw;
                                    set sb sb_append sb "\n";
                                    set i add i 1;
                                    ()
    let text <str> sb_build sb;
    let inl <Vec<Inline>> parse_inlines text;
    ParaRes inl i

// -----------------------------
// Inline parser: Ruby / Gloss / Math
// -----------------------------

//: parse_inlines: 主な用途
//:
//: [目的/もくてき]:
//: - parse_inlines の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn parse_inlines <(str)*>Vec<Inline>> (s):
    let mut out <Vec<Inline>> vec_new<Inline>;
    let n <i32> len s;
    let mut i <i32> 0;
    let mut text_start <i32> 0;

    while lt i n:
        do:
            let ch <i32> load_u8 add s add 4 i;

            // Math ($ or $$): keep delimiters, do not parse inside
            if:
                eq ch 36
                then:
                    // Flush pending text
                    let seg <str> str_slice s text_start i;
                    if:
                        gt len seg 0
                        then set out vec_push<Inline> out Inline::Text seg
                        else ()

                    let mut delim <i32> 1;
                    if:
                        lt add i 1 n
                        then:
                            let ch2 <i32> load_u8 add s add 4 add i 1;
                            if:
                                eq ch2 36
                                then set delim 2
                                else ()
                        else ()

                    let mut j <i32> add i delim;
                    let mut found <bool> false;

                    while and lt j n not found:
                        do:
                            let c0 <i32> load_u8 add s add 4 j;
                            if:
                                eq delim 1
                                then:
                                    if:
                                        eq c0 36
                                        then set found true
                                        else set j add j 1
                                else:
                                    if:
                                        and eq c0 36 lt add j 1 n
                                        then:
                                            let c1 <i32> load_u8 add s add 4 add j 1;
                                            if:
                                                eq c1 36
                                                then set found true
                                                else set j add j 1
                                        else:
                                            set j add j 1

                    if:
                        found
                        then:
                            let endpos <i32> add j delim;
                            let m <str> str_slice s i endpos;
                            set out vec_push<Inline> out Inline::Math m;
                            set i endpos;
                            set text_start endpos;
                            ()
                        else:
                            // No closing delimiter -> treat '$' as normal text
                            set i add i 1;
                            set text_start text_start;
                            ()
                else:
                    // Ruby: [base/ruby] (ignore if looks like markdown link: ]( )
                    if:
                        eq ch 91
                        then:
                            let mut j <i32> add i 1;
                            let mut slash <i32> -1;
                            let mut closed <bool> false;

                            while and lt j n not closed:
                                do:
                                    let cj <i32> load_u8 add s add 4 j;
                                    if:
                                        eq cj 93
                                        then set closed true
                                        else:
                                            if:
                                                and eq cj 47 lt slash 0
                                                then set slash j
                                                else ()
                                            set j add j 1;
                                            ()
                            if:
                                and closed ge slash 0
                                then:
                                    let mut next_is_paren <bool> false;
                                    if:
                                        lt add j 1 n
                                        then:
                                            let nx <i32> load_u8 add s add 4 add j 1;
                                            set next_is_paren eq nx 40;
                                            ()
                                        else ()

                                    if:
                                        next_is_paren
                                        then:
                                            set i add i 1;
                                            ()
                                        else:
                                            let seg <str> str_slice s text_start i;
                                            if:
                                                gt len seg 0
                                                then set out vec_push<Inline> out Inline::Text seg
                                                else ()

                                            let base <str> str_slice s add i 1 slash;
                                            let rub <str> str_slice s add slash 1 j;
                                            let r <RubyInfo> RubyInfo base rub;
                                            set out vec_push<Inline> out Inline::Ruby r;

                                            set i add j 1;
                                            set text_start i;
                                            ()
                                else:
                                    set i add i 1;
                                    ()
                        else:
                            // Gloss: {main/sub1/sub2...} (split '/' at top level, ignoring inside [...])
                            if:
                                eq ch 123
                                then:
                                    let mut j <i32> add i 1;
                                    let mut closed <bool> false;
                                    while and lt j n not closed:
                                        do:
                                            let cj <i32> load_u8 add s add 4 j;
                                            if:
                                                eq cj 125
                                                then set closed true
                                                else set j add j 1
                                    if:
                                        closed
                                        then:
                                            // Flush pending text
                                            let seg <str> str_slice s text_start i;
                                            if:
                                                gt len seg 0
                                                then set out vec_push<Inline> out Inline::Text seg
                                                else ()

                                            // Collect parts
                                            let mut parts <Vec<str>> vec_new<str>;
                                            let mut k <i32> add i 1;
                                            let mut start <i32> k;
                                            let mut depth <i32> 0;

                                            while lt k j:
                                                do:
                                                    let ck <i32> load_u8 add s add 4 k;
                                                    if:
                                                        eq ck 91
                                                        then set depth add depth 1
                                                        else:
                                                            if:
                                                                and eq ck 93 gt depth 0
                                                                then set depth sub depth 1
                                                                else ()
                                                    if:
                                                        and eq ck 47 eq depth 0
                                                        then:
                                                            let p <str> str_slice s start k;
                                                            set parts vec_push<str> parts p;
                                                            set start add k 1;
                                                            set k add k 1;
                                                            ()
                                                        else:
                                                            set k add k 1;
                                                            ()
                                            let plast <str> str_slice s start j;
                                            set parts vec_push<str> parts plast;

                                            let parts_len <i32> get parts "len";
                                            if:
                                                ge parts_len 2
                                                then:
                                                    let parts_data <i32> get parts "data";
                                                    let main <str> load<str> parts_data;
                                                    let mut subs <Vec<str>> vec_new<str>;
                                                    let mut idx <i32> 1;
                                                    while lt idx parts_len:
                                                        do:
                                                            let p <str> load<str> add parts_data mul idx size_of<str>;
                                                            set subs vec_push<str> subs p;
                                                            set idx add idx 1;
                                                    let g <GlossInfo> GlossInfo main subs;
                                                    set out vec_push<Inline> out Inline::Gloss g;
                                                    set i add j 1;
                                                    set text_start i;
                                                    ()
                                                else:
                                                    // Not actually gloss -> keep as text
                                                    set i add i 1;
                                                    ()
                                        else:
                                            set i add i 1;
                                            ()
                                else:
                                    set i add i 1;
                                    ()

    // Flush tail text
    let tail <str> str_slice s text_start n;
    if:
        gt len tail 0
        then vec_push<Inline> out Inline::Text tail
        else out

// -----------------------------
// Main block parser + Nest builder
// -----------------------------

//: parse_markdown: 拡張 Markdown 文字列を `Document` AST に変換する
//:
//: [目的/もくてき]:
//: - 見出し Nest / 段落 / 水平線 / コードフェンスを解析し、後段処理で使える AST を生成します。
//: - nm 系 API の入口として、HTML 変換・JSON 変換の双方から利用します。
//:
//: [実装/じっそう]:
//: - 行単位で走査し、section stack で入れ子構造を管理します。
//: - 行内要素（ruby/gloss/math）は `parse_inlines` に委譲します。
//:
//: [注意/ちゅうい]:
//: - 現状は `Result` ではなく AST を直接返す設計です。診断回復は今後の拡張対象です。
//:
//: [計算量/けいさんりょう]:
//: - O(n)（n は入力サイズ）。
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasm
//:| #import "alloc/string" as *
//:| #import "nm/parser" as *
//: fn main <()->i32> ():
//:     let d <Document> parse_markdown "# T\n\nx\n";
//:     let j <str> document_to_json d;
//:     if and str_starts_with j "{\"t\":\"doc\"" gt len j 0 0 1
//: ```
pub fn parse_markdown <(str)*>Document> (input):
    let lines <Vec<str>> str_split input "\n";
    let lines_mem <i32> alloc size_of<Vec<str>>;
    store<Vec<str>> lines_mem lines;
    let nlines <i32> get load<Vec<str>> lines_mem "len";

    let mut root <Vec<Node>> vec_new<Node>;
    let mut i <i32> 0;

    while lt i nlines:
        do:
            let line <str> safe_line lines_mem i;
            let t <str> str_trim line;

            if:
                eq len t 0
                then set i add i 1
                else:
                    if:
                        is_nest_break_line t
                        then:
                            set i add i 1;
                            ()
                        else:
                            if:
                                is_hr_line t
                                then:
                                    set root vec_push<Node> root Node::Hr;
                                    set i add i 1;
                                    ()
                                else:
                                    if:
                                        is_fence_start t
                                        then:
                                            let fr <FenceRes> parse_fence lines_mem nlines i;
                                            let fr_next_i <i32> get fr "next_i";
                                            let fr_cb <CodeBlockInfo> get fr "cb";
                                            let node <Node> Node::CodeBlock fr_cb;
                                            set root vec_push<Node> root node;
                                            set i fr_next_i;
                                            ()
                                        else:
                                            match parse_heading t:
                                                Option::Some h:
                                                    let mut kids <Vec<Node>> vec_new<Node>;
                                                    let mut j <i32> add i 1;
                                                    let mut done <bool> false;
                                                    while not done:
                                                        do:
                                                            if:
                                                                ge j nlines
                                                                then:
                                                                    set done true;
                                                                    ()
                                                                else:
                                                                    let li <str> safe_line lines_mem j;
                                                                    let tj <str> str_trim li;
                                                                    if:
                                                                        eq len tj 0
                                                                        then:
                                                                            set j add j 1;
                                                                            ()
                                                                        else:
                                                                            if:
                                                                                or is_heading_start tj or is_nest_break_line tj or is_hr_line tj is_fence_start tj
                                                                                then:
                                                                                    set done true;
                                                                                    ()
                                                                                else:
                                                                                    let pr <ParaRes> parse_paragraph lines_mem nlines j;
                                                                                    let pr_mem <i32> alloc size_of<ParaRes>;
                                                                                    store<ParaRes> pr_mem pr;
                                                                                    let pr_inlines <Vec<Inline>> get load<ParaRes> pr_mem "inlines";
                                                                                    let pr_next_i <i32> get load<ParaRes> pr_mem "next_i";
                                                                                    set kids vec_push<Node> kids Node::Paragraph pr_inlines;
                                                                                    set j pr_next_i;
                                                                                    ()
                                                    let sec <NestSection> NestSection get h "level" h kids;
                                                    set root vec_push<Node> root Node::Section sec;
                                                    set i j;
                                                    ()
                                                Option::None:
                                                    // Paragraph
                                                    let pr <ParaRes> parse_paragraph lines_mem nlines i;
                                                    let pr_mem <i32> alloc size_of<ParaRes>;
                                                    store<ParaRes> pr_mem pr;
                                                    let pr_inlines <Vec<Inline>> get load<ParaRes> pr_mem "inlines";
                                                    let pr_next_i <i32> get load<ParaRes> pr_mem "next_i";
                                                    let pnode <Node> Node::Paragraph pr_inlines;
                                                    set root vec_push<Node> root pnode;
                                                    set i pr_next_i;
                                                    ()

    Document root

// -----------------------------
// AST -> JSON (simple)
// -----------------------------

//: json_escape: 主な用途
//:
//: [目的/もくてき]:
//: - json_escape の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn json_escape <(str)*>str> (s):
    // Minimal escape: backslash and double-quote and newline
    let mut sb <StringBuilder> string_builder_new;
    let n <i32> len s;
    let mut i <i32> 0;
    while lt i n:
        do:
            let ch <i32> load_u8 add s add 4 i;
            if:
                eq ch 92
                then set sb sb_append sb "\\\\"
                else:
                    if:
                        eq ch 34
                        then set sb sb_append sb "\\\""
                        else:
                            if:
                                eq ch 10
                                then set sb sb_append sb "\\n"
                                else:
                                    set sb sb_append sb str_slice s i add i 1;
            set i add i 1;
    sb_build sb

//: inlines_to_json: 主な用途
//:
//: [目的/もくてき]:
//: - inlines_to_json の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn inlines_to_json <(Vec<Inline>)*>str> (v):
    let mut sb <StringBuilder> string_builder_new;
    set sb sb_append sb "[";
    let n <i32> get v "len";
    let v_data <i32> get v "data";
    let mut i <i32> 0;
    while lt i n:
        do:
            if:
                gt i 0
                then set sb sb_append sb ","
                else ()
            let it <Inline> load<Inline> add v_data mul i size_of<Inline>;
            match it:
                Inline::Text s:
                    set sb sb_append sb "{\"t\":\"text\",\"s\":\"";
                    set sb sb_append sb json_escape s;
                    set sb sb_append sb "\"}";
                Inline::Math m:
                    set sb sb_append sb "{\"t\":\"math\",\"s\":\"";
                    set sb sb_append sb json_escape m;
                    set sb sb_append sb "\"}";
                Inline::Ruby r:
                    set sb sb_append sb "{\"t\":\"ruby\",\"base\":\"";
                    set sb sb_append sb json_escape get r "base";
                    set sb sb_append sb "\",\"ruby\":\"";
                    set sb sb_append sb json_escape get r "ruby";
                    set sb sb_append sb "\"}";
                Inline::Gloss g:
                    set sb sb_append sb "{\"t\":\"gloss\",\"main\":\"";
                    set sb sb_append sb json_escape get g "main";
                    set sb sb_append sb "\",\"subs\":[";
                    let subs <Vec<str>> get g "subs";
                    let m <i32> get subs "len";
                    let subs_data <i32> get subs "data";
                    let mut j <i32> 0;
                    while lt j m:
                        do:
                            if:
                                gt j 0
                                then set sb sb_append sb ","
                                else ()
                            let ss <str> load<str> add subs_data mul j size_of<str>;
                            set sb sb_append sb "\"";
                            set sb sb_append sb json_escape ss;
                            set sb sb_append sb "\"";
                            set j add j 1;
                    set sb sb_append sb "]}";
            set i add i 1;
    set sb sb_append sb "]";
    sb_build sb

//: node_to_json: 主な用途
//:
//: [目的/もくてき]:
//: - node_to_json の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn node_to_json <(Node)*>str> (node):
    let mut sb <StringBuilder> string_builder_new;
    match node:
        Node::Hr:
            sb_build sb_append sb "{\"t\":\"hr\"}"
        Node::CodeBlock cb:
            let cb_info <str> get cb "info";
            let cb_code <str> get cb "code";
            set sb sb_append sb "{\"t\":\"code\",\"info\":\"";
            set sb sb_append sb json_escape cb_info;
            set sb sb_append sb "\",\"code\":\"";
            set sb sb_append sb json_escape cb_code;
            set sb sb_append sb "\"}";
            sb_build sb
        Node::Paragraph inl:
            set sb sb_append sb "{\"t\":\"p\",\"inl\":";
            set sb sb_append sb inlines_to_json inl;
            set sb sb_append sb "}";
            sb_build sb
        Node::Section sec:
            let sec_mem <i32> alloc size_of<NestSection>;
            store<NestSection> sec_mem sec;
            let sec_level <i32> get load<NestSection> sec_mem "level";
            let sec_heading <Heading> get load<NestSection> sec_mem "heading";
            let sec_children <Vec<Node>> get load<NestSection> sec_mem "children";
            let heading_mem <i32> alloc size_of<Heading>;
            store<Heading> heading_mem sec_heading;
            let heading_level <i32> get load<Heading> heading_mem "level";
            let heading_inlines <Vec<Inline>> get load<Heading> heading_mem "inlines";
            set sb sb_append sb "{\"t\":\"section\",\"level\":";
            set sb sb_append_i32 sb sec_level;
            set sb sb_append sb ",\"heading\":";
            set sb sb_append sb "{\"level\":";
            set sb sb_append_i32 sb heading_level;
            set sb sb_append sb ",\"inl\":";
            set sb sb_append sb inlines_to_json heading_inlines;
            set sb sb_append sb "}";
            set sb sb_append sb ",\"children\":";
            set sb sb_append sb nodes_to_json sec_children;
            set sb sb_append sb "}";
            sb_build sb

//: nodes_to_json: 主な用途
//:
//: [目的/もくてき]:
//: - nodes_to_json の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn nodes_to_json <(Vec<Node>)*>str> (nodes):
    let mut sb <StringBuilder> string_builder_new;
    set sb sb_append sb "[";
    let n <i32> get nodes "len";
    let nodes_data <i32> get nodes "data";
    let mut i <i32> 0;
    while lt i n:
        do:
            if:
                gt i 0
                then set sb sb_append sb ","
                else ()
            let nd <Node> load<Node> add nodes_data mul i size_of<Node>;
            set sb sb_append sb node_to_json nd;
            set i add i 1;
    set sb sb_append sb "]";
    sb_build sb

//: document_to_json: `Document` AST を JSON 文字列へ変換する
//:
//: [目的/もくてき]:
//: - AST の内部構造を機械可読な JSON に変換して、デバッグ・テスト・CLI 出力に利用します。
//:
//: [実装/じっそう]:
//: - ノード種別を `t` フィールドで表現し、子要素は再帰的にシリアライズします。
//: - 文字列は `json_escape` で最小限のエスケープを適用します。
//:
//: [注意/ちゅうい]:
//: - JSON スキーマは開発中であり、将来変更される可能性があります。
//:
//: [計算量/けいさんりょう]:
//: - O(m)（m は出力 JSON バイト数）。
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasm
//:| #import "alloc/string" as *
//:| #import "nm/parser" as *
//: fn main <()->i32> ():
//:     let d <Document> parse_markdown "plain\n";
//:     let j <str> document_to_json d;
//:     if str_starts_with j "{\"t\":\"doc\"" 0 1
//: ```
pub fn document_to_json <(Document)*>str> (doc):
    let mut sb <StringBuilder> string_builder_new;
    set sb sb_append sb "{\"t\":\"doc\",\"nodes\":";
    set sb sb_append sb nodes_to_json get doc "nodes";
    set sb sb_append sb "}";
    sb_build sb
