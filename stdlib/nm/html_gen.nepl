//: html_gen: nm/html_gen.nepl に関する機能を提供するライブラリ
//:
//: [目的/もくてき]:
//: - このモジュールの公開 API を提供します。
//: - 実装の変更時に最小限の doctest 実行経路を維持します。
//:
//: [注意/ちゅうい]:
//: - 利用時は各関数の「目的」「注意」「計算量」を確認してください。
//:
//: neplg2:test[skip]
//: ```neplg2
//:| #entry main
//:| #target wasi
//: ()
//: ```

#indent 4

#import "alloc/string" as *
#import "alloc/vec" as *
#import "core/option" as *
#import "core/mem" as *
#import "core/math" as *
#import "core/field" as *

#import "./parser" as *

//: escape_html: 主な用途
//:
//: [目的/もくてき]:
//: - escape_html の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn escape_html <(str)*>str> (s):
    // English comments required by user preference.
    let mut sb <StringBuilder> string_builder_new;
    let n <i32> len s;
    let mut i <i32> 0;
    while lt i n:
        do:
            let ch <i32> load_u8 add s add 4 i;
            if:
                eq ch 38
                then set sb sb_append sb "&amp;"
                else:
                    if:
                        eq ch 60
                        then set sb sb_append sb "&lt;"
                        else:
                            if:
                                eq ch 62
                                then set sb sb_append sb "&gt;"
                                else:
                                    if:
                                        eq ch 34
                                        then set sb sb_append sb "&quot;"
                                        else:
                                            set sb sb_append sb str_slice s i add i 1;
            set i add i 1;
    sb_build sb

//: render_inlines: 主な用途
//:
//: [目的/もくてき]:
//: - render_inlines の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn render_inlines <(Vec<Inline>)*>str> (v):
    let mut sb <StringBuilder> string_builder_new;
    let n <i32> get v "len";
    let v_data <i32> get v "data";
    let mut i <i32> 0;
    while lt i n:
        do:
            let it <Inline> load<Inline> add v_data mul i size_of<Inline>;
            match it:
                Inline::Text s:
                    set sb sb_append sb escape_html s;
                Inline::Math m:
                    // Keep delimiters as-is for KaTeX/MathJax.
                    set sb sb_append sb m;
                Inline::Ruby r:
                    set sb sb_append sb "<ruby>";
                    set sb sb_append sb escape_html (get r "base");
                    set sb sb_append sb "<rt>";
                    set sb sb_append sb escape_html (get r "ruby");
                    set sb sb_append sb "</rt></ruby>";
                Inline::Gloss g:
                    // Re-parse to allow ruby inside gloss segments.
                    set sb sb_append sb "<span class=\"gloss\">";
                    set sb sb_append sb "<span class=\"gloss-main\">";
                    set sb sb_append sb render_inlines parse_inlines get g "main";
                    set sb sb_append sb "</span>";
                    let subs <Vec<str>> get g "subs";
                    let m <i32> get subs "len";
                    let subs_data <i32> get subs "data";
                    let mut j <i32> 0;
                    while lt j m:
                        do:
                            let ss <str> load<str> add subs_data mul j size_of<str>;
                            set sb sb_append sb "<span class=\"gloss-sub\">";
                            set sb sb_append sb render_inlines parse_inlines ss;
                            set sb sb_append sb "</span>";
                            set j add j 1;
                    set sb sb_append sb "</span>";
            set i add i 1;
    sb_build sb

//: render_nodes: 主な用途
//:
//: [目的/もくてき]:
//: - render_nodes の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn render_nodes <(Vec<Node>)*>str> (nodes):
    let mut sb <StringBuilder> string_builder_new;
    let n <i32> get nodes "len";
    let nodes_data <i32> get nodes "data";
    let mut i <i32> 0;
    while lt i n:
        do:
            let nd <Node> load<Node> add nodes_data mul i size_of<Node>;
            match nd:
                Node::Hr:
                    set sb sb_append sb "<hr/>";
                Node::Paragraph inl:
                    set sb sb_append sb "<p>";
                    set sb sb_append sb render_inlines inl;
                    set sb sb_append sb "</p>";
                Node::CodeBlock cb:
                    set sb sb_append sb "<pre><code";
                    if:
                        gt len get cb "info" 0
                        then:
                            set sb sb_append sb " class=\"language-";
                            set sb sb_append sb escape_html get cb "info";
                            set sb sb_append sb "\"";
                            ()
                        else ();
                    set sb sb_append sb ">";
                    set sb sb_append sb escape_html get cb "code";
                    set sb sb_append sb "</code></pre>";
                Node::Section sec:
                    let sec_mem <i32> alloc size_of<NestSection>;
                    store<NestSection> sec_mem sec;
                    let sec_level <i32> get load<NestSection> sec_mem "level";
                    let sec_heading <Heading> get load<NestSection> sec_mem "heading";
                    let sec_children <Vec<Node>> get load<NestSection> sec_mem "children";
                    let heading_mem <i32> alloc size_of<Heading>;
                    store<Heading> heading_mem sec_heading;
                    let heading_level <i32> get load<Heading> heading_mem "level";
                    let heading_inlines <Vec<Inline>> get load<Heading> heading_mem "inlines";
                    set sb sb_append sb "<section class=\"nest level-";
                    set sb sb_append_i32 sb sec_level;
                    set sb sb_append sb "\">";
 
                    // Heading tag
                    if:
                        eq heading_level 1
                        then:
                            set sb sb_append sb "<h1>";
                            set sb sb_append sb render_inlines heading_inlines;
                            set sb sb_append sb "</h1>";
                            ()
                        else:
                            if:
                                eq heading_level 2
                                then:
                                    set sb sb_append sb "<h2>";
                                    set sb sb_append sb render_inlines heading_inlines;
                                    set sb sb_append sb "</h2>";
                                    ()
                                else:
                                    if:
                                        eq heading_level 3
                                        then:
                                            set sb sb_append sb "<h3>";
                                            set sb sb_append sb render_inlines heading_inlines;
                                            set sb sb_append sb "</h3>";
                                            ()
                                        else:
                                            if:
                                                eq heading_level 4
                                                then:
                                                    set sb sb_append sb "<h4>";
                                                    set sb sb_append sb render_inlines heading_inlines;
                                                    set sb sb_append sb "</h4>";
                                                    ()
                                                else:
                                                    if:
                                                        eq heading_level 5
                                                        then:
                                                            set sb sb_append sb "<h5>";
                                                            set sb sb_append sb render_inlines heading_inlines;
                                                            set sb sb_append sb "</h5>";
                                                            ()
                                                        else:
                                                            set sb sb_append sb "<h6>";
                                                            set sb sb_append sb render_inlines heading_inlines;
                                                            set sb sb_append sb "</h6>";
                                                            ();
 
                    set sb sb_append sb render_nodes sec_children;
                    set sb sb_append sb "</section>";
            set i add i 1;
    sb_build sb

//: render_document: `Document` AST を HTML 文字列へ変換する
//:
//: [目的/もくてき]:
//: - nm/parser が返した AST をブラウザ表示可能な HTML へ変換します。
//: - CLI の `--html` 出力や docs 生成で使用する最終段 API です。
//:
//: [実装/じっそう]:
//: - `render_nodes` / `render_inlines` でノード種別ごとに再帰展開します。
//: - 文字列部分は `escape_html` でエスケープし、math は `$...$` をそのまま保持します。
//:
//: [注意/ちゅうい]:
//: - 生成 HTML は安全側の最小エスケープ実装です。属性ホワイトリスト等は今後拡張します。
//:
//: [計算量/けいさんりょう]:
//: - O(m)（m は出力 HTML バイト数）。
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasm
//:| #import "alloc/string" as *
//:| #import "nm/parser" as *
//:| #import "nm/html_gen" as *
//: fn main <()->i32> ():
//:     let d <Document> parse_markdown "# T\n\nx\n";
//:     let h <str> render_document d;
//:     if and str_starts_with h "<section" str_ends_with h "</section>" 0 1
//: ```
pub fn render_document <(Document)*>str> (doc):
    render_nodes get doc "nodes"
