#indent 4

#import "std/math" as *
#import "std/mem" as *
#import "std/result" as *
#import "std/string" as *
#import "std/error" as *
#if[target=wasi]
#import "std/diag" as *

// test: 標準ライブラリ用の簡易テスト支援
//
// 目的:
// - assert 系関数と、文字列比較を提供します。
//
// 実装(アルゴリズム):
// - 失敗時はメッセージを表示して trap で異常終了させます。
//
// 注意(重要):
// - 失敗は回復不能です。テスト用途に限定してください。
// - 表示は WASI ターゲットのみ対応です。
//
// 計算量:
// - 文字列比較は O(n)、その他は O(1)

// test_str_eq: 文字列が等しいか判定する
//
// 目的:
// - a と b の内容が同じなら true を返します。
//
// 実装(アルゴリズム):
// - 長さ一致を確認し、バイト単位で比較します。
//
// 注意(重要):
// - UTF-8 のバイト列として比較します。
//
// 計算量:
// - O(n)
fn test_str_eq <(str,str)->bool> (a,b):
    let la <i32> load_i32 a;
    let lb <i32> load_i32 b;
    if:
        eq la lb
        then:
            test_str_eq_loop a b la 0
        else:
            false

// test_str_eq_loop: 文字列比較の内部ループ
//
// 目的:
// - i を進めながら各バイトを比較します。
//
// 実装(アルゴリズム):
// - 一致なら再帰、差異があれば false を返します。
//
// 注意(重要):
// - 呼び出し側で長さ一致を確認している前提です。
//
// 計算量:
// - O(n)
fn test_str_eq_loop <(str,str,i32,i32)->bool> (a,b,len,i):
    if:
        eq i len
        then:
            true
        else:
            let ba <i32> load_u8 add a add 4 i;
            let bb <i32> load_u8 add b add 4 i;
            if:
                eq ba bb
                then test_str_eq_loop a b len add i 1
                else false

// bool_to_str: bool を "true"/"false" に変換する
//
// 目的:
// - 失敗メッセージ用に bool を文字列化します。
//
// 実装(アルゴリズム):
// - if で分岐して固定文字列を返します。
//
// 注意(重要):
// - 文字列は定数です。
//
// 計算量:
// - O(1)
fn bool_to_str <(bool)->str> (b):
    if:
        b
        then:
            "true"
        else:
            "false"

// i32_to_str: i32 を文字列に変換する（符号対応）
//
// 目的:
// - 失敗メッセージ用に i32 を文字列化します。
//
// 実装(アルゴリズム):
// - 0 は "0" を返します。
// - 負数は符号を付け、正の値は from_i32 を使います。
//
// 注意(重要):
// - 最小値の符号反転は未定義になり得ます。
//
// 計算量:
// - O(d)
fn i32_to_str <(i32)*>str> (v):
    if:
        eq v 0
        then:
            "0"
        else:
            if:
                cond:
                    lt v 0
                then:
                    let a <i32> sub 0 v;
                    let s <str> from_i32 a;
                    concat "-" s
                else:
                    from_i32 v

// test_print_fail: 失敗メッセージを表示する（WASI）
//
// 目的:
// - msg を Failure として標準出力へ表示します。
//
// 実装(アルゴリズム):
// - diag_print_msg に渡して表示します。
//
// 注意(重要):
// - WASI ターゲットのみ対応です。
//
// 計算量:
// - O(n)
#if[target=wasi]
fn test_print_fail <(str)*>()> (msg):
    diag_print_msg msg

// test_print_fail: 失敗メッセージを無視する（WASM）
//
// 目的:
// - WASM ターゲットでのダミー実装です。
//
// 実装(アルゴリズム):
// - 何もしません。
//
// 注意(重要):
// - 表示は行いません。
//
// 計算量:
// - O(1)
#if[target=wasm]
fn test_print_fail <(str)*>()> (msg):
    ()

// test_fail: 失敗メッセージを出して異常終了する
//
// 目的:
// - msg を表示して trap で終了します。
//
// 実装(アルゴリズム):
// - test_print_fail を呼び、最後に trap を実行します。
//
// 注意(重要):
// - 失敗は回復不能です。
//
// 計算量:
// - O(n)
fn test_fail <(str)*>()> (msg):
    test_print_fail msg;
    trap;

// trap: 異常終了させる
//
// 目的:
// - 失敗を即座に検出するため異常終了します。
//
// 実装(アルゴリズム):
// - 0 除算で trap させます。
//
// 注意(重要):
// - 正常なプログラムでは使わないでください。
//
// 計算量:
// - O(1)
fn trap <()*>()> ():
    #wasm:
        i32.const 1
        i32.const 0
        i32.div_s
        drop

// fail: 失敗時に異常終了する
//
// 目的:
// - 失敗時の到達不能箇所として使います。
//
// 実装(アルゴリズム):
// - trap を呼びます。
//
// 注意(重要):
// - 呼び出すと即座に異常終了します。
//
// 計算量:
// - O(1)
fn fail <(str)*>()> (msg):
    test_print_fail msg;
    trap

// assert: 条件が false のとき失敗する
//
// 目的:
// - ok が false ならメッセージを表示して trap します。
//
// 実装(アルゴリズム):
// - if で分岐し、false なら test_fail を呼びます。
//
// 注意(重要):
// - ok は bool である必要があります。
//
// 計算量:
// - O(1)
fn assert <(bool)*>()> (ok):
    if:
        ok
        then ()
        else:
            test_fail "assert failed";

// assert_eq_i32: i32 の等値を検証する
//
// 目的:
// - expected と actual が等しいことを保証します。
//
// 実装(アルゴリズム):
// - eq の結果が false なら詳細メッセージを作って test_fail します。
//
// 注意(重要):
// - i32 専用です。
//
// 計算量:
// - O(1)
fn assert_eq_i32 <(i32,i32)*>()> (expected, actual):
    if:
        eq expected actual
        then ()
        else:
            let se <str> i32_to_str expected;
            let sa <str> i32_to_str actual;
            let m0 <str> concat "assert_eq_i32 failed: expected=" se;
            let m1 <str> concat m0 " actual=";
            let m2 <str> concat m1 sa;
            test_fail m2;

// assert_ne: bool が等しくないことを検証する
//
// 目的:
// - a と b が同じなら詳細メッセージを作って test_fail します。
//
// 実装(アルゴリズム):
// - a の値で分岐し、b との一致を確認します。
//
// 注意(重要):
// - bool 専用です。
//
// 計算量:
// - O(1)
fn assert_ne <(bool,bool)*>()> (a, b):
    if:
        a
        then:
            if:
                b
                then:
                    let sa <str> bool_to_str a;
                    let sb <str> bool_to_str b;
                    let m0 <str> concat "assert_ne failed: a=" sa;
                    let m1 <str> concat m0 " b=";
                    let m2 <str> concat m1 sb;
                    test_fail m2;
                else ()
        else:
            if:
                b
                then ()
                else:
                    let sa <str> bool_to_str a;
                    let sb <str> bool_to_str b;
                    let m0 <str> concat "assert_ne failed: a=" sa;
                    let m1 <str> concat m0 " b=";
                    let m2 <str> concat m1 sb;
                    test_fail m2;

// assert_str_eq: 文字列が等しいことを検証する
//
// 目的:
// - expected と actual が同じであることを保証します。
//
// 実装(アルゴリズム):
// - test_str_eq で比較し、false なら詳細メッセージを作って test_fail します。
//
// 注意(重要):
// - UTF-8 のバイト列として比較します。
//
// 計算量:
// - O(n)
fn assert_str_eq <(str,str)*>()> (expected, actual):
    if:
        test_str_eq expected actual
        then ()
        else:
            let m0 <str> concat "assert_str_eq failed: expected=\"" expected;
            let m1 <str> concat m0 "\" actual=\"";
            let m2 <str> concat m1 actual;
            let m3 <str> concat m2 "\"";
            test_fail m3;

// assert_ok_i32: Result が Ok であることを検証する
//
// 目的:
// - Result::Ok を受け付け、Err なら詳細メッセージを作って test_fail します。
//
// 実装(アルゴリズム):
// - match で Ok/Err を分岐します。
//
// 注意(重要):
// - Result<i32,i32> 専用です。
//
// 計算量:
// - O(1)
fn assert_ok_i32 <(Result<i32,i32>)*>()> (r):
    match r:
        Result::Ok v:
            ()
        Result::Err e:
            let se <str> i32_to_str e;
            let m0 <str> concat "assert_ok_i32 failed: Err=" se;
            test_fail m0;

// assert_err_i32: Result が Err であることを検証する
//
// 目的:
// - Result::Err を受け付け、Ok なら詳細メッセージを作って test_fail します。
//
// 実装(アルゴリズム):
// - match で Ok/Err を分岐します。
//
// 注意(重要):
// - Result<i32,i32> 専用です。
//
// 計算量:
// - O(1)
fn assert_err_i32 <(Result<i32,i32>)*>()> (r):
    match r:
        Result::Ok v:
            let sv <str> i32_to_str v;
            let m0 <str> concat "assert_err_i32 failed: Ok=" sv;
            test_fail m0;
        Result::Err e:
            ()
