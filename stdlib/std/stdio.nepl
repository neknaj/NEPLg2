//: stdio: std/stdio.nepl に関する機能を提供するライブラリ
//:
//: [目的/もくてき]:
//: - このモジュールの公開 API を提供します。
//: - 実装の変更時に最小限の doctest 実行経路を維持します。
//:
//: [注意/ちゅうい]:
//: - 詳細な関数別ドキュメントは段階的に追記します。
//:
//: neplg2:test[skip]
//: ```neplg2
//:| #entry main
//:| #target wasi
//: ()
//: ```

#indent 4

#extern "wasi_snapshot_preview1" "fd_read" fn fd_read <(i32,i32,i32,i32)->i32>
#extern "wasi_snapshot_preview1" "fd_write" fn fd_write <(i32,i32,i32,i32)->i32>

#import "core/mem" as *
#import "core/math" as *

// stdio: WASI 標準入出力
//
// 目的:
// - WASI の fd_read/fd_write を使った簡易 I/O を提供します。
//
// 実装(アルゴリズム):
// - iovec を作って fd_read/fd_write を呼びます。
// - 文字列は [len][bytes] の形式です。
//
// 注意(重要):
// - 入力は固定長バッファのため長い入力は切り捨てられます。
// - 失敗時は空文字列や無視で返します（Result 化は未実装）。
//
// 計算量:
// - 文字列長に比例

// print: 文字列を標準出力へ出す
//
// 目的:
// - s をそのまま stdout に書き込みます。
//
// 実装(アルゴリズム):
// - iovec を 1 要素で作り、fd_write を呼びます。
//
// 注意(重要):
// - エラーは無視します。
//
// 計算量:
// - O(n)
//: print: 関数の概要
//:
//: [目的/もくてき]:
//: - print が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn print <(str)*>()> (s):
    let iov <i32> alloc 8;
    store_i32 iov add s 4;
    store_i32 add iov 4 load_i32 s;
    let nwritten <i32> alloc 4;
    store_i32 nwritten 0;
    let _errno <i32> fd_write 1 iov 1 nwritten;
    ()

// read_all: 標準入力を読み込む（固定長）
//
// 目的:
// - stdin から最大 4096 バイト読み込み、文字列として返します。
//
// 実装(アルゴリズム):
// - 1 回の fd_read で読み込みます。
//
// 注意(重要):
// - 失敗時は長さ 0 を返します。
// - 入力が 4096 バイトを超える場合は切り捨てます。
//
// 計算量:
// - O(n)
//: read_all: 関数の概要
//:
//: [目的/もくてき]:
//: - read_all が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn read_all <()*>str> ():
    let cap <i32> 4096;
    let out <i32> alloc add 4 cap;
    let iov <i32> alloc 8;
    store_i32 iov add out 4;
    store_i32 add iov 4 cap;

    let nread <i32> alloc 4;
    store_i32 nread 0;
    let errno <i32> fd_read 0 iov 1 nread;

    if:
        eq errno 0
        then:
            let n <i32> load_i32 nread;
            store_i32 out n;
            out
        else:
            store_i32 out 0;
            out

// read_line: 1 行読み込む
//
// 目的:
// - newline か EOF まで読み込み、文字列として返します。
//
// 実装(アルゴリズム):
// - 1 バイトずつ読み取り、改行か EOF で停止します。
//
// 注意(重要):
// - 最大 1024 バイトまでです。
// - 失敗時は短い文字列になる可能性があります。
//
// 計算量:
// - O(n)
//: read_line: 関数の概要
//:
//: [目的/もくてき]:
//: - read_line が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn read_line <()*>str> ():
    let cap <i32> 1024;
    let out <i32> alloc add 4 cap;
    let iov <i32> alloc 8;
    let nread <i32> alloc 4;
    let mut len <i32> 0;
    let mut done <i32> 0;

    while eq done 0:
        if:
            lt len cap
            then:
                store_i32 iov add out add 4 len;
                store_i32 add iov 4 1;
                store_i32 nread 0;
                let errno <i32> fd_read 0 iov 1 nread;
                if:
                    eq errno 0
                    then:
                        let n <i32> load_i32 nread;
                        if:
                            eq n 0
                            then:
                                set done 1;
                            else:
                                let b <i32> load_u8 add out add 4 len;
                                if:
                                    eq b 10
                                    then:
                                        set done 1;
                                    else:
                                        set len add len 1;
                    else:
                        set done 1;
            else:
                set done 1;
    store_i32 out len;
    out

// println: 改行付き出力
//
// 目的:
// - s を出力し、改行を追加します。
//
// 実装(アルゴリズム):
// - print を 2 回呼びます。
//
// 注意(重要):
// - 改行は "\n" 固定です。
//
// 計算量:
// - O(n)
//: println: 関数の概要
//:
//: [目的/もくてき]:
//: - println が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn println <(str)*>()> (s):
    print s;
    print "\n";
    ()

// print_i32: i32 を文字列にして出力
//
// 目的:
// - v を 10 進文字列にして出力します。
//
// 実装(アルゴリズム):
// - from_i32 相当の手順で文字列を生成し、print します。
//
// 注意(重要):
// - 負数は未対応のため "0" を出力します（暫定動作）。
//
// 計算量:
// - O(d)
//: print_i32: 関数の概要
//:
//: [目的/もくてき]:
//: - print_i32 が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn print_i32 <(i32)*>()> (v):
    let s <i32> :
        if:
            eq v 0
            then:
                let out0 <i32> alloc 5;
                store_i32 out0 1;
                store_u8 add out0 4 48;
                out0
            else:
                if:
                    cond:
                        lt v 0
                    then:
                        let outn <i32> alloc 5;
                        store_i32 outn 1;
                        store_u8 add outn 4 48;
                        outn
                    else:
                        let scratch <i32> alloc 16;
                        let mut idx <i32> 0;
                        let mut n <i32> v;

                        while lt 0 n:
                            do:
                                let rem <i32> mod_s n 10;
                                store_u8 add scratch idx add 48 rem;
                                set idx add idx 1;
                                set n div_s n 10;

                        let out <i32> alloc add 4 idx;
                        store_i32 out idx;

                        let mut i <i32> 0;
                        while lt i idx:
                            do:
                                let rev <i32> sub idx add i 1;
                                let b <i32> load_u8 add scratch rev;
                                store_u8 add out add 4 i b;
                                set i add i 1;

                        out
    print s;
    ()

// println_i32: i32 を改行付きで出力
//
// 目的:
// - print_i32 の後に改行を出力します。
//
// 実装(アルゴリズム):
// - print_i32 と print("\n") を呼びます。
//
// 注意(重要):
// - 改行は常に追加されます。
//
// 計算量:
// - O(d)
//: println_i32: 関数の概要
//:
//: [目的/もくてき]:
//: - println_i32 が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn println_i32 <(i32)*>()> (v):
    print_i32 v;
    print "\n";

// ansi_reset: 色リセットコード
//
// 目的:
// - ANSI のリセットコードを返します。
//
// 実装(アルゴリズム):
// - 文字列リテラルを返します。
//
// 注意(重要):
// - 端末が ANSI に対応している必要があります。
//
// 計算量:
// - O(1)
//: ansi_reset: 関数の概要
//:
//: [目的/もくてき]:
//: - ansi_reset が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn ansi_reset <()->str> ():
    "\x1b[0m"

// ansi_bold: 太字コード
//
// 目的:
// - ANSI の太字コードを返します。
//
// 実装(アルゴリズム):
// - 文字列リテラルを返します。
//
// 注意(重要):
// - 端末が ANSI に対応している必要があります。
//
// 計算量:
// - O(1)
//: ansi_bold: 関数の概要
//:
//: [目的/もくてき]:
//: - ansi_bold が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn ansi_bold <()->str> ():
    "\x1b[1m"

// ansi_underline: 下線コード
//
// 目的:
// - ANSI の下線コードを返します。
//
// 実装(アルゴリズム):
// - 文字列リテラルを返します。
//
// 注意(重要):
// - 端末が ANSI に対応している必要があります。
//
// 計算量:
// - O(1)
//: ansi_underline: 関数の概要
//:
//: [目的/もくてき]:
//: - ansi_underline が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn ansi_underline <()->str> ():
    "\x1b[4m"

// ansi_red: 赤色コード
//
// 目的:
// - ANSI の赤色コードを返します。
//
// 実装(アルゴリズム):
// - 文字列リテラルを返します。
//
// 注意(重要):
// - 端末が ANSI に対応している必要があります。
//
// 計算量:
// - O(1)
//: ansi_red: 関数の概要
//:
//: [目的/もくてき]:
//: - ansi_red が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn ansi_red <()->str> ():
    "\x1b[31m"

// ansi_green: 緑色コード
//
// 目的:
// - ANSI の緑色コードを返します。
//
// 実装(アルゴリズム):
// - 文字列リテラルを返します。
//
// 注意(重要):
// - 端末が ANSI に対応している必要があります。
//
// 計算量:
// - O(1)
//: ansi_green: 関数の概要
//:
//: [目的/もくてき]:
//: - ansi_green が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn ansi_green <()->str> ():
    "\x1b[32m"

// ansi_yellow: 黄色コード
//
// 目的:
// - ANSI の黄色コードを返します。
//
// 実装(アルゴリズム):
// - 文字列リテラルを返します。
//
// 注意(重要):
// - 端末が ANSI に対応している必要があります。
//
// 計算量:
// - O(1)
//: ansi_yellow: 関数の概要
//:
//: [目的/もくてき]:
//: - ansi_yellow が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn ansi_yellow <()->str> ():
    "\x1b[33m"

// ansi_blue: 青色コード
//
// 目的:
// - ANSI の青色コードを返します。
//
// 実装(アルゴリズム):
// - 文字列リテラルを返します。
//
// 注意(重要):
// - 端末が ANSI に対応している必要があります。
//
// 計算量:
// - O(1)
//: ansi_blue: 関数の概要
//:
//: [目的/もくてき]:
//: - ansi_blue が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn ansi_blue <()->str> ():
    "\x1b[34m"

// ansi_magenta: マゼンタコード
//
// 目的:
// - ANSI のマゼンタコードを返します。
//
// 実装(アルゴリズム):
// - 文字列リテラルを返します。
//
// 注意(重要):
// - 端末が ANSI に対応している必要があります。
//
// 計算量:
// - O(1)
//: ansi_magenta: 関数の概要
//:
//: [目的/もくてき]:
//: - ansi_magenta が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn ansi_magenta <()->str> ():
    "\x1b[35m"

// ansi_cyan: シアンコード
//
// 目的:
// - ANSI のシアンコードを返します。
//
// 実装(アルゴリズム):
// - 文字列リテラルを返します。
//
// 注意(重要):
// - 端末が ANSI に対応している必要があります。
//
// 計算量:
// - O(1)
//: ansi_cyan: 関数の概要
//:
//: [目的/もくてき]:
//: - ansi_cyan が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn ansi_cyan <()->str> ():
    "\x1b[36m"

// ansi_white: 白色コード
//
// 目的:
// - ANSI の白色コードを返します。
//
// 実装(アルゴリズム):
// - 文字列リテラルを返します。
//
// 注意(重要):
// - 端末が ANSI に対応している必要があります。
//
// 計算量:
// - O(1)
//: ansi_white: 関数の概要
//:
//: [目的/もくてき]:
//: - ansi_white が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn ansi_white <()->str> ():
    "\x1b[37m"

// ansi_gray: 灰色コード
//
// 目的:
// - ANSI の灰色コードを返します。
//
// 実装(アルゴリズム):
// - 文字列リテラルを返します。
//
// 注意(重要):
// - 端末が ANSI に対応している必要があります。
//
// 計算量:
// - O(1)
//: ansi_gray: 関数の概要
//:
//: [目的/もくてき]:
//: - ansi_gray が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn ansi_gray <()->str> ():
    "\x1b[90m"

// print_color: 色付きで出力する
//
// 目的:
// - color を適用して s を出力し、最後にリセットします。
//
// 実装(アルゴリズム):
// - color/s/reset の順に print します。
//
// 注意(重要):
// - color は ANSI コード文字列を想定します。
//
// 計算量:
// - O(n)
//: print_color: 関数の概要
//:
//: [目的/もくてき]:
//: - print_color が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn print_color <(str,str)*>()> (color, s):
    print color;
    print s;
    print ansi_reset;
    ()

// println_color: 色付きで改行出力
//
// 目的:
// - print_color の後に改行を追加します。
//
// 実装(アルゴリズム):
// - print_color と print("\n") を呼びます。
//
// 注意(重要):
// - 改行は常に追加されます。
//
// 計算量:
// - O(n)
//: println_color: 関数の概要
//:
//: [目的/もくてき]:
//: - println_color が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn println_color <(str,str)*>()> (color, s):
    print_color color s;
    print "\n";

#if[profile=debug]
// debug: デバッグ出力
//
// 目的:
// - debug ビルド時のみ出力します。
//
// 実装(アルゴリズム):
// - print を呼びます。
//
// 注意(重要):
// - release では no-op です。
//
// 計算量:
// - O(n)
//: debug: 関数の概要
//:
//: [目的/もくてき]:
//: - debug が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn debug <(str)*>()> (s):
    print s;
    ()

// debug_color: 色付きデバッグ出力
//
// 目的:
// - debug ビルド時のみ色付きで出力します。
//
// 実装(アルゴリズム):
// - print_color を呼びます。
//
// 注意(重要):
// - ANSI 対応端末が必要です。
// - release では no-op です。
//
// 計算量:
// - O(n)
//: debug_color: 関数の概要
//:
//: [目的/もくてき]:
//: - debug_color が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn debug_color <(str,str)*>()> (color, s):
    print_color color s;
    ()

#if[profile=release]
// debug: デバッグ出力（release では無効）
//
// 目的:
// - release では何もしません。
//
// 実装(アルゴリズム):
// - 空関数です。
//
// 注意(重要):
// - 文字列は使用されません。
//
// 計算量:
// - O(1)
//: debug: 関数の概要
//:
//: [目的/もくてき]:
//: - debug が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn debug <(str)*>()> (_s):
    ()

// debug_color: 色付きデバッグ出力（release では無効）
//
// 目的:
// - release では何もしません。
//
// 実装(アルゴリズム):
// - 空関数です。
//
// 注意(重要):
// - 文字列は使用されません。
//
// 計算量:
// - O(1)
//: debug_color: 関数の概要
//:
//: [目的/もくてき]:
//: - debug_color が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn debug_color <(str,str)*>()> (_color, _s):
    ()

#if[profile=debug]
// debugln: デバッグ出力（改行付き）
//
// 目的:
// - debug ビルド時のみ改行付きで出力します。
//
// 実装(アルゴリズム):
// - println を呼びます。
//
// 注意(重要):
// - release では no-op です。
//
// 計算量:
// - O(n)
//: debugln: 関数の概要
//:
//: [目的/もくてき]:
//: - debugln が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn debugln <(str)*>()> (s):
    println s;
    ()

// debugln_color: 色付きデバッグ出力（改行付き）
//
// 目的:
// - debug ビルド時のみ色付きで改行出力します。
//
// 実装(アルゴリズム):
// - print_color と print("\n") を呼びます。
//
// 注意(重要):
// - ANSI 対応端末が必要です。
// - release では no-op です。
//
// 計算量:
// - O(n)
//: debugln_color: 関数の概要
//:
//: [目的/もくてき]:
//: - debugln_color が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn debugln_color <(str,str)*>()> (color, s):
    print_color color s;
    print "\n";
    ()

#if[profile=release]
// debugln: デバッグ出力（release では無効）
//
// 目的:
// - release では何もしません。
//
// 実装(アルゴリズム):
// - 空関数です。
//
// 注意(重要):
// - 文字列は使用されません。
//
// 計算量:
// - O(1)
//: debugln: 関数の概要
//:
//: [目的/もくてき]:
//: - debugln が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn debugln <(str)*>()> (_s):
    ()

// debugln_color: 色付きデバッグ出力（release では無効）
//
// 目的:
// - release では何もしません。
//
// 実装(アルゴリズム):
// - 空関数です。
//
// 注意(重要):
// - 文字列は使用されません。
//
// 計算量:
// - O(1)
//: debugln_color: 関数の概要
//:
//: [目的/もくてき]:
//: - debugln_color が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn debugln_color <(str,str)*>()> (_color, _s):
    ()
