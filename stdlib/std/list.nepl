#indent 4

#import "std/mem"
#use std::mem::*
#import "std/math"
#use std::math::*
#import "std/option"
#use std::option::*

// Generic linked list
// Node layout: [value:.T][next:i32]

fn list_nil <.T> <()->i32> ():
    0

fn list_cons <.T> <(.T,i32)*>i32> (head, tail):
    let node_size <i32> add size_of<.T> 4
    let node <i32> alloc node_size
    store<.T> node head
    store_i32 add node size_of<.T> tail
    node

fn list_head <.T> <(i32)->Option<.T>> (lst):
    if:
        cond:
            eq lst 0
        then:
            none<.T>
        else:
            some<.T> load<.T> lst

fn list_tail <.T> <(i32)->i32> (lst):
    if:
        cond:
            eq lst 0
        then:
            0
        else:
            load_i32 add lst size_of<.T>

fn list_is_empty <.T> <(i32)->bool> (lst):
    eq lst 0

fn list_len <.T> <(i32)*>i32> (lst):
    let mut count <i32> 0
    let mut cur <i32> lst
    while ne cur 0:
        set count add count 1
        set cur load_i32 add cur size_of<.T>
    count

fn list_get <.T> <(i32,i32)*>Option<.T>> (lst, idx):
    if:
        cond:
            lt idx 0
        then:
            none<.T>
        else:
            let mut cur <i32> lst
            let mut i <i32> 0
            while lt i idx:
                if:
                    cond:
                        eq cur 0
                    then:
                        // return early via break would be nice; use flag instead
                        set i idx
                    else:
                        set cur load_i32 add cur size_of<.T>
                        set i add i 1
            if:
                cond:
                    eq cur 0
                then:
                    none<.T>
                else:
                    some<.T> load<.T> cur

fn list_free <.T> <(i32)*>()> (lst):
    let node_size <i32> add size_of<.T> 4
    let mut cur <i32> lst
    while ne cur 0:
        let next <i32> load_i32 add cur size_of<.T>
        dealloc cur node_size
        set cur next
