#indent 4

#import "std/mem"
#use std::mem::*
#import "std/result"
#use std::result::*
#import "std/option"
#use std::option::*
#import "std/math"
#use std::math::*


fn len <(str)->i32> (s):
    load_i32 s


fn from_i32 <(i32)*>str> (x):
    // Convert i32 to UTF-8 string with layout: [len:i32][bytes...]

    if:
        eq x 0
        then:
            let out0 <i32> alloc 5;
            store_i32 out0 1;
            store_u8 add out0 4 48;    // '0'
            out0
        else:
            // For incremental safety: only handle positives first.
            if:
                cond:
                    lt x 0
                then:
                    // Temporary: reuse "0" to keep behavior well-defined
                    let outn <i32> alloc 5;
                    store_i32 outn 1;
                    store_u8 add outn 4 48;
                    outn
                else:
                    // Scratch buffer (LSB-first digits). 16 bytes is enough for i32.
                    let scratch <i32> alloc 16;
                    let mut idx <i32> 0;
                    let mut n <i32> x;

                    while lt 0 n:
                        let rem <i32> mod_s n 10;
                        store_u8 add scratch idx add 48 rem;
                        set idx add idx 1;
                        set n div_s n 10;

                    // Allocate final string: 4 bytes length + idx bytes
                    let out <i32> alloc add 4 idx;
                    store_i32 out idx;

                    // Reverse digits into output
                    let mut i <i32> 0;
                    while lt i idx:
                        let rev <i32> sub idx add i 1;
                        let b <i32> load_u8 add scratch rev;
                        store_u8 add out add 4 i b;
                        set i add i 1;

                    out


fn to_i32 <(str)*>ResultI32> (s):
    // Parse decimal UTF-8 bytes produced by `from_i32`.
    // Incremental safety: accept non-negative only.

    let n <i32> load_i32 s;
    if:
        cond:
            eq n 0
        then:
            ResultI32::Err 1
        else:
            let mut i <i32> 0;
            let mut res <i32> 0;
            let mut ok <i32> 1;

            // Reject negative for now
            let first <i32> load_u8 add s 4;
            if:
                cond:
                    eq first 45
                then:
                    ResultI32::Err 1
                else:
                    while lt i n:
                        let b <i32> load_u8 add s add 4 i;
                        let digit <i32> sub b 48;

                        if:
                            cond:
                                lt digit 0
                            then:
                                set ok 0;
                                set i n;
                            else:
                                if:
                                    le digit 9
                                    then:
                                        set res add mul res 10 digit;
                                        set i add i 1;
                                    else:
                                        set ok 0;
                                        set i n;

            if eq ok 1:
                ResultI32::Ok res
                else:
                    ResultI32::Err 1


fn find <(str,str)*>OptionI32> (_s, _pat):
    OptionI32::None
