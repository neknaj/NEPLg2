#indent 4

#import "std/mem"
#use std::mem::*
#import "std/result"
#use std::result::*
#import "std/option"
#use std::option::*
#import "std/math"
#use std::math::*


fn len <(str)->i32> (s):
    load_i32 s

fn concat <(str,str)*>str> (a,b):
    let la <i32> load_i32 a;
    let lb <i32> load_i32 b;
    let total <i32> add la lb;
    let out <i32> alloc add 4 total;
    store_i32 out total;
    let mut i <i32> 0;
    while lt i la:
        let ch <i32> load_u8 add a add 4 i;
        store_u8 add out add 4 i ch;
        set i add i 1;
    let mut j <i32> 0;
    while lt j lb:
        let ch <i32> load_u8 add b add 4 j;
        store_u8 add out add 4 add la j ch;
        set j add j 1;
    out

fn concat3 <(str,str,str)*>str> (a,b,c):
    let ab <str> concat a b;
    concat ab c

fn str_eq <(str,str)->bool> (a,b):
    let la <i32> load_i32 a;
    let lb <i32> load_i32 b;
    if:
        eq la lb
        then str_eq_loop a b la 0
        else false

fn str_eq_loop <(str,str,i32,i32)->bool> (a,b,len,i):
    if:
        eq i len
        then:
            true
        else:
            let ba <i32> load_u8 add a add 4 i;
            let bb <i32> load_u8 add b add 4 i;
            if:
                eq ba bb
                then str_eq_loop a b len add i 1
                else false


fn from_i32 <(i32)*>str> (x):
    // Convert i32 to UTF-8 string with layout: [len:i32][bytes...]

    if:
        eq x 0
        then:
            let out0 <i32> alloc 5;
            store_i32 out0 1;
            store_u8 add out0 4 48;    // '0'
            out0
        else:
            // For incremental safety: only handle positives first.
            if:
                cond:
                    lt x 0
                then:
                    // Temporary: reuse "0" to keep behavior well-defined
                    let outn <i32> alloc 5;
                    store_i32 outn 1;
                    store_u8 add outn 4 48;
                    outn
                else:
                    // Scratch buffer (LSB-first digits). 16 bytes is enough for i32.
                    let scratch <i32> alloc 16;
                    let mut idx <i32> 0;
                    let mut n <i32> x;

                    while lt 0 n:
                        let rem <i32> mod_s n 10;
                        store_u8 add scratch idx add 48 rem;
                        set idx add idx 1;
                        set n div_s n 10;

                    // Allocate final string: 4 bytes length + idx bytes
                    let out <i32> alloc add 4 idx;
                    store_i32 out idx;

                    // Reverse digits into output
                    let mut i <i32> 0;
                    while lt i idx:
                        let rev <i32> sub idx add i 1;
                        let b <i32> load_u8 add scratch rev;
                        store_u8 add out add 4 i b;
                        set i add i 1;

                    out


fn to_i32 <(str)*>Result<i32,i32>> (s):
    // Parse decimal UTF-8 bytes produced by `from_i32`.
    // Incremental safety: accept non-negative only.

    let n <i32> load_i32 s;
    let mut i <i32> 0;
    let mut res <i32> 0;
    let mut ok <i32> 1;

    if:
        cond:
            eq n 0
        then:
            set ok 0;
        else:
            let first <i32> load_u8 add s 4;
            if:
                cond:
                    eq first 45
                then:
                    set ok 0;
                else:
                    while lt i n:
                        let b <i32> load_u8 add s add 4 i;
                        let digit <i32> sub b 48;

                        if:
                            cond:
                                lt digit 0
                            then:
                                set ok 0;
                                set i n;
                            else:
                                if:
                                    cond:
                                        le digit 9
                                    then:
                                        set res add mul res 10 digit;
                                        set i add i 1;
                                    else:
                                        set ok 0;
                                        set i n;

    if:
        cond:
            eq ok 1
        then:
            Result::Ok <i32,i32> res
        else:
            Result::Err <i32,i32> 1


fn find <(str,str)*>Option<i32>> (_s, _pat):
    Option::None <i32>
