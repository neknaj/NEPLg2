#indent 4

#import "std/mem" as *
#import "std/option" as *
#import "std/result" as *

enum ErrorKind:
    Failure
    OutOfMemory
    IndexOutOfBounds
    KeyNotFound
    InvalidUtf8
    ParseError
    IoError
    Other

struct Span:
    file_id <i32>
    start <i32>
    end <i32>

struct Error:
    kind <ErrorKind>
    msg <str>
    span <Option<Span>>
    // source <Option<Error>>

fn callsite_span <()->Span> ():
    #intrinsic "callsite_span" <Span> ()

fn error_new <(ErrorKind,str)->Error> (kind, msg):
    Error kind msg none<Span>

fn error_with_span <(Error,Span)->Error> (e, sp):
    Error e.kind e.msg some<Span> sp

fn error_with_source <(Error,Error)->Error> (outer, inner):
    // Drop inner cause to avoid recursion
    Error outer.kind outer.msg outer.span

fn fail <(str)->Error> (msg):
    let e <Error> error_new ErrorKind::Failure msg;
    let s <Span> Span 0 0 0; // callsite_span();
    error_with_span e s

fn context <(Error,str)->Error> (cause, msg):
    let e <Error> error_new ErrorKind::Other msg;
    let s <Span> Span 0 0 0; // callsite_span();
    let outer <Error> error_with_span e s;
    error_with_source outer cause

fn result_context <.T> <(Result<.T, Error>, str)->Result<.T, Error>> (r, msg):
    match r:
        Result::Ok v:
            ok<.T, Error> v
        Result::Err e:
            err<.T, Error> context e msg
