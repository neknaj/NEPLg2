#indent 4

#import "std/mem"
#use std::mem::*
#import "std/math"
#use std::math::*
#import "std/option"
#use std::option::*

// Generic Vec<.T> - dynamically resizing array
// Layout: [len:i32][cap:i32][data_ptr:i32]

struct Vec<.T>:
    len <i32>
    cap <i32>
    data <i32>

fn vec_new <.T> <()*>Vec<.T>> ():
    let cap <i32> 8
    let data <i32> alloc mul cap size_of<.T>
    Vec<.T> 0 cap data

fn vec_with_capacity <.T> <(i32)*>Vec<.T>> (cap):
    let data <i32> alloc mul cap size_of<.T>
    Vec<.T> 0 cap data

fn vec_len <.T> <(Vec<.T>)->i32> (v):
    v.len

fn vec_cap <.T> <(Vec<.T>)->i32> (v):
    v.cap

fn vec_is_empty <.T> <(Vec<.T>)->bool> (v):
    eq v.len 0

fn vec_push <.T> <(Vec<.T>,.T)*>Vec<.T>> (v, item):
    if:
        eq v.len v.cap
        then:
            // grow
            let new_cap <i32> mul v.cap 2
            let new_data <i32> realloc v.data mul v.cap size_of<.T> mul new_cap size_of<.T>
            let offset <i32> mul v.len size_of<.T>
            store<.T> add new_data offset item
            Vec<.T> add v.len 1 new_cap new_data
        else:
            let offset <i32> mul v.len size_of<.T>
            store<.T> add v.data offset item
            Vec<.T> add v.len 1 v.cap v.data

fn vec_get <.T> <(Vec<.T>,i32)->Option<.T>> (v, idx):
    if:
        lt idx 0
        then none<.T>
        else:
            if:
                le v.len idx
                then none<.T>
                else:
                    let offset <i32> mul idx size_of<.T>
                    some<.T> load<.T> add v.data offset

fn vec_set <.T> <(Vec<.T>,i32,.T)*>()> (v, idx, item):
    if:
        lt idx 0
        then ()
        else:
            if:
                le v.len idx
                then ()
                else:
                    let offset <i32> mul idx size_of<.T>
                    store<.T> add v.data offset item

fn vec_pop <.T> <(Vec<.T>)*>(Vec<.T>,Option<.T>)> (v):
    if:
        eq v.len 0
        then (v, none<.T>)
        else:
            let new_len <i32> sub v.len 1
            let offset <i32> mul new_len size_of<.T>
            let item <.T> load<.T> add v.data offset
            (Vec<.T> new_len v.cap v.data, some<.T> item)

fn vec_clear <.T> <(Vec<.T>)*>Vec<.T>> (v):
    Vec<.T> 0 v.cap v.data

fn vec_free <.T> <(Vec<.T>)*>()> (v):
    dealloc v.data mul v.cap size_of<.T>
