#indent 4

#import "std/mem" as *
#import "std/math" as *
#import "std/option" as *

// Generic Vec<.T> - dynamically resizing array
// Layout: [len:i32][cap:i32][data_ptr:i32]

struct Vec<.T>:
    len <i32>
    cap <i32>
    data <i32>

fn vec_new <.T> <()*>Vec<.T>> ():
    let cap <i32> 8
    let data <i32> alloc mul cap size_of<.T>
    Vec<.T> 0 cap data

fn vec_with_capacity <.T> <(i32)*>Vec<.T>> (cap):
    let data <i32> alloc mul cap size_of<.T>
    Vec<.T> 0 cap data

fn vec_len <.T> <(Vec<.T>)->i32> (v):
    v.len

fn vec_cap <.T> <(Vec<.T>)->i32> (v):
    v.cap

fn vec_is_empty <.T> <(Vec<.T>)->bool> (v):
    eq v.len 0

fn vec_push <.T> <(Vec<.T>,.T)*>Vec<.T>> (v, item):
    let len <i32> v.len
    let cap <i32> v.cap
    let data <i32> v.data
    if:
        eq len cap
        then:
            // grow
            let new_cap <i32> mul cap 2
            let new_data <i32> realloc data mul cap size_of<.T> mul new_cap size_of<.T>
            let offset <i32> mul len size_of<.T>
            store<.T> add new_data offset item
            Vec<.T> add len 1 new_cap new_data
        else:
            let offset <i32> mul len size_of<.T>
            store<.T> add data offset item
            Vec<.T> add len 1 cap data

fn vec_get <.T> <(Vec<.T>,i32)->Option<.T>> (v, idx):
    let len <i32> v.len
    let data <i32> v.data
    if:
        lt idx 0
        then none<.T>
        else:
            if:
                le len idx
                then none<.T>
                else:
                    let offset <i32> mul idx size_of<.T>
                    some<.T> load<.T> add data offset

fn vec_set <.T> <(Vec<.T>,i32,.T)*>()> (v, idx, item):
    let len <i32> v.len
    let data <i32> v.data
    if:
        lt idx 0
        then ()
        else:
            if:
                le len idx
                then ()
                else:
                    let offset <i32> mul idx size_of<.T>
                    store<.T> add data offset item

fn vec_pop <.T> <(Vec<.T>)*>(Vec<.T>,Option<.T>)> (v):
    let len <i32> v.len
    let cap <i32> v.cap
    let data <i32> v.data
    if:
        eq len 0
        then (Vec<.T> len cap data, none<.T>)
        else:
            let new_len <i32> sub len 1
            let offset <i32> mul new_len size_of<.T>
            let item <.T> load<.T> add data offset
            (Vec<.T> new_len cap data, some<.T> item)

fn vec_clear <.T> <(Vec<.T>)*>Vec<.T>> (v):
    let cap <i32> v.cap
    let data <i32> v.data
    Vec<.T> 0 cap data

fn vec_free <.T> <(Vec<.T>)*>()> (v):
    let cap <i32> v.cap
    let data <i32> v.data
    dealloc data mul cap size_of<.T>
