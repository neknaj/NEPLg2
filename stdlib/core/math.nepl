//: math: core/math.nepl に関する機能を提供するライブラリ
//:
//: [目的/もくてき]:
//: - このモジュールの公開 API を提供します。
//: - 実装の変更時に最小限の doctest 実行経路を維持します。
//:
//: [注意/ちゅうい]:
//: - 利用時は各関数の「目的」「注意」「計算量」を確認してください。
//:
//: neplg2:test[skip]
//: ```neplg2
//:| #entry main
//:| #target wasi
//: ()
//: ```

#indent 4
#import "core/field" as *




#if[target=wasm]
//: i32_add: i32 の加算（mod 2^32）
//:
//: [目的/もくてき]:
//: - 2つの i32 を加算し、Wasm の i32 加算規則で結果を返します。
//:
//: [実装/じっそう]:
//: - `target=wasm` では `i32.add` を直接実行します。
//: - `target=llvm` では LLVM IR の `add i32` に分岐します。
//:
//: [注意/ちゅうい]:
//: - オーバーフロー時は 2^32 でラップします。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     assert_eq_i32 42 i32_add 40 2;
//:     assert_eq_i32 0 i32_add -1 1;
//: ```
fn i32_add <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.add
    #if[target=llvm]
    #llvmir:
        define i32 @i32_add(i32 %a, i32 %b) {
        entry:
            %0 = add i32 %a, %b
            ret i32 %0
        }

//: i32_sub: i32 の減算（mod 2^32）
//:
//: [目的/もくてき]:
//: - 2つの i32 の差を計算します。
//:
//: [実装/じっそう]:
//: - wasm は `i32.sub`、llvm は `sub i32` を使います。
//:
//: [注意/ちゅうい]:
//: - 符号付き/符号なしを問わず、ビット列として同じ減算を行います。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     assert_eq_i32 5 i32_sub 9 4;
//:     assert_eq_i32 -5 i32_sub 4 9;
//: ```
fn i32_sub <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.sub
    #if[target=llvm]
    #llvmir:
        define i32 @i32_sub(i32 %a, i32 %b) {
        entry:
            %0 = sub i32 %a, %b
            ret i32 %0
        }

//: i32_mul: i32 の乗算（mod 2^32）
//:
//: [目的/もくてき]:
//: - 2つの i32 の積を計算します。
//:
//: [実装/じっそう]:
//: - wasm は `i32.mul`、llvm は `mul i32` を使います。
//:
//: [注意/ちゅうい]:
//: - 積が 32-bit 範囲を超える場合は下位 32-bit が残ります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     assert_eq_i32 42 i32_mul 6 7;
//:     assert_eq_i32 0 i32_mul 0 12345;
//: ```
fn i32_mul <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.mul
    #if[target=llvm]
    #llvmir:
        define i32 @i32_mul(i32 %a, i32 %b) {
        entry:
            %0 = mul i32 %a, %b
            ret i32 %0
        }

//: i32_div_s: i32 の符号付き除算
//:
//: [目的/もくてき]:
//: - 符号付き整数として割り算を行います。
//:
//: [実装/じっそう]:
//: - wasm は `i32.div_s`、llvm は `sdiv i32` を使います。
//:
//: [注意/ちゅうい]:
//: - 0 除算は未定義動作ではなくランタイム trap になります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     assert_eq_i32 -3 i32_div_s -9 3;
//:     assert_eq_i32 -3 i32_div_s 10 -3;
//: ```
fn i32_div_s <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.div_s
    #if[target=llvm]
    #llvmir:
        define i32 @i32_div_s(i32 %a, i32 %b) {
        entry:
            %0 = sdiv i32 %a, %b
            ret i32 %0
        }

//: i32_div_u: i32 の符号なし除算
//:
//: [目的/もくてき]:
//: - 符号なし整数として割り算を行います。
//:
//: [実装/じっそう]:
//: - wasm は `i32.div_u`、llvm は `udiv i32` を使います。
//:
//: [注意/ちゅうい]:
//: - 引数が負に見える値でも、ビット列を符号なしとみなして計算します。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     assert_eq_i32 3 i32_div_u 11 3;
//:     assert_eq_i32 2147483647 i32_div_u -1 2;
//: ```
fn i32_div_u <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.div_u
    #if[target=llvm]
    #llvmir:
        define i32 @i32_div_u(i32 %a, i32 %b) {
        entry:
            %0 = udiv i32 %a, %b
            ret i32 %0
        }

//: i32_rem_s: i32 の符号付き剰余
//:
//: [目的/もくてき]:
//: - 符号付き除算の余りを計算します。
//:
//: [実装/じっそう]:
//: - wasm は `i32.rem_s`、llvm は `srem i32` を使います。
//:
//: [注意/ちゅうい]:
//: - 符号付き剰余の符号規則は Wasm/LLVM の仕様に従います。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     assert_eq_i32 1 i32_rem_s 10 3;
//:     assert_eq_i32 -1 i32_rem_s -10 3;
//: ```
fn i32_rem_s <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.rem_s
    #if[target=llvm]
    #llvmir:
        define i32 @i32_rem_s(i32 %a, i32 %b) {
        entry:
            %0 = srem i32 %a, %b
            ret i32 %0
        }

//: i32_rem_u: i32 の符号なし剰余
//:
//: [目的/もくてき]:
//: - 符号なし除算の余りを計算します。
//:
//: [実装/じっそう]:
//: - wasm は `i32.rem_u`、llvm は `urem i32` を使います。
//:
//: [注意/ちゅうい]:
//: - 結果は常に 0 以上で、除数未満になります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     assert_eq_i32 2 i32_rem_u 11 3;
//:     assert_eq_i32 5 i32_rem_u -1 10;
//: ```
fn i32_rem_u <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.rem_u
    #if[target=llvm]
    #llvmir:
        define i32 @i32_rem_u(i32 %a, i32 %b) {
        entry:
            %0 = urem i32 %a, %b
            ret i32 %0
        }

#if[target=wasm]
//: i32_and: i32 のビット AND
//:
//: [目的/もくてき]:
//: - i32 と i32 のビット AND を計算します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.and` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     assert_eq_i32 2 i32_and 6 3;
//:     assert_eq_i32 7 i32_or 6 3;
//:     assert_eq_i32 5 i32_xor 6 3;
//:     assert_eq_i32 8 i32_shl 1 3;
//:     assert_eq_i32 -2 i32_shr_s -8 2;
//:     assert_eq_i32 1073741822 i32_shr_u -8 2;
//:     assert_eq_i32 2 i32_rotl 1 1;
//:     assert_eq_i32 1 i32_rotr 2 1;
//: ```
fn i32_and <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.and

#if[target=wasm]
//: i32_or: i32 のビット OR
//:
//: [目的/もくてき]:
//: - i32 と i32 のビット OR を計算します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.or` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_or <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.or

#if[target=wasm]
//: i32_xor: i32 のビット XOR
//:
//: [目的/もくてき]:
//: - i32 と i32 のビット XOR を計算します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.xor` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_xor <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.xor

#if[target=wasm]
//: i32_shl: i32 の左シフト
//:
//: [目的/もくてき]:
//: - i32 を左へビットシフトします。
//:
//: [実装/じっそう]:
//: - wasm の `i32.shl` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_shl <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.shl

#if[target=wasm]
//: i32_shr_s: i32 の算術右シフト
//:
//: [目的/もくてき]:
//: - 符号ビットを維持した算術右シフトを行います。
//:
//: [実装/じっそう]:
//: - wasm の `i32.shr_s` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_shr_s <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.shr_s

#if[target=wasm]
//: i32_shr_u: i32 の論理右シフト
//:
//: [目的/もくてき]:
//: - 上位を 0 埋めする論理右シフトを行います。
//:
//: [実装/じっそう]:
//: - wasm の `i32.shr_u` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_shr_u <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.shr_u

#if[target=wasm]
//: i32_rotl: i32 の左ローテート
//:
//: [目的/もくてき]:
//: - i32 を左方向にビット回転します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.rotl` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_rotl <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.rotl

#if[target=wasm]
//: i32_rotr: i32 の右ローテート
//:
//: [目的/もくてき]:
//: - i32 を右方向にビット回転します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.rotr` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_rotr <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.rotr

#if[target=wasm]
//: i32_clz: 先頭ゼロビット数を数える
//:
//: [目的/もくてき]:
//: - i32 の上位側に連続する 0 ビット数を返します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.clz` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     assert_eq_i32 31 i32_clz 1;
//:     assert_eq_i32 3 i32_ctz 8;
//:     assert_eq_i32 4 i32_popcnt 15;
//: ```
fn i32_clz <(i32)->i32> (a):
    #wasm:
        local.get $a
        i32.clz

#if[target=wasm]
//: i32_ctz: 末尾ゼロビット数を数える
//:
//: [目的/もくてき]:
//: - i32 の下位側に連続する 0 ビット数を返します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.ctz` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_ctz <(i32)->i32> (a):
    #wasm:
        local.get $a
        i32.ctz

#if[target=wasm]
//: i32_popcnt: 1 ビットの個数を数える
//:
//: [目的/もくてき]:
//: - i32 のビット列に含まれる 1 の個数を返します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.popcnt` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_popcnt <(i32)->i32> (a):
    #wasm:
        local.get $a
        i32.popcnt

#if[target=wasm]
//: i32_eq: i32 の等値比較
//:
//: [目的/もくてき]:
//: - 2つの i32 が等しいか判定します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.eq` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     assert i32_eq 7 7;
//:     assert i32_ne 7 8;
//:     assert i32_lt_s -1 0;
//:     assert i32_lt_u 0 -1;
//:     assert i32_le_s 7 7;
//:     assert i32_le_u 7 8;
//:     assert i32_gt_s 9 3;
//:     assert i32_gt_u -1 0;
//:     assert i32_ge_s 9 9;
//:     assert i32_ge_u -1 -1;
//: ```
fn i32_eq <(i32,i32)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.eq

#if[target=wasm]
//: i32_ne: i32 の非等値比較
//:
//: [目的/もくてき]:
//: - 2つの i32 が異なるか判定します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.ne` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_ne <(i32,i32)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.ne

#if[target=wasm]
//: i32_lt_s: i32 の符号付き小なり比較
//:
//: [目的/もくてき]:
//: - i32 を符号付き値として比較し、`a < b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.lt_s` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_lt_s <(i32,i32)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.lt_s

#if[target=wasm]
//: i32_lt_u: i32 の符号なし小なり比較
//:
//: [目的/もくてき]:
//: - i32 を符号なし値として比較し、`a < b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.lt_u` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_lt_u <(i32,i32)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.lt_u

#if[target=wasm]
//: i32_le_s: i32 の符号付き以下比較
//:
//: [目的/もくてき]:
//: - i32 を符号付き値として比較し、`a <= b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.le_s` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_le_s <(i32,i32)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.le_s

#if[target=wasm]
//: i32_le_u: i32 の符号なし以下比較
//:
//: [目的/もくてき]:
//: - i32 を符号なし値として比較し、`a <= b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.le_u` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_le_u <(i32,i32)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.le_u

#if[target=wasm]
//: i32_gt_s: i32 の符号付き大なり比較
//:
//: [目的/もくてき]:
//: - i32 を符号付き値として比較し、`a > b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.gt_s` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_gt_s <(i32,i32)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.gt_s

#if[target=wasm]
//: i32_gt_u: i32 の符号なし大なり比較
//:
//: [目的/もくてき]:
//: - i32 を符号なし値として比較し、`a > b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.gt_u` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_gt_u <(i32,i32)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.gt_u

#if[target=wasm]
//: i32_ge_s: i32 の符号付き以上比較
//:
//: [目的/もくてき]:
//: - i32 を符号付き値として比較し、`a >= b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.ge_s` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_ge_s <(i32,i32)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.ge_s

#if[target=wasm]
//: i32_ge_u: i32 の符号なし以上比較
//:
//: [目的/もくてき]:
//: - i32 を符号なし値として比較し、`a >= b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm の `i32.ge_u` 命令を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_ge_u <(i32,i32)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.ge_u


#if[target=wasm]
//: u8_add: 主な用途
//:
//: [目的/もくてき]:
//: - u8_add の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn u8_add <(u8,u8)->u8> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.add
        i32.const 255
        i32.and

#if[target=wasm]
//: u8_sub: 主な用途
//:
//: [目的/もくてき]:
//: - u8_sub の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn u8_sub <(u8,u8)->u8> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.sub
        i32.const 255
        i32.and

#if[target=wasm]
//: u8_mul: 主な用途
//:
//: [目的/もくてき]:
//: - u8_mul の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn u8_mul <(u8,u8)->u8> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.mul
        i32.const 255
        i32.and

#if[target=wasm]
//: u8_div_u: 主な用途
//:
//: [目的/もくてき]:
//: - u8_div_u の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn u8_div_u <(u8,u8)->u8> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.div_u

#if[target=wasm]
//: u8_rem_u: 主な用途
//:
//: [目的/もくてき]:
//: - u8_rem_u の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn u8_rem_u <(u8,u8)->u8> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.rem_u

#if[target=wasm]
//: u8_eq: 主な用途
//:
//: [目的/もくてき]:
//: - u8_eq の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn u8_eq <(u8,u8)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.eq

#if[target=wasm]
//: u8_ne: 主な用途
//:
//: [目的/もくてき]:
//: - u8_ne の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn u8_ne <(u8,u8)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.ne

#if[target=wasm]
//: u8_lt_u: 主な用途
//:
//: [目的/もくてき]:
//: - u8_lt_u の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn u8_lt_u <(u8,u8)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.lt_u

#if[target=wasm]
//: u8_le_u: 主な用途
//:
//: [目的/もくてき]:
//: - u8_le_u の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn u8_le_u <(u8,u8)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.le_u

#if[target=wasm]
//: u8_gt_u: 主な用途
//:
//: [目的/もくてき]:
//: - u8_gt_u の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn u8_gt_u <(u8,u8)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.gt_u

#if[target=wasm]
//: u8_ge_u: 主な用途
//:
//: [目的/もくてき]:
//: - u8_ge_u の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn u8_ge_u <(u8,u8)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.ge_u


//: i64_add: i64 の加算（mod 2^64）
//:
//: [目的/もくてき]:
//: - i64 と i64 を加算します。
//:
//: [実装/じっそう]:
//: - wasm は `i64.add`、llvm は `add i64` を使います。
//:
//: [注意/ちゅうい]:
//: - オーバーフロー時は下位 64-bit が残ります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     let a <i64> i64_extend_i32_u 40;
//:     let b <i64> i64_extend_i32_u 2;
//:     assert i64_eq i64_add a b i64_extend_i32_u 42;
//:     let a <i64> i64_extend_i32_u 0;
//:     let b <i64> i64_extend_i32_u 7;
//:     assert i64_eq i64_add a b b;
//: ```
fn i64_add <(i64,i64)->i64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.add
    #if[target=llvm]
    #llvmir:
        define i64 @i64_add(i64 %a, i64 %b) {
        entry:
            %0 = add i64 %a, %b
            ret i64 %0
        }

//: i64_sub: i64 の減算（mod 2^64）
//:
//: [目的/もくてき]:
//: - i64 から i64 を減算します。
//:
//: [実装/じっそう]:
//: - wasm は `i64.sub`、llvm は `sub i64` を使います。
//:
//: [注意/ちゅうい]:
//: - 結果は 64-bit 符号付き値として解釈されますが、演算自体は 64-bit ラップです。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     let a <i64> i64_extend_i32_u 44;
//:     let b <i64> i64_extend_i32_u 2;
//:     assert i64_eq i64_sub a b i64_extend_i32_u 42;
//:     let z <i64> i64_extend_i32_u 0;
//:     let one <i64> i64_extend_i32_u 1;
//:     assert i64_lt_s i64_sub z one z;
//: ```
fn i64_sub <(i64,i64)->i64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.sub
    #if[target=llvm]
    #llvmir:
        define i64 @i64_sub(i64 %a, i64 %b) {
        entry:
            %0 = sub i64 %a, %b
            ret i64 %0
        }

//: i64_mul: i64 の乗算（mod 2^64）
//:
//: [目的/もくてき]:
//: - i64 と i64 を乗算します。
//:
//: [実装/じっそう]:
//: - wasm は `i64.mul`、llvm は `mul i64` を使います。
//:
//: [注意/ちゅうい]:
//: - 乗算結果が 64-bit を超える場合はラップします。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     let a <i64> i64_extend_i32_u 6;
//:     let b <i64> i64_extend_i32_u 7;
//:     assert i64_eq i64_mul a b i64_extend_i32_u 42;
//:     assert i64_eq i64_mul i64_extend_i32_u 0 i64_extend_i32_u 999 i64_extend_i32_u 0;
//: ```
fn i64_mul <(i64,i64)->i64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.mul
    #if[target=llvm]
    #llvmir:
        define i64 @i64_mul(i64 %a, i64 %b) {
        entry:
            %0 = mul i64 %a, %b
            ret i64 %0
        }

#if[target=wasm]
//: i64_div_s: i64 の符号付き除算
//:
//: [目的/もくてき]:
//: - i64 を符号付き整数として割り算します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.div_s` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 0 除算は trap します。
//: - 最小値 `-2^63` を `-1` で割るケースも trap します。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     let n9 <i64> i64_extend_i32_s -9;
//:     let p9 <i64> i64_extend_i32_s 9;
//:     let p3 <i64> i64_extend_i32_s 3;
//:     let n3 <i64> i64_extend_i32_s -3;
//:     let p <i64> i64_div_s n9 p3;
//:     let q <i64> i64_div_s p9 n3;
//:     assert i64_eq p i64_extend_i32_s -3;
//:     assert i64_eq q i64_extend_i32_s -3;
//: ```
fn i64_div_s <(i64,i64)->i64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.div_s

//: i64_div_u: i64 の符号なし除算
//:
//: [目的/もくてき]:
//: - i64 を符号なし整数として割り算します。
//:
//: [実装/じっそう]:
//: - wasm は `i64.div_u`、llvm は `udiv i64` を使います。
//:
//: [注意/ちゅうい]:
//: - 0 除算は trap します。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     let a <i64> i64_extend_i32_u 100;
//:     let b <i64> i64_extend_i32_u 9;
//:     assert i64_eq i64_div_u a b i64_extend_i32_u 11;
//:     let a <i64> i64_extend_i32_u 9;
//:     let b <i64> i64_extend_i32_u 10;
//:     assert i64_eq i64_div_u a b i64_extend_i32_u 0;
//: ```
fn i64_div_u <(i64,i64)->i64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.div_u
    #if[target=llvm]
    #llvmir:
        define i64 @i64_div_u(i64 %a, i64 %b) {
        entry:
            %0 = udiv i64 %a, %b
            ret i64 %0
        }

#if[target=wasm]
//: i64_rem_s: i64 の符号付き剰余
//:
//: [目的/もくてき]:
//: - i64 の符号付き剰余（余り）を計算します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.rem_s` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 余りの符号は被除数（左辺）に従います。
//: - 0 除算は trap します。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     let n10 <i64> i64_extend_i32_s -10;
//:     let p10 <i64> i64_extend_i32_s 10;
//:     let p3 <i64> i64_extend_i32_s 3;
//:     let a <i64> i64_rem_s n10 p3;
//:     let b <i64> i64_rem_s p10 p3;
//:     assert i64_eq a i64_extend_i32_s -1;
//:     assert i64_eq b i64_extend_i32_s 1;
//: ```
fn i64_rem_s <(i64,i64)->i64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.rem_s

//: i64_rem_u: i64 の符号なし剰余
//:
//: [目的/もくてき]:
//: - i64 の符号なし剰余を計算します。
//:
//: [実装/じっそう]:
//: - wasm は `i64.rem_u`、llvm は `urem i64` を使います。
//:
//: [注意/ちゅうい]:
//: - 戻り値は 0 以上かつ除数未満です。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     let a <i64> i64_extend_i32_u 100;
//:     let b <i64> i64_extend_i32_u 9;
//:     assert i64_eq i64_rem_u a b i64_extend_i32_u 1;
//:     let a <i64> i64_extend_i32_u 9;
//:     let b <i64> i64_extend_i32_u 10;
//:     assert i64_eq i64_rem_u a b a;
//: ```
fn i64_rem_u <(i64,i64)->i64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.rem_u
    #if[target=llvm]
    #llvmir:
        define i64 @i64_rem_u(i64 %a, i64 %b) {
        entry:
            %0 = urem i64 %a, %b
            ret i64 %0
        }

#if[target=wasm]
//: i64_and: i64 のビット AND
//:
//: [目的/もくてき]:
//: - 2つの i64 の各ビットに AND を適用します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.and` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 演算は整数の符号とは無関係にビット単位で行われます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     let a <i64> i64_extend_i32_u 14;
//:     let b <i64> i64_extend_i32_u 11;
//:     assert i64_eq i64_and a b i64_extend_i32_u 10;
//:     assert i64_eq i64_or a b i64_extend_i32_u 15;
//:     assert i64_eq i64_xor a b i64_extend_i32_u 5;
//: ```
fn i64_and <(i64,i64)->i64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.and

#if[target=wasm]
//: i64_or: i64 のビット OR
//:
//: [目的/もくてき]:
//: - 2つの i64 の各ビットに OR を適用します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.or` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 真理値 OR ではなく、ビット論理和です。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_or <(i64,i64)->i64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.or

#if[target=wasm]
//: i64_xor: i64 のビット XOR
//:
//: [目的/もくてき]:
//: - 2つの i64 の各ビットに XOR を適用します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.xor` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 異なるビットのみ 1 になる排他的論理和です。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_xor <(i64,i64)->i64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.xor

#if[target=wasm]
//: i64_shl: i64 の左シフト
//:
//: [目的/もくてき]:
//: - i64 のビット列を左へシフトします。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.shl` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - シフト量は Wasm 仕様に従い下位 6 bit が使われます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_shl <(i64,i64)->i64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.shl

#if[target=wasm]
//: i64_shr_s: i64 の算術右シフト
//:
//: [目的/もくてき]:
//: - i64 を符号付き整数として右へシフトします。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.shr_s` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 最上位ビット（符号ビット）が埋め戻されます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_shr_s <(i64,i64)->i64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.shr_s

#if[target=wasm]
//: i64_shr_u: i64 の論理右シフト
//:
//: [目的/もくてき]:
//: - i64 を符号なし整数として右へシフトします。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.shr_u` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 上位ビットは 0 で埋められます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_shr_u <(i64,i64)->i64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.shr_u

#if[target=wasm]
//: i64_rotl: i64 の左ローテート
//:
//: [目的/もくてき]:
//: - i64 のビット列を左へ循環シフトします。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.rotl` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - シフトで失われるビットは下位側へ回り込みます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_rotl <(i64,i64)->i64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.rotl

#if[target=wasm]
//: i64_rotr: i64 の右ローテート
//:
//: [目的/もくてき]:
//: - i64 のビット列を右へ循環シフトします。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.rotr` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - シフトで失われるビットは上位側へ回り込みます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_rotr <(i64,i64)->i64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.rotr

#if[target=wasm]
//: i64_clz: 先頭ゼロビット数の計算
//:
//: [目的/もくてき]:
//: - i64 の先頭側に連続する 0 bit の個数を返します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.clz` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 入力が 0 のときは 64 を返します。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_clz <(i64)->i64> (a):
    #wasm:
        local.get $a
        i64.clz

#if[target=wasm]
//: i64_ctz: 末尾ゼロビット数の計算
//:
//: [目的/もくてき]:
//: - i64 の末尾側に連続する 0 bit の個数を返します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.ctz` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 入力が 0 のときは 64 を返します。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_ctz <(i64)->i64> (a):
    #wasm:
        local.get $a
        i64.ctz

#if[target=wasm]
//: i64_popcnt: 1 ビット数の計算
//:
//: [目的/もくてき]:
//: - i64 に立っている 1 bit の個数を返します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.popcnt` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - ハミング重み（population count）として利用できます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_popcnt <(i64)->i64> (a):
    #wasm:
        local.get $a
        i64.popcnt

#if[target=wasm]
//: i64_eq: i64 の等値比較
//:
//: [目的/もくてき]:
//: - 2つの i64 が等しいかを判定します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.eq` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 比較はビット列が一致するかで判定されます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     let a <i64> i64_extend_i32_s -1;
//:     let b <i64> i64_extend_i32_s 1;
//:     let c <i64> i64_extend_i32_s -2;
//:     let d <i64> i64_extend_i32_s -1;
//:     assert i64_eq a d;
//:     assert i64_ne a b;
//:     assert i64_lt_s c d;
//:     assert i64_gt_u a b;
//: ```
fn i64_eq <(i64,i64)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.eq

#if[target=wasm]
//: i64_ne: i64 の非等値比較
//:
//: [目的/もくてき]:
//: - 2つの i64 が異なるかを判定します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.ne` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - `i64_eq` の否定と同値です。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_ne <(i64,i64)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.ne

#if[target=wasm]
//: i64_lt_s: i64 の符号付き小なり比較
//:
//: [目的/もくてき]:
//: - i64 を符号付き整数として `a < b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.lt_s` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 負数を含む順序関係を使うときはこちらを使います。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_lt_s <(i64,i64)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.lt_s

#if[target=wasm]
//: i64_lt_u: i64 の符号なし小なり比較
//:
//: [目的/もくてき]:
//: - i64 を符号なし整数として `a < b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.lt_u` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 上位ビットが立っている値は大きな正数として扱われます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_lt_u <(i64,i64)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.lt_u

#if[target=wasm]
//: i64_le_s: i64 の符号付き以下比較
//:
//: [目的/もくてき]:
//: - i64 を符号付き整数として `a <= b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.le_s` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - `i64_lt_s` と `i64_eq` の和集合と同じ真理値になります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_le_s <(i64,i64)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.le_s

#if[target=wasm]
//: i64_le_u: i64 の符号なし以下比較
//:
//: [目的/もくてき]:
//: - i64 を符号なし整数として `a <= b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.le_u` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 符号付き比較とは結果が異なる場合があります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_le_u <(i64,i64)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.le_u

#if[target=wasm]
//: i64_gt_s: i64 の符号付き大なり比較
//:
//: [目的/もくてき]:
//: - i64 を符号付き整数として `a > b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.gt_s` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 負数を含む大小比較に使用します。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_gt_s <(i64,i64)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.gt_s

#if[target=wasm]
//: i64_gt_u: i64 の符号なし大なり比較
//:
//: [目的/もくてき]:
//: - i64 を符号なし整数として `a > b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.gt_u` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - 上位ビットが立つ値は大きい値として判定されます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_gt_u <(i64,i64)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.gt_u

#if[target=wasm]
//: i64_ge_s: i64 の符号付き以上比較
//:
//: [目的/もくてき]:
//: - i64 を符号付き整数として `a >= b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.ge_s` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - `i64_gt_s` または `i64_eq` が真なら真になります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_ge_s <(i64,i64)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.ge_s

#if[target=wasm]
//: i64_ge_u: i64 の符号なし以上比較
//:
//: [目的/もくてき]:
//: - i64 を符号なし整数として `a >= b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm 命令 `i64.ge_u` を直接実行します。
//:
//: [注意/ちゅうい]:
//: - `i64_gt_u` または `i64_eq` が真なら真になります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i64_ge_u <(i64,i64)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i64.ge_u


//: f32_add: f32 の加算
//:
//: [目的/もくてき]:
//: - 2つの f32 を加算します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.add`、llvm は `fadd float` を実行します。
//:
//: [注意/ちゅうい]:
//: - 丸め・NaN・±∞の扱いは IEEE 754 と各 backend の仕様に従います。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     let x <f32> f32_add 1.5 2.25;
//:     let y <f32> f32_sub x 1.25;
//:     assert f32_eq x 3.75;
//:     assert f32_eq y 2.5;
//: ```
fn f32_add <(f32,f32)->f32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f32.add
    #if[target=llvm]
    #llvmir:
        define float @f32_add(float %a, float %b) {
        entry:
            %0 = fadd float %a, %b
            ret float %0
        }

//: f32_sub: f32 の減算
//:
//: [目的/もくてき]:
//: - 2つの f32 の差を計算します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.sub`、llvm は `fsub float` を実行します。
//:
//: [注意/ちゅうい]:
//: - NaN が関与する場合は比較で偽になる点に注意してください。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_sub <(f32,f32)->f32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f32.sub
    #if[target=llvm]
    #llvmir:
        define float @f32_sub(float %a, float %b) {
        entry:
            %0 = fsub float %a, %b
            ret float %0
        }

//: f32_mul: f32 の乗算
//:
//: [目的/もくてき]:
//: - 2つの f32 の積を計算します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.mul`、llvm は `fmul float` を実行します。
//:
//: [注意/ちゅうい]:
//: - 大きな値同士では `+∞` や `-∞` へ飽和することがあります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_mul <(f32,f32)->f32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f32.mul
    #if[target=llvm]
    #llvmir:
        define float @f32_mul(float %a, float %b) {
        entry:
            %0 = fmul float %a, %b
            ret float %0
        }

//: f32_div: f32 の除算
//:
//: [目的/もくてき]:
//: - 2つの f32 の商を計算します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.div`、llvm は `fdiv float` を実行します。
//:
//: [注意/ちゅうい]:
//: - 整数除算と異なり、0 除算は trap せず ±∞ / NaN になります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_div <(f32,f32)->f32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f32.div
    #if[target=llvm]
    #llvmir:
        define float @f32_div(float %a, float %b) {
        entry:
            %0 = fdiv float %a, %b
            ret float %0
        }

//: f32_sqrt: f32 の平方根
//:
//: [目的/もくてき]:
//: - f32 の平方根を返します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.sqrt` を実行します。
//: - llvm は `llvm.sqrt.f32` intrinsic を呼びます。
//:
//: [注意/ちゅうい]:
//: - 負数入力は NaN になります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_sqrt <(f32)->f32> (a):
    #wasm:
        local.get $a
        f32.sqrt
    #if[target=llvm]
    #llvmir:
        define float @f32_sqrt(float %a) {
        entry:
            %0 = call float @llvm.sqrt.f32(float %a)
            ret float %0
        }

//: f32_abs: f32 の絶対値
//:
//: [目的/もくてき]:
//: - f32 の符号を取り除いた絶対値を返します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.abs` を使います。
//: - llvm は `bitcast -> and mask -> bitcast` で符号ビットのみを落とします。
//:
//: [注意/ちゅうい]:
//: - NaN の payload は backend の仕様に従います。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_abs <(f32)->f32> (a):
    #wasm:
        local.get $a
        f32.abs
    #if[target=llvm]
    #llvmir:
        define float @f32_abs(float %a) {
        entry:
            %bits = bitcast float %a to i32
            %masked = and i32 %bits, 2147483647
            %0 = bitcast i32 %masked to float
            ret float %0
        }

//: f32_neg: f32 の符号反転
//:
//: [目的/もくてき]:
//: - f32 の符号を反転した値 `-a` を返します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.neg`、llvm は `fneg float` を使います。
//:
//: [注意/ちゅうい]:
//: - `-0.0` と `+0.0` は符号が反転します。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_neg <(f32)->f32> (a):
    #wasm:
        local.get $a
        f32.neg
    #if[target=llvm]
    #llvmir:
        define float @f32_neg(float %a) {
        entry:
            %0 = fneg float %a
            ret float %0
        }

//: f32_ceil: f32 の切り上げ
//:
//: [目的/もくてき]:
//: - f32 を「以上の最小整数値」へ切り上げます。
//:
//: [実装/じっそう]:
//: - wasm は `f32.ceil`、llvm は `llvm.ceil.f32` を使います。
//:
//: [注意/ちゅうい]:
//: - 戻り値の型は f32 のままです。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_ceil <(f32)->f32> (a):
    #wasm:
        local.get $a
        f32.ceil
    #if[target=llvm]
    #llvmir:
        define float @f32_ceil(float %a) {
        entry:
            %0 = call float @llvm.ceil.f32(float %a)
            ret float %0
        }

//: f32_floor: f32 の切り下げ
//:
//: [目的/もくてき]:
//: - f32 を「以下の最大整数値」へ切り下げます。
//:
//: [実装/じっそう]:
//: - wasm は `f32.floor`、llvm は `llvm.floor.f32` を使います。
//:
//: [注意/ちゅうい]:
//: - 戻り値の型は f32 のままです。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_floor <(f32)->f32> (a):
    #wasm:
        local.get $a
        f32.floor
    #if[target=llvm]
    #llvmir:
        define float @f32_floor(float %a) {
        entry:
            %0 = call float @llvm.floor.f32(float %a)
            ret float %0
        }

//: f32_trunc: f32 の小数部切り捨て
//:
//: [目的/もくてき]:
//: - f32 の小数部を 0 方向へ切り捨てます。
//:
//: [実装/じっそう]:
//: - wasm は `f32.trunc`、llvm は `llvm.trunc.f32` を使います。
//:
//: [注意/ちゅうい]:
//: - 負数では切り下げではなく 0 方向へ寄ります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_trunc <(f32)->f32> (a):
    #wasm:
        local.get $a
        f32.trunc
    #if[target=llvm]
    #llvmir:
        define float @f32_trunc(float %a) {
        entry:
            %0 = call float @llvm.trunc.f32(float %a)
            ret float %0
        }

//: f32_nearest: f32 の最近接整数丸め
//:
//: [目的/もくてき]:
//: - f32 を最近接整数へ丸めます。
//:
//: [実装/じっそう]:
//: - wasm は `f32.nearest`、llvm は `llvm.nearbyint.f32` を使います。
//:
//: [注意/ちゅうい]:
//: - 中間値（x.5）は backend の丸め規則に従います。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_nearest <(f32)->f32> (a):
    #wasm:
        local.get $a
        f32.nearest
    #if[target=llvm]
    #llvmir:
        define float @f32_nearest(float %a) {
        entry:
            %0 = call float @llvm.nearbyint.f32(float %a)
            ret float %0
        }

//: f32_min: f32 の最小値
//:
//: [目的/もくてき]:
//: - 2つの f32 から小さい方を返します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.min`、llvm は `llvm.minimum.f32` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN 入力時の振る舞いは backend 仕様に従います。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_min <(f32,f32)->f32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f32.min
    #if[target=llvm]
    #llvmir:
        define float @f32_min(float %a, float %b) {
        entry:
            %0 = call float @llvm.minimum.f32(float %a, float %b)
            ret float %0
        }

//: f32_max: f32 の最大値
//:
//: [目的/もくてき]:
//: - 2つの f32 から大きい方を返します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.max`、llvm は `llvm.maximum.f32` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN 入力時の振る舞いは backend 仕様に従います。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_max <(f32,f32)->f32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f32.max
    #if[target=llvm]
    #llvmir:
        define float @f32_max(float %a, float %b) {
        entry:
            %0 = call float @llvm.maximum.f32(float %a, float %b)
            ret float %0
        }

//: f32_copysign: f32 の符号コピー
//:
//: [目的/もくてき]:
//: - 第1引数の絶対値に、第2引数の符号ビットを適用した値を返します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.copysign`、llvm は `llvm.copysign.f32` を使います。
//:
//: [注意/ちゅうい]:
//: - 値の大きさは第1引数、符号のみ第2引数から採用されます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_copysign <(f32,f32)->f32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f32.copysign
    #if[target=llvm]
    #llvmir:
        define float @f32_copysign(float %a, float %b) {
        entry:
            %0 = call float @llvm.copysign.f32(float %a, float %b)
            ret float %0
        }

//: f32_eq: f32 の等値比較
//:
//: [目的/もくてき]:
//: - 2つの f32 が等しいかを判定します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.eq`、llvm は `fcmp oeq` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN を含む比較は false になります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_eq <(f32,f32)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f32.eq
    #if[target=llvm]
    #llvmir:
        define i32 @f32_eq(float %a, float %b) {
        entry:
            %cmp = fcmp oeq float %a, %b
            %0 = zext i1 %cmp to i32
            ret i32 %0
        }

//: f32_ne: f32 の非等値比較
//:
//: [目的/もくてき]:
//: - 2つの f32 が異なるかを判定します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.ne`、llvm は `fcmp une` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN を含む比較は true になります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_ne <(f32,f32)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f32.ne
    #if[target=llvm]
    #llvmir:
        define i32 @f32_ne(float %a, float %b) {
        entry:
            %cmp = fcmp une float %a, %b
            %0 = zext i1 %cmp to i32
            ret i32 %0
        }

//: f32_lt: f32 の小なり比較
//:
//: [目的/もくてき]:
//: - `a < b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.lt`、llvm は `fcmp olt` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN を含むと false です。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_lt <(f32,f32)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f32.lt
    #if[target=llvm]
    #llvmir:
        define i32 @f32_lt(float %a, float %b) {
        entry:
            %cmp = fcmp olt float %a, %b
            %0 = zext i1 %cmp to i32
            ret i32 %0
        }

//: f32_le: f32 の以下比較
//:
//: [目的/もくてき]:
//: - `a <= b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.le`、llvm は `fcmp ole` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN を含むと false です。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_le <(f32,f32)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f32.le
    #if[target=llvm]
    #llvmir:
        define i32 @f32_le(float %a, float %b) {
        entry:
            %cmp = fcmp ole float %a, %b
            %0 = zext i1 %cmp to i32
            ret i32 %0
        }

//: f32_gt: f32 の大なり比較
//:
//: [目的/もくてき]:
//: - `a > b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.gt`、llvm は `fcmp ogt` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN を含むと false です。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_gt <(f32,f32)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f32.gt
    #if[target=llvm]
    #llvmir:
        define i32 @f32_gt(float %a, float %b) {
        entry:
            %cmp = fcmp ogt float %a, %b
            %0 = zext i1 %cmp to i32
            ret i32 %0
        }

//: f32_ge: f32 の以上比較
//:
//: [目的/もくてき]:
//: - `a >= b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.ge`、llvm は `fcmp oge` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN を含むと false です。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_ge <(f32,f32)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f32.ge
    #if[target=llvm]
    #llvmir:
        define i32 @f32_ge(float %a, float %b) {
        entry:
            %cmp = fcmp oge float %a, %b
            %0 = zext i1 %cmp to i32
            ret i32 %0
        }


//: f64_add: f64 の加算
//:
//: [目的/もくてき]:
//: - 2つの f64 を加算します。
//:
//: [実装/じっそう]:
//: - wasm は `f64.add`、llvm は `fadd double` を実行します。
//:
//: [注意/ちゅうい]:
//: - 丸め誤差や NaN の伝播は IEEE 754 の規則に従います。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     let one <f64> f64_convert_i32_s 1;
//:     let two <f64> f64_convert_i32_s 2;
//:     let three <f64> f64_convert_i32_s 3;
//:     let six <f64> f64_convert_i32_s 6;
//:     let x <f64> f64_add one two;
//:     let y <f64> f64_mul x two;
//:     assert f64_eq x three;
//:     assert f64_eq y six;
//: ```
fn f64_add <(f64,f64)->f64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f64.add
    #if[target=llvm]
    #llvmir:
        define double @f64_add(double %a, double %b) {
        entry:
            %0 = fadd double %a, %b
            ret double %0
        }

//: f64_sub: f64 の減算
//:
//: [目的/もくてき]:
//: - 2つの f64 の差を計算します。
//:
//: [実装/じっそう]:
//: - wasm は `f64.sub`、llvm は `fsub double` を実行します。
//:
//: [注意/ちゅうい]:
//: - 丸めの影響で `(a - b) + b` が常に `a` になるとは限りません。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_sub <(f64,f64)->f64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f64.sub
    #if[target=llvm]
    #llvmir:
        define double @f64_sub(double %a, double %b) {
        entry:
            %0 = fsub double %a, %b
            ret double %0
        }

//: f64_mul: f64 の乗算
//:
//: [目的/もくてき]:
//: - 2つの f64 の積を計算します。
//:
//: [実装/じっそう]:
//: - wasm は `f64.mul`、llvm は `fmul double` を実行します。
//:
//: [注意/ちゅうい]:
//: - 大きい値では ±∞、非数値入力では NaN になります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_mul <(f64,f64)->f64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f64.mul
    #if[target=llvm]
    #llvmir:
        define double @f64_mul(double %a, double %b) {
        entry:
            %0 = fmul double %a, %b
            ret double %0
        }

//: f64_div: f64 の除算
//:
//: [目的/もくてき]:
//: - 2つの f64 の商を計算します。
//:
//: [実装/じっそう]:
//: - wasm は `f64.div`、llvm は `fdiv double` を実行します。
//:
//: [注意/ちゅうい]:
//: - 整数演算とは異なり 0 除算で trap せず、±∞ や NaN が返ります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_div <(f64,f64)->f64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f64.div
    #if[target=llvm]
    #llvmir:
        define double @f64_div(double %a, double %b) {
        entry:
            %0 = fdiv double %a, %b
            ret double %0
        }

//: f64_sqrt: f64 の平方根
//:
//: [目的/もくてき]:
//: - f64 の平方根を返します。
//:
//: [実装/じっそう]:
//: - wasm は `f64.sqrt` を実行します。
//: - llvm は `llvm.sqrt.f64` intrinsic を呼びます。
//:
//: [注意/ちゅうい]:
//: - 負数入力は NaN になります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_sqrt <(f64)->f64> (a):
    #wasm:
        local.get $a
        f64.sqrt
    #if[target=llvm]
    #llvmir:
        define double @f64_sqrt(double %a) {
        entry:
            %0 = call double @llvm.sqrt.f64(double %a)
            ret double %0
        }

//: f64_abs: f64 の絶対値
//:
//: [目的/もくてき]:
//: - f64 の符号を取り除いた絶対値を返します。
//:
//: [実装/じっそう]:
//: - wasm は `f64.abs` を使います。
//: - llvm は `bitcast -> and mask -> bitcast` で符号ビットのみを落とします。
//:
//: [注意/ちゅうい]:
//: - NaN の payload は backend の仕様に従います。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_abs <(f64)->f64> (a):
    #wasm:
        local.get $a
        f64.abs
    #if[target=llvm]
    #llvmir:
        define double @f64_abs(double %a) {
        entry:
            %bits = bitcast double %a to i64
            %masked = and i64 %bits, 9223372036854775807
            %0 = bitcast i64 %masked to double
            ret double %0
        }

//: f64_neg: f64 の符号反転
//:
//: [目的/もくてき]:
//: - f64 の符号を反転した値 `-a` を返します。
//:
//: [実装/じっそう]:
//: - wasm は `f64.neg`、llvm は `fneg double` を使います。
//:
//: [注意/ちゅうい]:
//: - `-0.0` と `+0.0` は区別されるため、符号反転で相互変換されます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_neg <(f64)->f64> (a):
    #wasm:
        local.get $a
        f64.neg
    #if[target=llvm]
    #llvmir:
        define double @f64_neg(double %a) {
        entry:
            %0 = fneg double %a
            ret double %0
        }

//: f64_ceil: f64 の切り上げ
//:
//: [目的/もくてき]:
//: - f64 を「以上の最小整数値」へ切り上げます。
//:
//: [実装/じっそう]:
//: - wasm は `f64.ceil`、llvm は `llvm.ceil.f64` を使います。
//:
//: [注意/ちゅうい]:
//: - 戻り値の型は f64 のままです。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_ceil <(f64)->f64> (a):
    #wasm:
        local.get $a
        f64.ceil
    #if[target=llvm]
    #llvmir:
        define double @f64_ceil(double %a) {
        entry:
            %0 = call double @llvm.ceil.f64(double %a)
            ret double %0
        }

//: f64_floor: f64 の切り下げ
//:
//: [目的/もくてき]:
//: - f64 を「以下の最大整数値」へ切り下げます。
//:
//: [実装/じっそう]:
//: - wasm は `f64.floor`、llvm は `llvm.floor.f64` を使います。
//:
//: [注意/ちゅうい]:
//: - 戻り値の型は f64 のままです。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_floor <(f64)->f64> (a):
    #wasm:
        local.get $a
        f64.floor
    #if[target=llvm]
    #llvmir:
        define double @f64_floor(double %a) {
        entry:
            %0 = call double @llvm.floor.f64(double %a)
            ret double %0
        }

//: f64_trunc: f64 の小数部切り捨て
//:
//: [目的/もくてき]:
//: - f64 の小数部を 0 方向へ切り捨てます。
//:
//: [実装/じっそう]:
//: - wasm は `f64.trunc`、llvm は `llvm.trunc.f64` を使います。
//:
//: [注意/ちゅうい]:
//: - 負数では切り下げではなく 0 方向へ寄ります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_trunc <(f64)->f64> (a):
    #wasm:
        local.get $a
        f64.trunc
    #if[target=llvm]
    #llvmir:
        define double @f64_trunc(double %a) {
        entry:
            %0 = call double @llvm.trunc.f64(double %a)
            ret double %0
        }

//: f64_nearest: f64 の最近接整数丸め
//:
//: [目的/もくてき]:
//: - f64 を最近接整数へ丸めます。
//:
//: [実装/じっそう]:
//: - wasm は `f64.nearest`、llvm は `llvm.nearbyint.f64` を使います。
//:
//: [注意/ちゅうい]:
//: - 中間値（x.5）は backend の丸め規則に従います。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_nearest <(f64)->f64> (a):
    #wasm:
        local.get $a
        f64.nearest
    #if[target=llvm]
    #llvmir:
        define double @f64_nearest(double %a) {
        entry:
            %0 = call double @llvm.nearbyint.f64(double %a)
            ret double %0
        }

//: f64_min: f64 の最小値
//:
//: [目的/もくてき]:
//: - 2つの f64 から小さい方を返します。
//:
//: [実装/じっそう]:
//: - wasm は `f64.min`、llvm は `llvm.minimum.f64` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN 入力時の振る舞いは backend 仕様に従います。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_min <(f64,f64)->f64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f64.min
    #if[target=llvm]
    #llvmir:
        define double @f64_min(double %a, double %b) {
        entry:
            %0 = call double @llvm.minimum.f64(double %a, double %b)
            ret double %0
        }

//: f64_max: f64 の最大値
//:
//: [目的/もくてき]:
//: - 2つの f64 から大きい方を返します。
//:
//: [実装/じっそう]:
//: - wasm は `f64.max`、llvm は `llvm.maximum.f64` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN 入力時の振る舞いは backend 仕様に従います。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_max <(f64,f64)->f64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f64.max
    #if[target=llvm]
    #llvmir:
        define double @f64_max(double %a, double %b) {
        entry:
            %0 = call double @llvm.maximum.f64(double %a, double %b)
            ret double %0
        }

//: f64_copysign: f64 の符号コピー
//:
//: [目的/もくてき]:
//: - 第1引数の絶対値に、第2引数の符号ビットを適用した値を返します。
//:
//: [実装/じっそう]:
//: - wasm は `f64.copysign`、llvm は `llvm.copysign.f64` を使います。
//:
//: [注意/ちゅうい]:
//: - 値の大きさは第1引数、符号のみ第2引数から採用されます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_copysign <(f64,f64)->f64> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f64.copysign
    #if[target=llvm]
    #llvmir:
        define double @f64_copysign(double %a, double %b) {
        entry:
            %0 = call double @llvm.copysign.f64(double %a, double %b)
            ret double %0
        }

//: f64_eq: f64 の等値比較
//:
//: [目的/もくてき]:
//: - 2つの f64 が等しいかを判定します。
//:
//: [実装/じっそう]:
//: - wasm は `f64.eq`、llvm は `fcmp oeq` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN を含む比較は false です。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_eq <(f64,f64)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f64.eq
    #if[target=llvm]
    #llvmir:
        define i32 @f64_eq(double %a, double %b) {
        entry:
            %cmp = fcmp oeq double %a, %b
            %0 = zext i1 %cmp to i32
            ret i32 %0
        }

//: f64_ne: f64 の非等値比較
//:
//: [目的/もくてき]:
//: - 2つの f64 が異なるかを判定します。
//:
//: [実装/じっそう]:
//: - wasm は `f64.ne`、llvm は `fcmp une` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN を含む比較は true です。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_ne <(f64,f64)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f64.ne
    #if[target=llvm]
    #llvmir:
        define i32 @f64_ne(double %a, double %b) {
        entry:
            %cmp = fcmp une double %a, %b
            %0 = zext i1 %cmp to i32
            ret i32 %0
        }

//: f64_lt: f64 の小なり比較
//:
//: [目的/もくてき]:
//: - `a < b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm は `f64.lt`、llvm は `fcmp olt` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN を含む比較は false です。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_lt <(f64,f64)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f64.lt
    #if[target=llvm]
    #llvmir:
        define i32 @f64_lt(double %a, double %b) {
        entry:
            %cmp = fcmp olt double %a, %b
            %0 = zext i1 %cmp to i32
            ret i32 %0
        }

//: f64_le: f64 の以下比較
//:
//: [目的/もくてき]:
//: - `a <= b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm は `f64.le`、llvm は `fcmp ole` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN を含む比較は false です。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_le <(f64,f64)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f64.le
    #if[target=llvm]
    #llvmir:
        define i32 @f64_le(double %a, double %b) {
        entry:
            %cmp = fcmp ole double %a, %b
            %0 = zext i1 %cmp to i32
            ret i32 %0
        }

//: f64_gt: f64 の大なり比較
//:
//: [目的/もくてき]:
//: - `a > b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm は `f64.gt`、llvm は `fcmp ogt` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN を含む比較は false です。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_gt <(f64,f64)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f64.gt
    #if[target=llvm]
    #llvmir:
        define i32 @f64_gt(double %a, double %b) {
        entry:
            %cmp = fcmp ogt double %a, %b
            %0 = zext i1 %cmp to i32
            ret i32 %0
        }

//: f64_ge: f64 の以上比較
//:
//: [目的/もくてき]:
//: - `a >= b` を判定します。
//:
//: [実装/じっそう]:
//: - wasm は `f64.ge`、llvm は `fcmp oge` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN を含む比較は false です。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f64_ge <(f64,f64)->bool> (a,b):
    #wasm:
        local.get $a
        local.get $b
        f64.ge
    #if[target=llvm]
    #llvmir:
        define i32 @f64_ge(double %a, double %b) {
        entry:
            %cmp = fcmp oge double %a, %b
            %0 = zext i1 %cmp to i32
            ret i32 %0
        }


//: i32_extend_i8_s: i8 相当値の符号拡張
//:
//: [目的/もくてき]:
//: - i32 下位 8 bit を符号付き値として i32 へ拡張します。
//:
//: [実装/じっそう]:
//: - wasm は `i32.extend8_s` を使います。
//: - llvm は `shl 24` 後に `ashr 24` で符号拡張します。
//:
//: [注意/ちゅうい]:
//: - 上位 24 bit は入力の符号に応じて埋められます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i32_extend_i8_s <(i32)->i32> (a):
    #wasm:
        local.get $a
        i32.extend8_s
    #if[target=llvm]
    #llvmir:
        define i32 @i32_extend_i8_s(i32 %a) {
        entry:
            %shl = shl i32 %a, 24
            %0 = ashr i32 %shl, 24
            ret i32 %0
        }

//: i32_extend_i16_s: i16 相当値の符号拡張
//:
//: [目的/もくてき]:
//: - i32 下位 16 bit を符号付き値として i32 へ拡張します。
//:
//: [実装/じっそう]:
//: - wasm は `i32.extend16_s` を使います。
//: - llvm は `shl 16` 後に `ashr 16` で符号拡張します。
//:
//: [注意/ちゅうい]:
//: - 上位 16 bit は入力の符号に応じて埋められます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i32_extend_i16_s <(i32)->i32> (a):
    #wasm:
        local.get $a
        i32.extend16_s
    #if[target=llvm]
    #llvmir:
        define i32 @i32_extend_i16_s(i32 %a) {
        entry:
            %shl = shl i32 %a, 16
            %0 = ashr i32 %shl, 16
            ret i32 %0
        }

//: i64_extend_i32_s: i32 を符号拡張して i64 へ変換する
//:
//: [目的/もくてき]:
//: - i32 の符号を保ったまま i64 に拡張します。
//:
//: [実装/じっそう]:
//: - wasm は `i64.extend_i32_s`、llvm は `sext i32 to i64` を使います。
//:
//: [注意/ちゅうい]:
//: - 負値は上位ビットが 1 で埋められます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     let v <i64> i64_extend_i32_s -1;
//:     assert i64_lt_s v i64_extend_i32_u 0;
//:     let v <i64> i64_extend_i32_s 123;
//:     assert i64_eq v i64_extend_i32_u 123;
//: ```
fn i64_extend_i32_s <(i32)->i64> (a):
    #wasm:
        local.get $a
        i64.extend_i32_s
    #if[target=llvm]
    #llvmir:
        define i64 @i64_extend_i32_s(i32 %a) {
        entry:
            %0 = sext i32 %a to i64
            ret i64 %0
        }

//: i64_extend_i32_u: i32 をゼロ拡張して i64 へ変換する
//:
//: [目的/もくてき]:
//: - i32 を符号なし値として i64 に拡張します。
//:
//: [実装/じっそう]:
//: - wasm は `i64.extend_i32_u`、llvm は `zext i32 to i64` を使います。
//:
//: [注意/ちゅうい]:
//: - 32-bit 上位は必ず 0 になります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     let v <i64> i64_extend_i32_u -1;
//:     assert i64_gt_u v i64_extend_i32_u 0;
//:     let v <i64> i64_extend_i32_u 1;
//:     assert i64_eq v i64_extend_i32_u 1;
//: ```
fn i64_extend_i32_u <(i32)->i64> (a):
    #wasm:
        local.get $a
        i64.extend_i32_u
    #if[target=llvm]
    #llvmir:
        define i64 @i64_extend_i32_u(i32 %a) {
        entry:
            %0 = zext i32 %a to i64
            ret i64 %0
        }

//: i32_wrap_i64: i64 を i32 へ切り詰める
//:
//: [目的/もくてき]:
//: - i64 の下位 32 bit を取り出して i32 として返します。
//:
//: [実装/じっそう]:
//: - wasm は `i32.wrap_i64`、llvm は `trunc i64 to i32` を使います。
//:
//: [注意/ちゅうい]:
//: - 上位 32 bit は破棄されます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i32_wrap_i64 <(i64)->i32> (a):
    #wasm:
        local.get $a
        i32.wrap_i64
    #if[target=llvm]
    #llvmir:
        define i32 @i32_wrap_i64(i64 %a) {
        entry:
            %0 = trunc i64 %a to i32
            ret i32 %0
        }

//: f32_convert_i32_s: i32(符号付き) を f32 へ変換
//:
//: [目的/もくてき]:
//: - 符号付き i32 を f32 に変換します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.convert_i32_s`、llvm は `sitofp i32 to float` を使います。
//:
//: [注意/ちゅうい]:
//: - 大きい整数は f32 で正確に表現できない場合があります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_convert_i32_s <(i32)->f32> (a):
    #wasm:
        local.get $a
        f32.convert_i32_s
    #if[target=llvm]
    #llvmir:
        define float @f32_convert_i32_s(i32 %a) {
        entry:
            %0 = sitofp i32 %a to float
            ret float %0
        }

//: f32_convert_i32_u: i32(符号なし) を f32 へ変換
//:
//: [目的/もくてき]:
//: - 符号なし i32 を f32 に変換します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.convert_i32_u`、llvm は `uitofp i32 to float` を使います。
//:
//: [注意/ちゅうい]:
//: - 符号付き値としては負に見えるビット列も、大きな正数として解釈されます。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_convert_i32_u <(i32)->f32> (a):
    #wasm:
        local.get $a
        f32.convert_i32_u
    #if[target=llvm]
    #llvmir:
        define float @f32_convert_i32_u(i32 %a) {
        entry:
            %0 = uitofp i32 %a to float
            ret float %0
        }

//: f32_convert_i64_s: i64(符号付き) を f32 へ変換
//:
//: [目的/もくてき]:
//: - 符号付き i64 を f32 に変換します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.convert_i64_s`、llvm は `sitofp i64 to float` を使います。
//:
//: [注意/ちゅうい]:
//: - 表現可能桁数を超える場合は丸めが発生します。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_convert_i64_s <(i64)->f32> (a):
    #wasm:
        local.get $a
        f32.convert_i64_s
    #if[target=llvm]
    #llvmir:
        define float @f32_convert_i64_s(i64 %a) {
        entry:
            %0 = sitofp i64 %a to float
            ret float %0
        }

//: f32_convert_i64_u: i64(符号なし) を f32 へ変換
//:
//: [目的/もくてき]:
//: - 符号なし i64 を f32 に変換します。
//:
//: [実装/じっそう]:
//: - wasm は `f32.convert_i64_u`、llvm は `uitofp i64 to float` を使います。
//:
//: [注意/ちゅうい]:
//: - 非常に大きな値では丸め誤差が大きくなることがあります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn f32_convert_i64_u <(i64)->f32> (a):
    #wasm:
        local.get $a
        f32.convert_i64_u
    #if[target=llvm]
    #llvmir:
        define float @f32_convert_i64_u(i64 %a) {
        entry:
            %0 = uitofp i64 %a to float
            ret float %0
        }

//: i32_trunc_f32_s: f32 を i32(符号付き)へ切り捨て変換
//:
//: [目的/もくてき]:
//: - f32 を 0 方向へ切り捨てて符号付き i32 に変換します。
//:
//: [実装/じっそう]:
//: - wasm は `i32.trunc_f32_s`、llvm は `fptosi float to i32` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN や範囲外値は trap（未定義変換）になります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i32_trunc_f32_s <(f32)->i32> (a):
    #wasm:
        local.get $a
        i32.trunc_f32_s
    #if[target=llvm]
    #llvmir:
        define i32 @i32_trunc_f32_s(float %a) {
        entry:
            %0 = fptosi float %a to i32
            ret i32 %0
        }

//: i32_trunc_f32_u: f32 を i32(符号なし)へ切り捨て変換
//:
//: [目的/もくてき]:
//: - f32 を 0 方向へ切り捨てて符号なし i32 に変換します。
//:
//: [実装/じっそう]:
//: - wasm は `i32.trunc_f32_u`、llvm は `fptoui float to i32` を使います。
//:
//: [注意/ちゅうい]:
//: - NaN や範囲外値は trap（未定義変換）になります。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
fn i32_trunc_f32_u <(f32)->i32> (a):
    #wasm:
        local.get $a
        i32.trunc_f32_u
    #if[target=llvm]
    #llvmir:
        define i32 @i32_trunc_f32_u(float %a) {
        entry:
            %0 = fptoui float %a to i32
            ret i32 %0
        }

#if[target=wasm]
//: i32_trunc_sat_f32_s: 主な用途
//:
//: [目的/もくてき]:
//: - i32_trunc_sat_f32_s の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_trunc_sat_f32_s <(f32)->i32> (a):
    #wasm:
        local.get $a
        i32.trunc_sat_f32_s

#if[target=wasm]
//: i32_trunc_sat_f32_u: 主な用途
//:
//: [目的/もくてき]:
//: - i32_trunc_sat_f32_u の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_trunc_sat_f32_u <(f32)->i32> (a):
    #wasm:
        local.get $a
        i32.trunc_sat_f32_u

#if[target=wasm]
//: i64_trunc_f32_s: 主な用途
//:
//: [目的/もくてき]:
//: - i64_trunc_f32_s の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i64_trunc_f32_s <(f32)->i64> (a):
    #wasm:
        local.get $a
        i64.trunc_f32_s

#if[target=wasm]
//: i64_trunc_f32_u: 主な用途
//:
//: [目的/もくてき]:
//: - i64_trunc_f32_u の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i64_trunc_f32_u <(f32)->i64> (a):
    #wasm:
        local.get $a
        i64.trunc_f32_u

#if[target=wasm]
//: i64_trunc_sat_f32_s: 主な用途
//:
//: [目的/もくてき]:
//: - i64_trunc_sat_f32_s の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i64_trunc_sat_f32_s <(f32)->i64> (a):
    #wasm:
        local.get $a
        i64.trunc_sat_f32_s

#if[target=wasm]
//: i64_trunc_sat_f32_u: 主な用途
//:
//: [目的/もくてき]:
//: - i64_trunc_sat_f32_u の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i64_trunc_sat_f32_u <(f32)->i64> (a):
    #wasm:
        local.get $a
        i64.trunc_sat_f32_u

#if[target=wasm]
//: f64_convert_i32_s: 主な用途
//:
//: [目的/もくてき]:
//: - f64_convert_i32_s の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn f64_convert_i32_s <(i32)->f64> (a):
    #wasm:
        local.get $a
        f64.convert_i32_s

#if[target=wasm]
//: f64_convert_i32_u: 主な用途
//:
//: [目的/もくてき]:
//: - f64_convert_i32_u の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn f64_convert_i32_u <(i32)->f64> (a):
    #wasm:
        local.get $a
        f64.convert_i32_u

#if[target=wasm]
//: f64_convert_i64_s: 主な用途
//:
//: [目的/もくてき]:
//: - f64_convert_i64_s の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn f64_convert_i64_s <(i64)->f64> (a):
    #wasm:
        local.get $a
        f64.convert_i64_s

#if[target=wasm]
//: f64_convert_i64_u: 主な用途
//:
//: [目的/もくてき]:
//: - f64_convert_i64_u の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn f64_convert_i64_u <(i64)->f64> (a):
    #wasm:
        local.get $a
        f64.convert_i64_u

#if[target=wasm]
//: i32_trunc_f64_s: 主な用途
//:
//: [目的/もくてき]:
//: - i32_trunc_f64_s の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_trunc_f64_s <(f64)->i32> (a):
    #wasm:
        local.get $a
        i32.trunc_f64_s

#if[target=wasm]
//: i32_trunc_f64_u: 主な用途
//:
//: [目的/もくてき]:
//: - i32_trunc_f64_u の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_trunc_f64_u <(f64)->i32> (a):
    #wasm:
        local.get $a
        i32.trunc_f64_u

#if[target=wasm]
//: i32_trunc_sat_f64_s: 主な用途
//:
//: [目的/もくてき]:
//: - i32_trunc_sat_f64_s の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_trunc_sat_f64_s <(f64)->i32> (a):
    #wasm:
        local.get $a
        i32.trunc_sat_f64_s

#if[target=wasm]
//: i32_trunc_sat_f64_u: 主な用途
//:
//: [目的/もくてき]:
//: - i32_trunc_sat_f64_u の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_trunc_sat_f64_u <(f64)->i32> (a):
    #wasm:
        local.get $a
        i32.trunc_sat_f64_u

#if[target=wasm]
//: i64_trunc_f64_s: 主な用途
//:
//: [目的/もくてき]:
//: - i64_trunc_f64_s の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i64_trunc_f64_s <(f64)->i64> (a):
    #wasm:
        local.get $a
        i64.trunc_f64_s

#if[target=wasm]
//: i64_trunc_f64_u: 主な用途
//:
//: [目的/もくてき]:
//: - i64_trunc_f64_u の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i64_trunc_f64_u <(f64)->i64> (a):
    #wasm:
        local.get $a
        i64.trunc_f64_u

#if[target=wasm]
//: i64_trunc_sat_f64_s: 主な用途
//:
//: [目的/もくてき]:
//: - i64_trunc_sat_f64_s の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i64_trunc_sat_f64_s <(f64)->i64> (a):
    #wasm:
        local.get $a
        i64.trunc_sat_f64_s

#if[target=wasm]
//: i64_trunc_sat_f64_u: 主な用途
//:
//: [目的/もくてき]:
//: - i64_trunc_sat_f64_u の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i64_trunc_sat_f64_u <(f64)->i64> (a):
    #wasm:
        local.get $a
        i64.trunc_sat_f64_u

#if[target=wasm]
//: f64_promote_f32: 主な用途
//:
//: [目的/もくてき]:
//: - f64_promote_f32 の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn f64_promote_f32 <(f32)->f64> (a):
    #wasm:
        local.get $a
        f64.promote_f32

#if[target=wasm]
//: f32_demote_f64: 主な用途
//:
//: [目的/もくてき]:
//: - f32_demote_f64 の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn f32_demote_f64 <(f64)->f32> (a):
    #wasm:
        local.get $a
        f32.demote_f64

#if[target=wasm]
//: f32_reinterpret_i32: 主な用途
//:
//: [目的/もくてき]:
//: - f32_reinterpret_i32 の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn f32_reinterpret_i32 <(i32)->f32> (a):
    #wasm:
        local.get $a
        f32.reinterpret_i32

#if[target=wasm]
//: i32_reinterpret_f32: 主な用途
//:
//: [目的/もくてき]:
//: - i32_reinterpret_f32 の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i32_reinterpret_f32 <(f32)->i32> (a):
    #wasm:
        local.get $a
        i32.reinterpret_f32

#if[target=wasm]
//: f64_reinterpret_i64: 主な用途
//:
//: [目的/もくてき]:
//: - f64_reinterpret_i64 の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn f64_reinterpret_i64 <(i64)->f64> (a):
    #wasm:
        local.get $a
        f64.reinterpret_i64

#if[target=wasm]
//: i64_reinterpret_f64: 主な用途
//:
//: [目的/もくてき]:
//: - i64_reinterpret_f64 の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn i64_reinterpret_f64 <(f64)->i64> (a):
    #wasm:
        local.get $a
        i64.reinterpret_f64


#if[target=wasm]
//: add: 主な用途
//:
//: [目的/もくてき]:
//: - add の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn add <(i32,i32)->i32> (a,b):
    #if[target=wasm]
    #wasm:
        local.get $a
        local.get $b
        i32.add
    #if[target=llvm]
    #llvmir:
        define i32 @add(i32 %a, i32 %b) {
        entry:
            %0 = add i32 %a, %b
            ret i32 %0
        }

//: sub: 主な用途
//:
//: [目的/もくてき]:
//: - sub の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn sub <(i32,i32)->i32> (a,b):
    #if[target=wasm]
    #wasm:
        local.get $a
        local.get $b
        i32.sub
    #if[target=llvm]
    #llvmir:
        define i32 @sub(i32 %a, i32 %b) {
        entry:
            %0 = sub i32 %a, %b
            ret i32 %0
        }

//: mul: 主な用途
//:
//: [目的/もくてき]:
//: - mul の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn mul <(i32,i32)->i32> (a,b):
    #if[target=wasm]
    #wasm:
        local.get $a
        local.get $b
        i32.mul
    #if[target=llvm]
    #llvmir:
        define i32 @mul(i32 %a, i32 %b) {
        entry:
            %0 = mul i32 %a, %b
            ret i32 %0
        }

//: div_s: 主な用途
//:
//: [目的/もくてき]:
//: - div_s の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn div_s <(i32,i32)->i32> (a,b):
    #if[target=wasm]
    #wasm:
        local.get $a
        local.get $b
        i32.div_s
    #if[target=llvm]
    #llvmir:
        define i32 @div_s(i32 %a, i32 %b) {
        entry:
            %0 = sdiv i32 %a, %b
            ret i32 %0
        }

//: mod_s: 主な用途
//:
//: [目的/もくてき]:
//: - mod_s の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn mod_s <(i32,i32)->i32> (a,b):
    #if[target=wasm]
    #wasm:
        local.get $a
        local.get $b
        i32.rem_s
    #if[target=llvm]
    #llvmir:
        define i32 @mod_s(i32 %a, i32 %b) {
        entry:
            %0 = srem i32 %a, %b
            ret i32 %0
        }

//: lt: 主な用途
//:
//: [目的/もくてき]:
//: - lt の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn lt <(i32,i32)->bool> (a,b):
    #if[target=wasm]
    #wasm:
        local.get $a
        local.get $b
        i32.lt_s
    #if[target=llvm]
    #llvmir:
        define i32 @lt(i32 %a, i32 %b) {
        entry:
            %0 = icmp slt i32 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

//: eq: 主な用途
//:
//: [目的/もくてき]:
//: - eq の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn eq <(i32,i32)->bool> (a,b):
    #if[target=wasm]
    #wasm:
        local.get $a
        local.get $b
        i32.eq
    #if[target=llvm]
    #llvmir:
        define i32 @eq(i32 %a, i32 %b) {
        entry:
            %0 = icmp eq i32 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

//: ne: 主な用途
//:
//: [目的/もくてき]:
//: - ne の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn ne <(i32,i32)->bool> (a,b):
    #if[target=wasm]
    #wasm:
        local.get $a
        local.get $b
        i32.ne
    #if[target=llvm]
    #llvmir:
        define i32 @ne(i32 %a, i32 %b) {
        entry:
            %0 = icmp ne i32 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

//: le: 主な用途
//:
//: [目的/もくてき]:
//: - le の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn le <(i32,i32)->bool> (a,b):
    #if[target=wasm]
    #wasm:
        local.get $a
        local.get $b
        i32.le_s
    #if[target=llvm]
    #llvmir:
        define i32 @le(i32 %a, i32 %b) {
        entry:
            %0 = icmp sle i32 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

//: gt: 主な用途
//:
//: [目的/もくてき]:
//: - gt の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn gt <(i32,i32)->bool> (a,b):
    #if[target=wasm]
    #wasm:
        local.get $a
        local.get $b
        i32.gt_s
    #if[target=llvm]
    #llvmir:
        define i32 @gt(i32 %a, i32 %b) {
        entry:
            %0 = icmp sgt i32 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

//: ge: 主な用途
//:
//: [目的/もくてき]:
//: - ge の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn ge <(i32,i32)->bool> (a,b):
    #if[target=wasm]
    #wasm:
        local.get $a
        local.get $b
        i32.ge_s
    #if[target=llvm]
    #llvmir:
        define i32 @ge(i32 %a, i32 %b) {
        entry:
            %0 = icmp sge i32 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

//: and: 主な用途
//:
//: [目的/もくてき]:
//: - and の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn and <(bool,bool)->bool> (a,b):
    #if[target=wasm]
    #wasm:
        local.get $a
        local.get $b
        i32.and
    #if[target=llvm]
    #llvmir:
        define i32 @and(i32 %a, i32 %b) {
        entry:
            %0 = and i32 %a, %b
            ret i32 %0
        }

//: or: 主な用途
//:
//: [目的/もくてき]:
//: - or の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn or <(bool,bool)->bool> (a,b):
    #if[target=wasm]
    #wasm:
        local.get $a
        local.get $b
        i32.or
    #if[target=llvm]
    #llvmir:
        define i32 @or(i32 %a, i32 %b) {
        entry:
            %0 = or i32 %a, %b
            ret i32 %0
        }

//: not: 主な用途
//:
//: [目的/もくてき]:
//: - not の主な用途と呼び出し方を示します。
//:
//: [実装/じっそう]:
//: - 定義済み処理をそのまま呼び出す薄いラッパで構成されています。
//:
//: [注意/ちゅうい]:
//: - 引数の値は関数呼び出しで移動するため、再利用時は束縛し直してください。
//:
//: [計算量/けいさんりょう]:
//: - 本体処理に準じます。
fn not <(bool)->bool> (a):
    #if[target=wasm]
    #wasm:
        local.get $a
        i32.eqz
    #if[target=llvm]
    #llvmir:
        define i32 @not(i32 %a) {
        entry:
            %0 = icmp eq i32 %a, 0
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

//: 追加整数型 API（u32/u64/u128/i128）
//:
//: [目的/もくてき]:
//: - WASM ネイティブの `i32/i64` を土台に、符号なし整数および 128-bit 相当の基本演算を提供します。
//:
//: [実装/じっそう]:
//: - `u32/u64` は既存の unsigned 命令ラッパを再公開します。
//: - `u128/i128` は `i64` 2 ワード（上位/下位）で構成し、加減算と比較を実装します。
//:
//: [注意/ちゅうい]:
//: - `u128/i128` の除算・乗算は未提供です（今後拡張）。
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "std/test" as *
//:| #import "core/math" as *
//: fn main <()*>()> ():
//:     assert_eq_i32 3 u32_add 1 2;
//:     assert u64_lt i64_extend_i32_u 9 i64_extend_i32_u 10;
//: ```

//: u32_add: u32 の加算（mod 2^32）
fn u32_add <(i32,i32)->i32> (a, b):
    i32_add a b

//: u32_sub: u32 の減算（mod 2^32）
fn u32_sub <(i32,i32)->i32> (a, b):
    i32_sub a b

//: u32_mul: u32 の乗算（mod 2^32）
fn u32_mul <(i32,i32)->i32> (a, b):
    i32_mul a b

//: u32_div: u32 の除算
fn u32_div <(i32,i32)->i32> (a, b):
    i32_div_u a b

//: u32_rem: u32 の剰余
fn u32_rem <(i32,i32)->i32> (a, b):
    i32_rem_u a b

//: u32_lt: u32 の大小比較（a < b）
fn u32_lt <(i32,i32)->bool> (a, b):
    i32_lt_u a b

//: u32_le: u32 の大小比較（a <= b）
fn u32_le <(i32,i32)->bool> (a, b):
    i32_le_u a b

//: u32_gt: u32 の大小比較（a > b）
fn u32_gt <(i32,i32)->bool> (a, b):
    i32_gt_u a b

//: u32_ge: u32 の大小比較（a >= b）
fn u32_ge <(i32,i32)->bool> (a, b):
    i32_ge_u a b

//: u64_add: u64 の加算（mod 2^64）
fn u64_add <(i64,i64)->i64> (a, b):
    i64_add a b

//: u64_sub: u64 の減算（mod 2^64）
fn u64_sub <(i64,i64)->i64> (a, b):
    i64_sub a b

//: u64_mul: u64 の乗算（mod 2^64）
fn u64_mul <(i64,i64)->i64> (a, b):
    i64_mul a b

//: u64_div: u64 の除算
fn u64_div <(i64,i64)->i64> (a, b):
    i64_div_u a b

//: u64_rem: u64 の剰余
fn u64_rem <(i64,i64)->i64> (a, b):
    i64_rem_u a b

//: u64_lt: u64 の大小比較（a < b）
fn u64_lt <(i64,i64)->bool> (a, b):
    i64_lt_u a b

//: u64_le: u64 の大小比較（a <= b）
fn u64_le <(i64,i64)->bool> (a, b):
    i64_le_u a b

//: u64_gt: u64 の大小比較（a > b）
fn u64_gt <(i64,i64)->bool> (a, b):
    i64_gt_u a b

//: u64_ge: u64 の大小比較（a >= b）
fn u64_ge <(i64,i64)->bool> (a, b):
    i64_ge_u a b

//: U128: u128 相当（上位/下位 64-bit）
struct U128:
    hi <i64>
    lo <i64>

//: u128_new: hi/lo から u128 値を構築する
fn u128_new <(i64,i64)->U128> (hi, lo):
    U128 hi lo

//: u128_from_u64: u64 値から u128 値を作る
fn u128_from_u64 <(i64)->U128> (v):
    U128 i64_extend_i32_u 0 v

//: u128_add: u128 の加算（mod 2^128）
fn u128_add <(U128,U128)->U128> (a, b):
    let a_hi <i64> get a "hi";
    let a_lo <i64> get a "lo";
    let b_hi <i64> get b "hi";
    let b_lo <i64> get b "lo";
    let lo <i64> i64_add a_lo b_lo;
    let carry <i64> if i64_lt_u lo a_lo:
        then i64_extend_i32_u 1
        else i64_extend_i32_u 0;
    U128 i64_add i64_add a_hi b_hi carry lo

//: u128_sub: u128 の減算（mod 2^128）
fn u128_sub <(U128,U128)->U128> (a, b):
    let a_hi <i64> get a "hi";
    let a_lo <i64> get a "lo";
    let b_hi <i64> get b "hi";
    let b_lo <i64> get b "lo";
    let lo <i64> i64_sub a_lo b_lo;
    let borrow <i64> if i64_lt_u a_lo b_lo:
        then i64_extend_i32_u 1
        else i64_extend_i32_u 0;
    U128 i64_sub i64_sub a_hi b_hi borrow lo

//: u128_lt: u128 の大小比較（a < b）
fn u128_lt <(U128,U128)->bool> (a, b):
    let a_hi <i64> get a "hi";
    let b_hi <i64> get b "hi";
    let a_lo <i64> get a "lo";
    let b_lo <i64> get b "lo";
    if i64_lt_u a_hi b_hi:
        true
    else:
        if i64_gt_u a_hi b_hi:
            false
        else:
            i64_lt_u a_lo b_lo

//: I128: i128 相当（上位/下位 64-bit, 2 の補数）
struct I128:
    hi <i64>
    lo <i64>

//: i128_new: hi/lo から i128 値を構築する
fn i128_new <(i64,i64)->I128> (hi, lo):
    I128 hi lo

//: i128_from_i64: i64 値を符号拡張して i128 に変換する
fn i128_from_i64 <(i64)->I128> (v):
    let hi <i64> if i64_lt_s v i64_extend_i32_u 0:
        then i64_extend_i32_s -1
        else i64_extend_i32_u 0;
    I128 hi v

//: i128_add: i128 の加算（mod 2^128）
fn i128_add <(I128,I128)->I128> (a, b):
    let a_hi <i64> get a "hi";
    let a_lo <i64> get a "lo";
    let b_hi <i64> get b "hi";
    let b_lo <i64> get b "lo";
    let lo <i64> i64_add a_lo b_lo;
    let carry <i64> if i64_lt_u lo a_lo:
        then i64_extend_i32_u 1
        else i64_extend_i32_u 0;
    I128 i64_add i64_add a_hi b_hi carry lo

//: i128_sub: i128 の減算（mod 2^128）
fn i128_sub <(I128,I128)->I128> (a, b):
    let a_hi <i64> get a "hi";
    let a_lo <i64> get a "lo";
    let b_hi <i64> get b "hi";
    let b_lo <i64> get b "lo";
    let lo <i64> i64_sub a_lo b_lo;
    let borrow <i64> if i64_lt_u a_lo b_lo:
        then i64_extend_i32_u 1
        else i64_extend_i32_u 0;
    I128 i64_sub i64_sub a_hi b_hi borrow lo

//: i128_lt: i128 の大小比較（a < b）
fn i128_lt <(I128,I128)->bool> (a, b):
    let a_hi <i64> get a "hi";
    let b_hi <i64> get b "hi";
    let a_lo <i64> get a "lo";
    let b_lo <i64> get b "lo";
    if i64_lt_s a_hi b_hi:
        true
    else:
        if i64_gt_s a_hi b_hi:
            false
        else:
            i64_lt_u a_lo b_lo

#if[target=llvm]
fn i32_lt_s <(i32,i32)->bool> (a,b):
    #llvmir:
        define i32 @i32_lt_s(i32 %a, i32 %b) {
        entry:
            %0 = icmp slt i32 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

#if[target=llvm]
fn i32_lt_u <(i32,i32)->bool> (a,b):
    #llvmir:
        define i32 @i32_lt_u(i32 %a, i32 %b) {
        entry:
            %0 = icmp ult i32 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

#if[target=llvm]
fn i32_le_s <(i32,i32)->bool> (a,b):
    #llvmir:
        define i32 @i32_le_s(i32 %a, i32 %b) {
        entry:
            %0 = icmp sle i32 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

#if[target=llvm]
fn i32_le_u <(i32,i32)->bool> (a,b):
    #llvmir:
        define i32 @i32_le_u(i32 %a, i32 %b) {
        entry:
            %0 = icmp ule i32 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

#if[target=llvm]
fn i32_gt_s <(i32,i32)->bool> (a,b):
    #llvmir:
        define i32 @i32_gt_s(i32 %a, i32 %b) {
        entry:
            %0 = icmp sgt i32 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

#if[target=llvm]
fn i32_gt_u <(i32,i32)->bool> (a,b):
    #llvmir:
        define i32 @i32_gt_u(i32 %a, i32 %b) {
        entry:
            %0 = icmp ugt i32 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

#if[target=llvm]
fn i32_ge_s <(i32,i32)->bool> (a,b):
    #llvmir:
        define i32 @i32_ge_s(i32 %a, i32 %b) {
        entry:
            %0 = icmp sge i32 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

#if[target=llvm]
fn i32_ge_u <(i32,i32)->bool> (a,b):
    #llvmir:
        define i32 @i32_ge_u(i32 %a, i32 %b) {
        entry:
            %0 = icmp uge i32 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

#if[target=llvm]
fn i32_eq <(i32,i32)->bool> (a,b):
    #llvmir:
        define i32 @i32_eq(i32 %a, i32 %b) {
        entry:
            %0 = icmp eq i32 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

#if[target=llvm]
fn i32_ne <(i32,i32)->bool> (a,b):
    #llvmir:
        define i32 @i32_ne(i32 %a, i32 %b) {
        entry:
            %0 = icmp ne i32 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

#if[target=llvm]
fn i64_lt_s <(i64,i64)->bool> (a,b):
    #llvmir:
        define i32 @i64_lt_s(i64 %a, i64 %b) {
        entry:
            %0 = icmp slt i64 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

#if[target=llvm]
fn i64_lt_u <(i64,i64)->bool> (a,b):
    #llvmir:
        define i32 @i64_lt_u(i64 %a, i64 %b) {
        entry:
            %0 = icmp ult i64 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

#if[target=llvm]
fn i64_le_u <(i64,i64)->bool> (a,b):
    #llvmir:
        define i32 @i64_le_u(i64 %a, i64 %b) {
        entry:
            %0 = icmp ule i64 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

#if[target=llvm]
fn i64_gt_s <(i64,i64)->bool> (a,b):
    #llvmir:
        define i32 @i64_gt_s(i64 %a, i64 %b) {
        entry:
            %0 = icmp sgt i64 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

#if[target=llvm]
fn i64_gt_u <(i64,i64)->bool> (a,b):
    #llvmir:
        define i32 @i64_gt_u(i64 %a, i64 %b) {
        entry:
            %0 = icmp ugt i64 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }

#if[target=llvm]
fn i64_ge_u <(i64,i64)->bool> (a,b):
    #llvmir:
        define i32 @i64_ge_u(i64 %a, i64 %b) {
        entry:
            %0 = icmp uge i64 %a, %b
            %1 = zext i1 %0 to i32
            ret i32 %1
        }


