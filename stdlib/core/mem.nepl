#indent 4

//: mem: メモリ管理と低レベルロード/ストア
//:
//: 目的:
//: - WASM 線形メモリ上でのアロケータと基本的な load/store を提供します。
//:
//: 実装(アルゴリズム):
//: - free list と bump を併用し、8 バイト境界に整列します。
//: - 0..4 に heap_ptr、4..8 に free_list_head を置きます。
//:
//: 注意(重要):
//: - 領域の再利用は簡易的で、細かな最適化は行いません。
//: - 無効なポインタを渡すと未定義動作になります。
//:
//: 計算量:
//: - alloc/free は平均 O(1) ですが、free list の探索で O(n) になり得ます。
//:
//: todo memory.copy などを使って効率を上げる
//:
//: ---
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target std
//:| #import "std/test" as *
//:| #import "core/mem" as *
//: fn main <()*>()> ():
//:     assert_eq_i32 0 align8 0;
//:     assert_eq_i32 8 align8 1;
//:     assert_eq_i32 8 align8 8;
//:     assert_eq_i32 16 align8 9;
//: ```
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target std
//:| #import "std/test" as *
//:| #import "core/mem" as *
//: fn main <()*>()> ():
//:     let p alloc 4;
//:     assert ne 0 p;
//:     store_i32 p 123;
//:     assert_eq_i32 123 load_i32 p;
//:     dealloc p 4;
//: ```



#import "core/math" as *
#import "core/result" as *

#if[target=llvm]
#llvmir:
    @__nepl_mem = internal global [67108864 x i8] zeroinitializer, align 16
    @__nepl_pages = internal global i32 1, align 4

//: mem_size: 現在のメモリページ数を返す
//:
//: 目的:
//: - wasm の memory.size を返します。
//:
//: 実装(アルゴリズム):
//: - wasm 命令を直接実行します。
//:
//: 注意(重要):
//: - 1 ページ = 64KiB です。
//: - llvm では内部線形メモリの擬似ページ数を返します。
//:
//: 計算量:
//: - O(1)
fn mem_size <()->i32> ():
    #if[target=wasm]
    #wasm:
        memory.size
    #if[target=llvm]
    #llvmir:
        define i32 @mem_size() {
        entry:
            %0 = load i32, ptr @__nepl_pages, align 4
            ret i32 %0
        }

//: mem_grow: メモリを拡張する
//:
//: 目的:
//: - pages だけメモリを拡張し、以前のページ数を返します。
//:
//: 実装(アルゴリズム):
//: - wasm の memory.grow を呼びます。
//:
//: 注意(重要):
//: - 失敗時は -1 を返します。
//: - llvm では擬似線形メモリの総量（64MiB）を超える要求を失敗扱いにします。
//:
//: 計算量:
//: - O(1)
fn mem_grow <(i32)*>i32> (pages):
    #if[target=wasm]
    #wasm:
        local.get $pages
        memory.grow
    #if[target=llvm]
    #llvmir:
        define i32 @mem_grow(i32 %pages) {
        entry:
            %neg = icmp slt i32 %pages, 0
            br i1 %neg, label %fail, label %cont
        cont:
            %old = load i32, ptr @__nepl_pages, align 4
            %new = add i32 %old, %pages
            %too_large = icmp sgt i32 %new, 1024
            br i1 %too_large, label %fail, label %ok
        ok:
            store i32 %new, ptr @__nepl_pages, align 4
            ret i32 %old
        fail:
            ret i32 -1
        }

//: align8: 8 バイト境界に切り上げる
//:
//: 目的:
//: - n を 8 の倍数に切り上げます。
//:
//: 実装(アルゴリズム):
//: - (n+7)/8*8 を計算します。
//:
//: 注意(重要):
//: - 8 バイト整列はアロケータの前提です。
//:
//: 計算量:
//: - O(1)
fn align8 <(i32)->i32> (n):
    let t <i32> add n 7
    mul div_s t 8 8

//: alloc: ヒープから領域を確保する
//:
//: 目的:
//: - size バイトの領域を返します（失敗時は 0）。
//:
//: 実装(アルゴリズム):
//: - free list を探索し、合うブロックが無ければ bump で拡張します。
//:
//: 注意(重要):
//: - size<=0 の場合は 0 を返します。
//: - 返り値 0 は失敗を意味します。
//:
//: 計算量:
//: - 平均 O(1) / 最悪 O(n)
fn alloc <(i32)*>i32> (size):
    if:
        cond:
            le size 0
        then:
            0
        else:
            let header <i32> 8
            let total <i32> align8 add size header
            let mut prev <i32> 0
            let mut cur <i32> load_i32 4
            let mut found <i32> 0
            while ne cur 0:
                do:
                    let blk_sz <i32> load_i32 cur
                    let next <i32> load_i32 add cur 4
                    if:
                        cond:
                            le total blk_sz
                        then:
                            if:
                                cond:
                                    eq prev 0
                                then:
                                    store_i32 4 next
                                else:
                                    store_i32 add prev 4 next
                            let remain <i32> sub blk_sz total
                            if:
                                cond:
                                    le 16 remain
                                then:
                                    let new_blk <i32> add cur total
                                    store_i32 new_blk remain
                                    store_i32 add new_blk 4 next
                                    store_i32 cur total
                                else:
                                    store_i32 cur blk_sz
                            set found add cur header
                            set cur 0
                        else:
                            set prev cur
                            set cur next
            if:
                cond:
                    ne found 0
                then:
                    found
                else:
                    let heap_ptr <i32> load_i32 0
                    let start <i32> align8 heap_ptr
                    let new_heap <i32> add start total
                    let cur_pages <i32> mem_size
                    let cur_bytes <i32> mul cur_pages 65536
                    let mut ok <bool> true
                    if:
                        cond:
                            le new_heap cur_bytes
                        then:
                            ()
                        else:
                            let need_bytes <i32> sub new_heap cur_bytes
                            let grow_pages <i32> div_s add need_bytes 65535 65536
                            let prev_pages <i32> mem_grow grow_pages
                            if:
                                cond:
                                    lt prev_pages 0
                                then:
                                    set ok false
                                else:
                                    ()
                    if:
                        cond:
                            ok
                        then:
                            store_i32 0 new_heap
                            store_i32 start total
                            add start header
                        else:
                            0

//: dealloc: 領域を解放する
//:
//: 目的:
//: - ptr を free list に戻します。
//:
//: 実装(アルゴリズム):
//: - ブロック先頭に size を書き、free list 先頭へ挿入します。
//:
//: 注意(重要):
//: - ptr<=0 は無視します。
//: - size は alloc 時のサイズと一致させてください。
//:
//: 計算量:
//: - O(1)
fn dealloc <(i32,i32)*>()> (ptr, size):
    if:
        cond:
            le ptr 0
        then:
            ()
        else:
            let header <i32> 8
            let total <i32> align8 add size header
            let blk <i32> sub ptr header
            let head <i32> load_i32 4
            store_i32 blk total
            store_i32 add blk 4 head
            store_i32 4 blk

//: realloc: 既存領域を再確保する
//:
//: 目的:
//: - サイズ変更した領域を返します。
//:
//: 実装(アルゴリズム):
//: - 新領域を確保し、必要バイトをコピーして旧領域を解放します。
//:
//: 注意(重要):
//: - ptr<=0 は新規 alloc と同等です。
//: - new_size<=0 は解放して 0 を返します。
//:
//: 計算量:
//: - O(n)
fn realloc <(i32,i32,i32)*>i32> (ptr, old_size, new_size):
    if:
        cond:
            le ptr 0
        then:
            alloc new_size
        else:
            if:
                cond:
                    le new_size 0
                then:
                    dealloc ptr old_size
                    0
                else:
                    let new_ptr <i32> alloc new_size
                    if:
                        cond:
                            le new_ptr 0
                        then:
                            0
                        else:
                            let copy_bytes <i32> if lt new_size old_size new_size old_size
                            let mut i <i32> 0
                            while lt i copy_bytes:
                                do:
                                    let b <i32> load_u8 add ptr i
                                    store_u8 add new_ptr i b
                                    set i add i 1
                            dealloc ptr old_size
                            new_ptr

//: alloc_safe: alloc の結果を Result で返す安全ラッパ
//:
//: 目的:
//: - 失敗時に `0` ではなく `Result::Err` を返し、呼び出し側で明示的に処理できるようにします。
//:
//: 実装(アルゴリズム):
//: - `alloc` の返値を検査し、`ptr>0` なら `Ok(ptr)`、それ以外は `Err(\"mem.alloc failed\")` を返します。
//:
//: 注意(重要):
//: - 既存の `alloc` は互換維持のため残してあります。
//: - 新規コードは `alloc_safe` を優先してください。
//:
//: 計算量:
//: - O(1)（`alloc` 本体を除く）
fn alloc_safe <(i32)*>Result<i32, str>> (size):
    let ptr <i32> alloc size
    if:
        lt 0 ptr
        then:
            Result<i32, str>::Ok ptr
        else:
            Result<i32, str>::Err "mem.alloc failed"

//: realloc_safe: realloc の結果を Result で返す安全ラッパ
//:
//: 目的:
//: - 再確保失敗を `Result` で扱い、エラー伝播しやすくします。
//:
//: 実装(アルゴリズム):
//: - `new_size<=0` は仕様通り `Ok(0)` とします。
//: - `realloc` の返値が 0 かどうかで成功/失敗を判定します。
//:
//: 注意(重要):
//: - `new_size>0` で `0` が返った場合のみ `Err` を返します。
//:
//: 計算量:
//: - O(1)（`realloc` 本体を除く）
fn realloc_safe <(i32,i32,i32)*>Result<i32, str>> (ptr, old_size, new_size):
    if:
        le new_size 0
        then:
            Result<i32, str>::Ok (realloc ptr old_size new_size)
        else:
            let new_ptr <i32> realloc ptr old_size new_size
            if:
                lt 0 new_ptr
                then:
                    Result<i32, str>::Ok new_ptr
                else:
                    Result<i32, str>::Err "mem.realloc failed"

//: dealloc_safe: dealloc の前提を検査する安全ラッパ
//:
//: 目的:
//: - 不正な引数を早期に検出し、呼び出し側へ `Result` で返します。
//:
//: 実装(アルゴリズム):
//: - `ptr<=0` または `size<0` を `Err` とし、それ以外は `dealloc` 後に `Ok(())` を返します。
//:
//: 計算量:
//: - O(1)
fn dealloc_safe <(i32,i32)*>Result<(), str>> (ptr, size):
    if:
        or le ptr 0 lt size 0
        then:
            Result<(), str>::Err "mem.dealloc invalid argument"
        else:
            dealloc ptr size
            Result<(), str>::Ok ()

//: load_i32: i32 を読み出す
//:
//: 目的:
//: - ptr から i32 をロードします。
//:
//: 実装(アルゴリズム):
//: - wasm の i32.load を実行します。
//:
//: 注意(重要):
//: - アラインメントは呼び出し側の責任です。
//:
//: 計算量:
//: - O(1)
fn load_i32 <(i32)->i32> (p):
    #if[target=wasm]
    #wasm:
        local.get $p
        i32.load
    #if[target=llvm]
    #llvmir:
        define i32 @load_i32(i32 %p) {
        entry:
            %idx = zext i32 %p to i64
            %ptr8 = getelementptr inbounds [67108864 x i8], ptr @__nepl_mem, i64 0, i64 %idx
            %0 = load i32, ptr %ptr8, align 1
            ret i32 %0
        }

//: store_i32: i32 を書き込む
//:
//: 目的:
//: - ptr に i32 をストアします。
//:
//: 実装(アルゴリズム):
//: - wasm の i32.store を実行します。
//:
//: 注意(重要):
//: - アラインメントは呼び出し側の責任です。
//:
//: 計算量:
//: - O(1)
fn store_i32 <(i32,i32)*>()> (p, v):
    #if[target=wasm]
    #wasm:
        local.get $p
        local.get $v
        i32.store
    #if[target=llvm]
    #llvmir:
        define void @store_i32(i32 %p, i32 %v) {
        entry:
            %idx = zext i32 %p to i64
            %ptr8 = getelementptr inbounds [67108864 x i8], ptr @__nepl_mem, i64 0, i64 %idx
            store i32 %v, ptr %ptr8, align 1
            ret void
        }

//: load_u8: 1 バイトを読み出す
//:
//: 目的:
//: - ptr から unsigned byte を読みます。
//:
//: 実装(アルゴリズム):
//: - wasm の i32.load8_u を実行します。
//:
//: 注意(重要):
//: - 返り値は i32 に拡張されます。
//:
//: 計算量:
//: - O(1)
fn load_u8 <(i32)->i32> (p):
    #if[target=wasm]
    #wasm:
        local.get $p
        i32.load8_u
    #if[target=llvm]
    #llvmir:
        define i32 @load_u8(i32 %p) {
        entry:
            %idx = zext i32 %p to i64
            %ptr8 = getelementptr inbounds [67108864 x i8], ptr @__nepl_mem, i64 0, i64 %idx
            %raw = load i8, ptr %ptr8, align 1
            %0 = zext i8 %raw to i32
            ret i32 %0
        }

//: store_u8: 1 バイトを書き込む
//:
//: 目的:
//: - ptr に 1 バイトを書き込みます。
//:
//: 実装(アルゴリズム):
//: - wasm の i32.store8 を実行します。
//:
//: 注意(重要):
//: - v の下位 8 ビットのみが使われます。
//:
//: 計算量:
//: - O(1)
fn store_u8 <(i32,i32)*>()> (p, v):
    #if[target=wasm]
    #wasm:
        local.get $p
        local.get $v
        i32.store8
    #if[target=llvm]
    #llvmir:
        define void @store_u8(i32 %p, i32 %v) {
        entry:
            %idx = zext i32 %p to i64
            %ptr8 = getelementptr inbounds [67108864 x i8], ptr @__nepl_mem, i64 0, i64 %idx
            %b = trunc i32 %v to i8
            store i8 %b, ptr %ptr8, align 1
            ret void
        }

//: memset_u8: バイト列を同じ値で埋める
//:
//: 目的:
//: - `ptr` から `len` バイトを `value`（下位 8bit）で埋めます。
//:
//: 実装(アルゴリズム):
//: - 0..len を順に走査し、`store_u8` で書き込みます。
//:
//: 注意(重要):
//: - `ptr` は少なくとも `len` バイトの有効領域を指している必要があります。
//:
//: 計算量:
//: - O(len)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target std
//:| #import "std/test" as *
//:| #import "core/mem" as *
//: fn main <()*>()> ():
//:     let p <i32> alloc 8;
//:     memset_u8 p 8 65;
//:     assert_eq_i32 65 load_u8 add p 0;
//:     assert_eq_i32 65 load_u8 add p 7;
//:     dealloc p 8;
//: ```
fn memset_u8 <(i32,i32,i32)*>()> (ptr, len, value):
    let mut i <i32> 0;
    while lt i len:
        do:
            store_u8 add ptr i value;
            set i add i 1;

//: fill_u8: `memset_u8` の同義 API
//:
//: 目的:
//: - 競プロ向けの名前でバイト埋め API を提供します。
//:
//: 実装(アルゴリズム):
//: - `memset_u8` を呼び出す薄いラッパです。
//:
//: 注意(重要):
//: - `value` は下位 8bit が使用されます。
//:
//: 計算量:
//: - O(len)
fn fill_u8 <(i32,i32,i32)*>()> (ptr, len, value):
    memset_u8 ptr len value

//: fill_i32: `i32` 配列を同じ値で埋める
//:
//: 目的:
//: - `ptr` から `count` 個の `i32` 要素を `value` で埋めます。
//:
//: 実装(アルゴリズム):
//: - 0..count を順に走査し、`store_i32` で書き込みます。
//:
//: 注意(重要):
//: - `ptr` は少なくとも `count * 4` バイトの有効領域を指している必要があります。
//:
//: 計算量:
//: - O(count)
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target std
//:| #import "std/test" as *
//:| #import "core/mem" as *
//: fn main <()*>()> ():
//:     let p <i32> alloc 16;
//:     fill_i32 p 4 42;
//:     assert_eq_i32 42 load_i32 add p 0;
//:     assert_eq_i32 42 load_i32 add p 12;
//:     dealloc p 16;
//: ```
fn fill_i32 <(i32,i32,i32)*>()> (ptr, count, value):
    let mut i <i32> 0;
    while lt i count:
        do:
            store_i32 add ptr mul i 4 value;
            set i add i 1;

//: size_of: 型のサイズを取得する
//:
//: 目的:
//: - .T のサイズ（バイト）を返します。
//:
//: 実装(アルゴリズム):
//: - intrinsic "size_of" を呼びます。
//:
//: 注意(重要):
//: - サイズはコンパイル時に決まります。
//:
//: 計算量:
//: - O(1)
fn size_of <.T> <()->i32> ():
    #intrinsic "size_of" <.T> ()

//: align_of: 型のアラインメントを取得する
//:
//: 目的:
//: - .T のアラインメント（バイト）を返します。
//:
//: 実装(アルゴリズム):
//: - intrinsic "align_of" を呼びます。
//:
//: 注意(重要):
//: - アラインメントはコンパイル時に決まります。
//:
//: 計算量:
//: - O(1)
fn align_of <.T> <()->i32> ():
    #intrinsic "align_of" <.T> ()

//: load: 任意型をロードする
//:
//: 目的:
//: - ptr から .T を読み出します。
//:
//: 実装(アルゴリズム):
//: - intrinsic "load" を呼びます。
//:
//: 注意(重要):
//: - 型とメモリ内容の整合性は呼び出し側の責任です。
//:
//: 計算量:
//: - O(1)
fn load <.T> <(i32)->.T> (ptr):
    #intrinsic "load" <.T> (ptr)

//: store: 任意型をストアする
//:
//: 目的:
//: - ptr に .T を書き込みます。
//:
//: 実装(アルゴリズム):
//: - intrinsic "store" を呼びます。
//:
//: 注意(重要):
//: - 型とメモリ内容の整合性は呼び出し側の責任です。
//:
//: 計算量:
//: - O(1)
fn store <.T> <(i32,.T)*>()> (ptr, val):
    #intrinsic "store" <.T> (ptr, val)
