//: sort: alloc/sort.nepl に関する機能を提供するライブラリ
//:
//: [目的/もくてき]:
//: - このモジュールの公開 API を提供します。
//: - 実装の変更時に最小限の doctest 実行経路を維持します。
//:
//: [注意/ちゅうい]:
//: - 詳細な関数別ドキュメントは段階的に追記します。
//:
//: neplg2:test[skip]
//: ```neplg2
//:| #entry main
//:| #target wasi
//: ()
//: ```

#indent 4

#import "core/mem" as *
#import "core/math" as *
#import "core/cast" as *
#import "alloc/vec" as *
#import "core/field" as *


// sort: Vec の in-place ソート集
//
// 目的:
// - Vec<.T> を「同じバッファのまま」並べ替える関数群を提供します。
// - 比較は trait Ord の lt (strict less-than) だけに依存します。
//
// 注意(重要):
// - 破壊的(in-place)です。v の要素が並べ替えられます。
// - 比較は昇順のみです(降順が欲しい場合は Ord を反転して実装します)。
// - 安全性のための範囲チェックを省き、v.len と v.data を直接使います。
//   (stdlib/alloc の他モジュール同様、「正しい index で呼ぶ」前提です)
//
// 計算量:
// - 各アルゴリズムごとのコメントを参照してください。


// Ord: ソートに必要な最小の順序づけ
//
// 目的:
// - 要素型 .T に「a < b」を与えるための最小トレイトです。
//
// 注意(重要):
// - lt は strict な大小比較を返してください。
// - 「等しい」判定は要求しません。
//   (a <= b は not (b < a) として構成します)
trait Ord:
    fn lt <(Self,Self)->bool> (a, b):
        false


// i32 の Ord 実装
impl Ord for i32:
    fn lt <(i32,i32)->bool> (a, b):
        lt a b

// u8 の Ord 実装
impl Ord for u8:
    fn lt <(u8,u8)->bool> (a, b):
        lt cast a cast b


// sort_lt: a < b
//: sort_lt: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_lt が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_lt <.T: Ord> <(.T,.T)->bool> (a, b):
    Ord::lt a b

// sort_le: a <= b  (not (b < a))
//: sort_le: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_le が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_le <.T: Ord> <(.T,.T)->bool> (a, b):
    not Ord::lt b a

// sort_gt: a > b  (b < a)
//: sort_gt: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_gt が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_gt <.T: Ord> <(.T,.T)->bool> (a, b):
    Ord::lt b a

// sort_ge: a >= b (not (a < b))
//: sort_ge: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_ge が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_ge <.T: Ord> <(.T,.T)->bool> (a, b):
    not Ord::lt a b


// sort_get_unchecked: 範囲チェックなしの要素取得
//
// 注意(重要):
// - 0 <= idx < v.len を満たすこと。
//: sort_get_unchecked: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_get_unchecked が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_get_unchecked <.T> <(Vec<.T>,i32)->.T> (v, idx):
    let data <i32> get v "data"
    let off <i32> mul idx size_of<.T>
    load<.T> add data off

// sort_set_unchecked: 範囲チェックなしの要素設定
//
// 注意(重要):
// - 0 <= idx < v.len を満たすこと。
//: sort_set_unchecked: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_set_unchecked が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_set_unchecked <.T> <(Vec<.T>,i32,.T)*>()> (v, idx, val):
    let data <i32> get v "data"
    let off <i32> mul idx size_of<.T>
    store<.T> add data off val;
    ()

// sort_get_unchecked_data: data ポインタ版の取得
fn sort_get_unchecked_data <.T> <(i32,i32)->.T> (data_ptr, idx):
    let off <i32> mul idx size_of<.T>
    load<.T> add data_ptr off

// sort_set_unchecked_data: data ポインタ版の設定
fn sort_set_unchecked_data <.T> <(i32,i32,.T)*>()> (data_ptr, idx, val):
    let off <i32> mul idx size_of<.T>
    store<.T> add data_ptr off val;
    ()

// sort_swap_data: data ポインタ版の交換
fn sort_swap_data <.T> <(i32,i32,i32)*>()> (data_ptr, i, j):
    if:
        eq i j
        then ()
        else:
            let a <.T> sort_get_unchecked_data<.T> data_ptr i
            let b <.T> sort_get_unchecked_data<.T> data_ptr j
            sort_set_unchecked_data<.T> data_ptr i b;
            sort_set_unchecked_data<.T> data_ptr j a;
            ()


 // sort_swap: v[i] と v[j] を交換
//: sort_swap: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_swap が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_swap <.T> <(Vec<.T>,i32,i32)*>()> (v, i, j):
    if:
        eq i j
        then ()
        else:
            let a <.T> sort_get_unchecked<.T> v i
            let b <.T> sort_get_unchecked<.T> v j
            sort_set_unchecked<.T> v i b;
            sort_set_unchecked<.T> v j a;
            ()

// sort_is_sorted: 昇順にソート済みか
//
// 注意(重要):
// - strict lt を使うため、隣り合う要素で「右 < 左」があれば未ソート。
//: sort_is_sorted: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_is_sorted が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_is_sorted <.T: Ord> <(Vec<.T>)*>bool> (v):
    let n <i32> get v "len"
    if:
        le n 1
        then true
        else:
            let mut i <i32> 1
            let mut ok <bool> true
            while and ok lt i n:
                do:
                    let a <.T> sort_get_unchecked<.T> v sub i 1;
                    let b <.T> sort_get_unchecked<.T> v i;
                    if:
                        sort_lt<.T> b a
                        then set ok false
                        else ();
                    set i add i 1;
            ok


// -----------------------------------------------------------------------------
// 1) Insertion sort
// -----------------------------------------------------------------------------
//: sort_insertion: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_insertion が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_insertion <.T: Ord> <(Vec<.T>)*>()> (v):
    let n <i32> get v "len"
    if:
        le n 1
        then ()
        else:
            let mut i <i32> 1
            while lt i n:
                do:
                    let key <.T> sort_get_unchecked<.T> v i;
                    let mut j <i32> sub i 1;

                    let mut done <i32> 0;
                    while eq done 0:
                        do:
                            if:
                                and le 0 j sort_lt<.T> key sort_get_unchecked<.T> v j
                                then:
                                    let x <.T> sort_get_unchecked<.T> v j;
                                    sort_set_unchecked<.T> v add j 1 x;
                                    set j sub j 1;
                                else set done 1;
                    sort_set_unchecked<.T> v add j 1 key;
                    set i add i 1;
            ()


// -----------------------------------------------------------------------------
// 2) Selection sort
// -----------------------------------------------------------------------------
//: sort_selection: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_selection が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_selection <.T: Ord> <(Vec<.T>)*>()> (v):
    let n <i32> get v "len"
    if:
        le n 1
        then ()
        else:
            let mut i <i32> 0
            while lt i n:
                do:
                    let mut min_idx <i32> i;
                    let mut j <i32> add i 1;
                    while lt j n:
                        do:
                            let a <.T> sort_get_unchecked<.T> v j;
                            let b <.T> sort_get_unchecked<.T> v min_idx;
                            if:
                                sort_lt<.T> a b
                                then set min_idx j
                                else ();
                            set j add j 1;
                    sort_swap<.T> v i min_idx;
                    set i add i 1;
            ()


// -----------------------------------------------------------------------------
// 3) Bubble sort
// -----------------------------------------------------------------------------
//: sort_bubble: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_bubble が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_bubble <.T: Ord> <(Vec<.T>)*>()> (v):
    let n <i32> get v "len"
    if:
        le n 1
        then ()
        else:
            let mut end <i32> sub n 1;
            while lt 0 end:
                do:
                    let mut i <i32> 0;
                    while lt i end:
                        do:
                            let a <.T> sort_get_unchecked<.T> v i;
                            let b <.T> sort_get_unchecked<.T> v add i 1;
                            if:
                                sort_lt<.T> b a
                                then sort_swap<.T> v i add i 1
                                else ();
                            set i add i 1;
                    set end sub end 1;
            ()


// -----------------------------------------------------------------------------
// 4) Cocktail shaker sort
// -----------------------------------------------------------------------------
//: sort_cocktail: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_cocktail が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_cocktail <.T: Ord> <(Vec<.T>)*>()> (v):
    let n <i32> get v "len"
    if:
        le n 1
        then ()
        else:
            let mut start <i32> 0;
            let mut end <i32> sub n 1;
            let mut swapped <i32> 1;

            while and eq swapped 1 lt start end:
                do:
                    set swapped 0;

                    // forward pass
                    let mut i <i32> start;
                    while lt i end:
                        do:
                            let a <.T> sort_get_unchecked<.T> v i;
                            let b <.T> sort_get_unchecked<.T> v add i 1;
                            if:
                                sort_lt<.T> b a
                                then:
                                    sort_swap<.T> v i add i 1;
                                    set swapped 1;
                                    ()
                                else ();
                            set i add i 1;

                    set end sub end 1;

                    if:
                        eq swapped 0
                        then set start end
                        else:
                            set swapped 0;

                    // backward pass
                    let mut j <i32> end;
                    while lt start j:
                        do:
                            let a <.T> sort_get_unchecked<.T> v sub j 1;
                            let b <.T> sort_get_unchecked<.T> v j;
                            if:
                                sort_lt<.T> b a
                                then:
                                    sort_swap<.T> v sub j 1 j;
                                    set swapped 1;
                                    ()
                                else ();
                            set j sub j 1;

                    set start add start 1;
            ()


// -----------------------------------------------------------------------------
// 5) Gnome sort
// -----------------------------------------------------------------------------
//: sort_gnome: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_gnome が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_gnome <.T: Ord> <(Vec<.T>)*>()> (v):
    let n <i32> get v "len"
    if:
        le n 1
        then ()
        else:
            let mut i <i32> 1;
            while lt i n:
                do:
                    if:
                        or eq i 0 sort_le<.T> sort_get_unchecked<.T> v sub i 1 sort_get_unchecked<.T> v i
                        then set i add i 1
                        else:
                            sort_swap<.T> v i sub i 1;
                            set i sub i 1;
                    ();
            ()


// -----------------------------------------------------------------------------
// 6) Shell sort
// -----------------------------------------------------------------------------
//: sort_shell: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_shell が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_shell <.T: Ord> <(Vec<.T>)*>()> (v):
    let n <i32> get v "len"
    if:
        le n 1
        then ()
        else:
            let mut gap <i32> div_s n 2;

            while lt 0 gap:
                do:
                    let mut i <i32> gap;
                    while lt i n:
                        do:
                            let temp <.T> sort_get_unchecked<.T> v i;
                            let mut j <i32> i;

                            let mut done <i32> 0;
                            while eq done 0:
                                do:
                                    if:
                                        and le gap j sort_lt<.T> temp sort_get_unchecked<.T> v sub j gap
                                        then:
                                            let x <.T> sort_get_unchecked<.T> v sub j gap;
                                            sort_set_unchecked<.T> v j x;
                                            set j sub j gap;
                                        else set done 1;

                            sort_set_unchecked<.T> v j temp;
                            set i add i 1;
                    set gap div_s gap 2;
            ()


// -----------------------------------------------------------------------------
// 7) Comb sort
// -----------------------------------------------------------------------------
//: sort_comb: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_comb が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_comb <.T: Ord> <(Vec<.T>)*>()> (v):
    let n <i32> get v "len"
    if:
        le n 1
        then ()
        else:
            let mut gap <i32> n;
            let mut sorted <i32> 0;

            while eq sorted 0:
                do:
                    // gap = floor(gap * 10 / 13)
                    set gap div_s mul gap 10 13;
                    if:
                        lt gap 1
                        then set gap 1
                        else ();

                    if:
                        eq gap 1
                        then set sorted 1
                        else ();

                    let mut i <i32> 0;
                    while lt add i gap n:
                        do:
                            let a <.T> sort_get_unchecked<.T> v i;
                            let b <.T> sort_get_unchecked<.T> v add i gap;
                            if:
                                sort_lt<.T> b a
                                then:
                                    sort_swap<.T> v i add i gap;
                                    set sorted 0;
                                    ()
                                else ();
                            set i add i 1;
            ()


// -----------------------------------------------------------------------------
// 8) Quick sort (Lomuto partition)
// -----------------------------------------------------------------------------
//: sort_quick_partition: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_quick_partition が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_quick_partition_data <.T: Ord> <(i32,i32,i32)*>i32> (data_ptr, lo, hi):
    let pivot <.T> sort_get_unchecked_data<.T> data_ptr hi
    let mut i <i32> lo;
    let mut j <i32> lo;

    while lt j hi:
        do:
            let x <.T> sort_get_unchecked_data<.T> data_ptr j;
            if:
                sort_le<.T> x pivot
                then:
                    sort_swap_data<.T> data_ptr i j;
                    set i add i 1;
                    ()
                else ();
            set j add j 1;

    sort_swap_data<.T> data_ptr i hi;
    i

//: sort_quick_range: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_quick_range が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_quick_range_data <.T: Ord> <(i32,i32,i32)*>()> (data_ptr, lo, hi):
    if:
        lt lo hi
        then:
            let p <i32> sort_quick_partition_data<.T> data_ptr lo hi;
            sort_quick_range_data<.T> data_ptr lo sub p 1;
            sort_quick_range_data<.T> data_ptr add p 1 hi;
            ()
        else ()

//: sort_quick: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_quick が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_quick <.T: Ord> <(Vec<.T>)*>()> (v):
    let n <i32> get v "len"
    let data_ptr <i32> get v "data"
    if:
        le n 1
        then ()
        else:
            sort_quick_range_data<.T> data_ptr 0 sub n 1;
            ()


// -----------------------------------------------------------------------------
// 9) Heap sort (max-heap)
// -----------------------------------------------------------------------------
//: sort_heap_sift_down: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_heap_sift_down が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_heap_sift_down_data <.T: Ord> <(i32,i32,i32)*>()> (data_ptr, start, end):
    let mut root <i32> start;
    let mut done <i32> 0;

    while eq done 0:
        do:
            let child <i32> add mul root 2 1;
            if:
                lt child end
                then:
                    let mut swap_idx <i32> root;

                    if:
                        sort_lt<.T> sort_get_unchecked_data<.T> data_ptr swap_idx sort_get_unchecked_data<.T> data_ptr child
                        then set swap_idx child
                        else ();

                    let right <i32> add child 1;
                    if:
                        lt right end
                        then:
                            if:
                                sort_lt<.T> sort_get_unchecked_data<.T> data_ptr swap_idx sort_get_unchecked_data<.T> data_ptr right
                                then set swap_idx right
                                else ();
                            ()
                        else ();

                    if:
                        eq swap_idx root
                        then set done 1
                        else:
                            sort_swap_data<.T> data_ptr root swap_idx;
                            set root swap_idx;
                            ();
                    ()
                else set done 1;

    ()

//: sort_heap: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_heap が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_heap <.T: Ord> <(Vec<.T>)*>()> (v):
    let n <i32> get v "len"
    let data_ptr <i32> get v "data"
    if:
        le n 1
        then ()
        else:
            let mut start <i32> div_s sub n 2 2;
            let mut done0 <i32> 0;
            while eq done0 0:
                do:
                    if:
                        lt start 0
                        then set done0 1
                        else:
                            sort_heap_sift_down_data data_ptr start n;
                            set start sub start 1;
                            ();
            let mut end <i32> sub n 1;
            while lt 0 end:
                do:
                    sort_swap_data<.T> data_ptr 0 end;
                    sort_heap_sift_down_data data_ptr 0 end;
                    set end sub end 1;
            ()


// -----------------------------------------------------------------------------
// 10) Merge sort (top-down)
// -----------------------------------------------------------------------------
//: sort_buf_get: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_buf_get が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_buf_get <.T> <(i32,i32)->.T> (buf, idx):
    let off <i32> mul idx size_of<.T>
    load<.T> add buf off

//: sort_buf_set: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_buf_set が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_buf_set <.T> <(i32,i32,.T)*>()> (buf, idx, val):
    let off <i32> mul idx size_of<.T>
    store<.T> add buf off val;
    ()

//: sort_merge_range: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_merge_range が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_merge_range_data <.T: Ord> <(i32,i32,i32,i32)*>()> (data_ptr, buf, l, r):
    if:
        le sub r l 1
        then ()
        else:
            let mid <i32> div_s add l r 2;
            sort_merge_range_data data_ptr buf l mid;
            sort_merge_range_data data_ptr buf mid r;

            let mut i0 <i32> l;
            while lt i0 r:
                do:
                    let x <.T> sort_get_unchecked_data<.T> data_ptr i0;
                    sort_buf_set<.T> buf i0 x;
                    set i0 add i0 1;

            let mut i <i32> l;
            let mut j <i32> mid;
            let mut k <i32> l;

            while and lt i mid lt j r:
                do:
                    let a <.T> sort_buf_get<.T> buf i;
                    let b <.T> sort_buf_get<.T> buf j;
                    if:
                        sort_lt<.T> b a
                        then:
                            sort_set_unchecked_data<.T> data_ptr k b;
                            set j add j 1;
                            ()
                        else:
                            sort_set_unchecked_data<.T> data_ptr k a;
                            set i add i 1;
                            ();
                    set k add k 1;

            while lt i mid:
                do:
                    let a <.T> sort_buf_get<.T> buf i;
                    sort_set_unchecked_data<.T> data_ptr k a;
                    set i add i 1;
                    set k add k 1;

            while lt j r:
                do:
                    let b <.T> sort_buf_get<.T> buf j;
                    sort_set_unchecked_data<.T> data_ptr k b;
                    set j add j 1;
                    set k add k 1;

            ()

//: sort_merge: 関数の概要
//:
//: [目的/もくてき]:
//: - sort_merge が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort_merge <.T: Ord> <(Vec<.T>)*>()> (v):
    let n <i32> get v "len"
    let data_ptr <i32> get v "data"
    if:
        le n 1
        then ()
        else:
            let bytes <i32> mul n size_of<.T>
            let buf <i32> alloc bytes
            sort_merge_range_data data_ptr buf 0 n;
            dealloc buf bytes;
            ()


// sort: デフォルトは quick sort
//: sort: 関数の概要
//:
//: [目的/もくてき]:
//: - sort が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sort <.T: Ord> <(Vec<.T>)*>()> (v):
    sort_quick<.T> v
