//: stack: [後入先出/こうにゅうせんしゅつ]（LIFO）スタックを扱うライブラリ
//:
//: [目的/もくてき]:
//: - `push` / `pop` / `peek` / `len` など、スタック操作の基本 API を提供します。
//: - parser や探索処理で使いやすい軽量なポインタベース実装を提供します。
//:
//: [実装/じっそう]:
//: - スタック本体は `i32` ポインタで表し、ヘッダ `[len, cap, data_ptr]` と要素領域を保持します。
//: - 容量不足時は 2 倍拡張して `realloc` します。
//:
//: [注意/ちゅうい]:
//: - `stack_push` / `stack_clear` は破壊的更新です。
//: - `stack_pop` / `stack_peek` は空の場合 `Option::None` を返します。
//: - `stack_free` 後のポインタは再利用できません。
//:
//: [計算量/けいさんりょう]:
//: - `stack_len`/`stack_is_empty`/`stack_peek`/`stack_pop` は O(1)。
//: - `stack_push` はならし O(1)、拡張発生時のみ O(n)。
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/stack" as *
//:| #import "alloc/string" as *
//:| #import "core/option" as *
//: fn main <()->i32> ():
//:     let st stack_new<i32>;
//:     stack_push<i32> st 10;
//:     stack_push<i32> st 20;
//:     let ok0 if eq stack_len<i32> st 2 1 0;
//:     let ok1 match stack_peek<i32> st:
//:         Option::Some x:
//:             if eq x 20 1 0
//:         Option::None:
//:             0
//:     match stack_pop<i32> st:
//:         Option::Some x:
//:             ()
//:         Option::None:
//:             ()
//:     stack_clear<i32> st;
//:     let ok2 if stack_is_empty<i32> st 1 0;
//:     add ok0 add ok1 ok2
//: ```
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/stack" as *
//:| #import "alloc/string" as *
//:| #import "core/option" as *
//: fn main <()->i32> ():
//:     let st stack_new<str>;
//:     stack_push<str> st "a";
//:     stack_push<str> st "b";
//:     let ok0 match stack_pop<str> st:
//:         Option::Some x:
//:             if str_eq x "b" 1 0
//:         Option::None:
//:             0
//:     let ok1 match stack_pop<str> st:
//:         Option::Some x:
//:             if str_eq x "a" 1 0
//:         Option::None:
//:             0
//:     let ok2 match stack_pop<str> st:
//:         Option::Some _:
//:             0
//:         Option::None:
//:             1
//:     add ok0 add ok1 ok2
//: ```

#indent 4

#import "core/mem" as *
#import "core/option" as *

//: stack: LIFO スタック（可変長配列ベース）
//:
//: 目的:
//: - push/pop/peek などの基本操作を提供します。
//:
//: 実装(アルゴリズム):
//: - [len][cap][data_ptr] を持つヘッダとデータ領域を確保します。
//:
//: 注意(重要):
//: - pop/peek は Option を返します。
//: - スタック本体は i32 ポインタで扱います。
//:
//: 計算量:
//: - push/pop/peek: ならし O(1)

//: stack_new: 空のスタックを作る
//:
//: 目的:
//: - 既定容量で空のスタックを返します。
//:
//: 実装(アルゴリズム):
//: - ヘッダ 12 バイトとデータ領域を確保します。
//:
//: 注意(重要):
//: - 返り値はヘッダのポインタです。
//:
//: 計算量:
//: - O(1)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/stack" as *
//: fn main <()->i32> ():
//:     let st stack_new<i32>;
//:     if stack_is_empty<i32> st 0 1
//: ```
fn stack_new <.T> <()*>i32> ():
    let cap <i32> 8
    let header <i32> alloc 12
    store_i32 header 0  // len
    store_i32 add header 4 cap
    let data <i32> alloc mul cap size_of<.T>
    store_i32 add header 8 data
    header

//: stack_push: 末尾に要素を積む
//:
//: 目的:
//: - item を末尾に追加します。
//:
//: 実装(アルゴリズム):
//: - 容量不足なら 2 倍に拡張して realloc します。
//:
//: 注意(重要):
//: - スタックは破壊的に更新されます。
//:
//: 計算量:
//: - ならし O(1)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/stack" as *
//: fn main <()->i32> ():
//:     let st stack_new<i32>;
//:     stack_push<i32> st 10;
//:     if eq stack_len<i32> st 1 0 1
//: ```
fn stack_push <.T> <(i32,.T)*>()> (stk, item):
    let len <i32> load_i32 stk
    let cap <i32> load_i32 add stk 4
    let data <i32> load_i32 add stk 8
    if:
        eq len cap
        then:
            let new_cap <i32> mul cap 2
            let new_data <i32> realloc data mul cap size_of<.T> mul new_cap size_of<.T>
            store_i32 add stk 4 new_cap
            store_i32 add stk 8 new_data
            let offset <i32> mul len size_of<.T>
            store<.T> add new_data offset item
            store_i32 stk add len 1
        else:
            let offset <i32> mul len size_of<.T>
            store<.T> add data offset item
            store_i32 stk add len 1

//: stack_pop: 末尾要素を取り出す
//:
//: 目的:
//: - 末尾要素を返し、長さを 1 減らします。
//:
//: 実装(アルゴリズム):
//: - len==0 なら None、そうでなければ最後の要素を load します。
//:
//: 注意(重要):
//: - 取り出した値は Option で返します。
//:
//: 計算量:
//: - O(1)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/stack" as *
//:| #import "core/option" as *
//: fn main <()->i32> ():
//:     let st stack_new<i32>;
//:     stack_push<i32> st 10;
//:     match stack_pop<i32> st:
//:         Option::Some x:
//:             if eq x 10 0 1
//:         Option::None:
//:             1
//: ```
fn stack_pop <.T> <(i32)*>Option<.T>> (stk):
    let len <i32> load_i32 stk
    if:
        eq len 0
        then:
            none<.T>
        else:
            let new_len <i32> sub len 1
            let data <i32> load_i32 add stk 8
            let offset <i32> mul new_len size_of<.T>
            let item <.T> load<.T> add data offset
            store_i32 stk new_len
            some<.T> item

//: stack_peek: 末尾要素を覗く
//:
//: 目的:
//: - 末尾要素を取り出さずに返します。
//:
//: 実装(アルゴリズム):
//: - len==0 なら None、そうでなければ最後の要素を load します。
//:
//: 注意(重要):
//: - スタックは変更されません。
//:
//: 計算量:
//: - O(1)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/stack" as *
//:| #import "core/option" as *
//: fn main <()->i32> ():
//:     let st stack_new<i32>;
//:     stack_push<i32> st 20;
//:     match stack_peek<i32> st:
//:         Option::Some x:
//:             if eq x 20 0 1
//:         Option::None:
//:             1
//: ```
fn stack_peek <.T> <(i32)->Option<.T>> (stk):
    let len <i32> load_i32 stk
    if:
        eq len 0
        then:
            none<.T>
        else:
            let data <i32> load_i32 add stk 8
            let offset <i32> mul sub len 1 size_of<.T>
            some<.T> load<.T> add data offset

//: stack_len: 長さを返す
//:
//: 目的:
//: - len を返します。
//:
//: 実装(アルゴリズム):
//: - ヘッダ先頭の i32 を読むだけです。
//:
//: 注意(重要):
//: - 変更操作ではありません。
//:
//: 計算量:
//: - O(1)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/stack" as *
//: fn main <()->i32> ():
//:     let st stack_new<i32>;
//:     stack_push<i32> st 1;
//:     stack_push<i32> st 2;
//:     if eq stack_len<i32> st 2 0 1
//: ```
fn stack_len <.T> <(i32)->i32> (stk):
    load_i32 stk

//: stack_is_empty: 空か判定する
//:
//: 目的:
//: - len==0 なら true を返します。
//:
//: 実装(アルゴリズム):
//: - len を読んで 0 と比較します。
//:
//: 注意(重要):
//: - 変更操作ではありません。
//:
//: 計算量:
//: - O(1)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/stack" as *
//: fn main <()->i32> ():
//:     let st stack_new<i32>;
//:     if stack_is_empty<i32> st 0 1
//: ```
fn stack_is_empty <.T> <(i32)->bool> (stk):
    eq load_i32 stk 0

//: stack_clear: すべての要素を削除する
//:
//: 目的:
//: - len を 0 にして空にします。
//:
//: 実装(アルゴリズム):
//: - ヘッダ先頭を書き換えます。
//:
//: 注意(重要):
//: - メモリは解放されません。
//:
//: 計算量:
//: - O(1)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/stack" as *
//: fn main <()->i32> ():
//:     let st stack_new<i32>;
//:     stack_push<i32> st 9;
//:     stack_clear<i32> st;
//:     if stack_is_empty<i32> st 0 1
//: ```
fn stack_clear <.T> <(i32)*>()> (stk):
    store_i32 stk 0

//: stack_free: メモリを解放する
//:
//: 目的:
//: - データ領域とヘッダを解放します。
//:
//: 実装(アルゴリズム):
//: - cap に基づき data を解放し、ヘッダも dealloc します。
//:
//: 注意(重要):
//: - この後に stk を使うと未定義です。
//:
//: 計算量:
//: - O(1)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/stack" as *
//: fn main <()->i32> ():
//:     let st stack_new<i32>;
//:     stack_free<i32> st;
//:     0
//: ```
fn stack_free <.T> <(i32)*>()> (stk):
    let cap <i32> load_i32 add stk 4
    let data <i32> load_i32 add stk 8
    dealloc data mul cap size_of<.T>
    dealloc stk 12
