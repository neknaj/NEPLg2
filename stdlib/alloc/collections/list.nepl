//: list: [単方向/たんほうこう][連結/れんけつ]リストを扱うライブラリ
//:
//: [目的/もくてき]:
//: - `cons/head/tail/get/len/reverse` など、リスト処理の基本 API を提供します。
//: - 空リスト・範囲外アクセスを `Option` で安全に扱える形で提供します。
//:
//: [実装/じっそう]:
//: - ノードは `[value:.T][next:i32]` レイアウトでヒープ確保します。
//: - 空リストは `0` ポインタで表現します。
//:
//: [注意/ちゅうい]:
//: - `list_get` は範囲外や負 index で `Option::None` を返します。
//: - `list_free` は循環リストを想定していません。
//: - `list_reverse` は新しいノード列を構築するため、元リストと逆順リストは別管理です。
//:
//: [計算量/けいさんりょう]:
//: - `list_nil`/`list_cons`/`list_head`/`list_tail`/`list_is_empty` は O(1)。
//: - `list_len`/`list_get`/`list_free`/`list_reverse` は O(n)。
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/list" as *
//:| #import "alloc/string" as *
//:| #import "core/option" as *
//: fn main <()->i32> ():
//:     let l0 list_nil<i32>;
//:     let l1 list_cons<i32> 3 l0;
//:     let l2 list_cons<i32> 2 l1;
//:     let l3 list_cons<i32> 1 l2;
//:     let ok0 if eq list_len<i32> l3 3 1 0;
//:     let ok1 match list_head<i32> l3:
//:         Option::Some x:
//:             if eq x 1 1 0
//:         Option::None:
//:             0
//:     let ok2 match list_get<i32> l3 1:
//:         Option::Some x:
//:             if eq x 2 1 0
//:         Option::None:
//:             0
//:     let ok3 match list_tail<i32> l3:
//:         Option::Some t:
//:             if eq list_len<i32> t 2 1 0
//:         Option::None:
//:             0
//:     add ok0 add ok1 add ok2 ok3
//: ```
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/list" as *
//:| #import "alloc/string" as *
//:| #import "core/option" as *
//: fn main <()->i32> ():
//:     let l0 list_nil<str>;
//:     let l1 list_cons<str> "c" l0;
//:     let l2 list_cons<str> "b" l1;
//:     let l3 list_cons<str> "a" l2;
//:     let r list_reverse<str> l3;
//:     let ok0 match list_head<str> r:
//:         Option::Some x:
//:             if str_eq x "c" 1 0
//:         Option::None:
//:             0
//:     let ok1 match list_get<str> r 2:
//:         Option::Some x:
//:             if str_eq x "a" 1 0
//:         Option::None:
//:             0
//:     let ok2 if is_none<str> list_get<str> r 3 1 0;
//:     add ok0 add ok1 ok2
//: ```

#indent 4

#import "core/mem" as *
#import "core/math" as *
#import "core/option" as *

//: list: 単方向連結リスト（i32 のポインタをノード先頭として扱う）
//:
//: 目的:
//: - 空リストを 0 ポインタで表し、ノードをヒープ上に確保します。
//: - Option を用いて「存在しない値」を明示します。
//:
//: 実装(アルゴリズム):
//: - ノードは [value:.T][next:i32] の順で配置します。
//: - 末尾は 0 を next として表します。
//:
//: 注意(重要):
//: - list_head/list_tail/list_get は空や範囲外のとき None を返します。
//: - list_free はノードを順に解放します（循環リストは未対応）。
//:
//: 計算量:
//: - 参照・挿入: O(1)
//: - 走査系: O(n)

//: list_nil: 空リストを表す値を返す
//:
//: 目的:
//: - 空リスト（null ポインタ）を返します。
//:
//: 実装(アルゴリズム):
//: - 定数 0 を返すだけです。
//:
//: 注意(重要):
//: - 0 は「空」を表す特別な値です。
//:
//: 計算量:
//: - O(1)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/list" as *
//: fn main <()->i32> ():
//:     if list_is_empty<i32> list_nil<i32> 0 1
//: ```
fn list_nil <.T> <()->i32> ():
    0

//: list_cons: 先頭に要素を追加して新しいリストを作る
//:
//: 目的:
//: - head を値として持つ新ノードを確保し、tail を next に接続します。
//:
//: 実装(アルゴリズム):
//: - size_of<.T> + 4 の領域を確保し、[value][next] を格納します。
//:
//: 注意(重要):
//: - 返り値は新しい先頭ノードのポインタです。
//:
//: 計算量:
//: - O(1)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/list" as *
//: fn main <()->i32> ():
//:     let l list_cons<i32> 5 list_nil<i32>;
//:     if list_is_empty<i32> l 1 0
//: ```
fn list_cons <.T> <(.T,i32)*>i32> (head, tail):
    let node_size <i32> add size_of<.T> 4
    let node <i32> alloc node_size
    store<.T> node head
    store_i32 add node size_of<.T> tail
    node

//: list_head: 先頭要素を取得する
//:
//: 目的:
//: - 空なら None、非空なら先頭の値を Some で返します。
//:
//: 実装(アルゴリズム):
//: - lst が 0 かを判定し、非空なら value を load します。
//:
//: 注意(重要):
//: - 空リストでは None を返します。
//:
//: 計算量:
//: - O(1)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/list" as *
//:| #import "core/option" as *
//: fn main <()->i32> ():
//:     let l list_cons<i32> 8 list_nil<i32>;
//:     match list_head<i32> l:
//:         Option::Some x:
//:             if eq x 8 0 1
//:         Option::None:
//:             1
//: ```
fn list_head <.T> <(i32)->Option<.T>> (lst):
    if:
        cond:
            eq lst 0
        then:
            none<.T>
        else:
            some<.T> load<.T> lst

//: list_tail: 末尾以外の部分（次のノード）を取得する
//:
//: 目的:
//: - 空なら None、非空なら next ポインタを Some で返します。
//:
//: 実装(アルゴリズム):
//: - lst が 0 かを判定し、非空なら next を load します。
//:
//: 注意(重要):
//: - 戻り値の Some は i32 のポインタです。
//:
//: 計算量:
//: - O(1)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/list" as *
//:| #import "core/option" as *
//: fn main <()->i32> ():
//:     let l0 list_nil<i32>;
//:     let l1 list_cons<i32> 2 l0;
//:     let l2 list_cons<i32> 1 l1;
//:     match list_tail<i32> l2:
//:         Option::Some t:
//:             if eq list_len<i32> t 1 0 1
//:         Option::None:
//:             1
//: ```
fn list_tail <.T> <(i32)->Option<i32>> (lst):
    if:
        cond:
            eq lst 0
        then:
            none<i32>
        else:
            some<i32> load_i32 add lst size_of<.T>

//: list_is_empty: 空リストか判定する
//:
//: 目的:
//: - lst が空なら true を返します。
//:
//: 実装(アルゴリズム):
//: - lst == 0 を判定します。
//:
//: 注意(重要):
//: - 空リストは 0 で表します。
//:
//: 計算量:
//: - O(1)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/list" as *
//: fn main <()->i32> ():
//:     if list_is_empty<i32> list_nil<i32> 0 1
//: ```
fn list_is_empty <.T> <(i32)->bool> (lst):
    eq lst 0

//: list_len: 長さを数える
//:
//: 目的:
//: - リストの要素数を返します。
//:
//: 実装(アルゴリズム):
//: - next をたどりながらカウントを増やします。
//:
//: 注意(重要):
//: - 循環リストに対しては無限ループします。
//:
//: 計算量:
//: - O(n)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/list" as *
//: fn main <()->i32> ():
//:     let l0 list_nil<i32>;
//:     let l1 list_cons<i32> 3 l0;
//:     let l2 list_cons<i32> 2 l1;
//:     let l3 list_cons<i32> 1 l2;
//:     if eq list_len<i32> l3 3 0 1
//: ```
fn list_len <.T> <(i32)*>i32> (lst):
    let mut count <i32> 0
    let mut cur <i32> lst
    while ne cur 0:
        do:
            set count add count 1
            set cur load_i32 add cur size_of<.T>
    count

//: list_get: 指定位置の要素を取得する
//:
//: 目的:
//: - idx が範囲内なら Some(value)、範囲外なら None を返します。
//:
//: 実装(アルゴリズム):
//: - 先頭から idx 回 next をたどり、到達したノードの value を返します。
//: - 途中で null に到達したら None を返します。
//:
//: 注意(重要):
//: - idx が負のときは None です。
//:
//: 計算量:
//: - O(n)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/list" as *
//:| #import "core/option" as *
//: fn main <()->i32> ():
//:     let l0 list_nil<i32>;
//:     let l1 list_cons<i32> 3 l0;
//:     let l2 list_cons<i32> 2 l1;
//:     let l3 list_cons<i32> 1 l2;
//:     match list_get<i32> l3 1:
//:         Option::Some x:
//:             if eq x 2 0 1
//:         Option::None:
//:             1
//: ```
fn list_get <.T> <(i32,i32)*>Option<.T>> (lst, idx):
    if:
        cond:
            lt idx 0
        then:
            none<.T>
        else:
            let mut cur <i32> lst
            let mut i <i32> 0
            let mut done <i32> 0
            let mut out <Option<.T>> none<.T>
            while eq done 0:
                if:
                    cond:
                        eq cur 0
                    then:
                        set done 1
                    else:
                        if:
                            cond:
                                eq i idx
                            then:
                                set out some<.T> load<.T> cur
                                set done 1
                            else:
                                set cur load_i32 add cur size_of<.T>
                                set i add i 1
            out

//: list_free: リスト全体を解放する
//:
//: 目的:
//: - 連結リストの全ノードを解放します。
//:
//: 実装(アルゴリズム):
//: - next を保存しながら現在ノードを順に dealloc します。
//:
//: 注意(重要):
//: - 循環リストには対応していません。
//:
//: 計算量:
//: - O(n)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/list" as *
//: fn main <()->i32> ():
//:     let l0 list_nil<i32>;
//:     let l1 list_cons<i32> 1 l0;
//:     list_free<i32> l1;
//:     0
//: ```
fn list_free <.T> <(i32)*>()> (lst):
    let node_size <i32> add size_of<.T> 4
    let mut cur <i32> lst
    while ne cur 0:
        do:
            let next <i32> load_i32 add cur size_of<.T>
            dealloc cur node_size
            set cur next

//: list_reverse: リストを逆順にする
//:
//: 目的:
//: - 逆順の新しいリストを作って返します。
//:
//: 実装(アルゴリズム):
//: - 先頭から走査し、list_cons で新しい先頭へ積み直します。
//:
//: 注意(重要):
//: - 返り値は新しいリストで、元のノードは再利用しません。
//:
//: 計算量:
//: - O(n)
//:
//: 使い方:
//:
//: neplg2:test
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "alloc/collections/list" as *
//:| #import "core/option" as *
//: fn main <()->i32> ():
//:     let l0 list_nil<i32>;
//:     let l1 list_cons<i32> 3 l0;
//:     let l2 list_cons<i32> 2 l1;
//:     let l3 list_cons<i32> 1 l2;
//:     let r list_reverse<i32> l3;
//:     match list_head<i32> r:
//:         Option::Some x:
//:             if eq x 3 0 1
//:         Option::None:
//:             1
//: ```
fn list_reverse <.T> <(i32)*>i32> (lst):
    let mut new_list <i32> 0;
    let mut cur <i32> lst;
    while ne cur 0:
        do:
            let val <.T> load<.T> cur;
            set new_list list_cons<.T> val new_list;
            set cur load_i32 add cur size_of<.T>;
    new_list
