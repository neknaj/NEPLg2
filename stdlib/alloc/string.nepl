//: string: alloc/string.nepl に関する機能を提供するライブラリ
//:
//: [目的/もくてき]:
//: - このモジュールの公開 API を提供します。
//: - 実装の変更時に最小限の doctest 実行経路を維持します。
//:
//: [注意/ちゅうい]:
//: - 詳細な関数別ドキュメントは段階的に追記します。
//:
//: neplg2:test[skip]
//: ```neplg2
//:| #entry main
//:| #target wasi
//: ()
//: ```

#indent 4

#import "core/mem" as *
#import "core/result" as *
#import "core/option" as *
#import "core/math" as *
#import "alloc/vec" as *
#import "core/field" as *

// string: 文字列操作（長さ付きUTF-8）
//
// 目的:
// - [len:i32][bytes...] 形式の UTF-8 文字列を扱う関数群を提供します。
//
// 実装(アルゴリズム):
// - 文字列はヒープに確保し、先頭 4 バイトに長さを格納します。
//
// 注意(重要):
// - 文字列は NUL 終端ではありません。
// - 変換関数は i32/i64/f32/f64 の主要経路を提供します。
//
// 計算量:
// - 連結や変換は O(n)

// len: 文字列の長さを返す
//
// 目的:
// - 文字列のバイト長を返します。
//
// 実装(アルゴリズム):
// - 先頭 4 バイトの長さを読み出します。
//
// 注意(重要):
// - UTF-8 のバイト長であり、文字数とは一致しません。
//
// 計算量:
// - O(1)
//: len: 関数の概要
//:
//: [目的/もくてき]:
//: - len が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn len <(str)->i32> (s):
    load_i32 s

// concat: 2つの文字列を連結する
//
// 目的:
// - a と b を連結した新しい文字列を返します。
//
// 実装(アルゴリズム):
// - 長さを計算し、新領域を確保して順にコピーします。
//
// 注意(重要):
// - 新しいバッファを確保するため O(n) のコストがかかります。
//
// 計算量:
// - O(la + lb)
//: concat: 関数の概要
//:
//: [目的/もくてき]:
//: - concat が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn concat <(str,str)*>str> (a,b):
    let la <i32> load_i32 a;
    let lb <i32> load_i32 b;
    let total <i32> add la lb;
    let out <i32> alloc add 4 total;
    store_i32 out total;
    let mut i <i32> 0;
    while lt i la:
        do:
            let ch <i32> load_u8 add a add 4 i;
            store_u8 add out add 4 i ch;
            set i add i 1;
    let mut j <i32> 0;
    while lt j lb:
        do:
            let ch <i32> load_u8 add b add 4 j;
            store_u8 add out add 4 add la j ch;
            set j add j 1;
    out

// concat3: 3つの文字列を連結する
//
// 目的:
// - a,b,c を連結した文字列を返します。
//
// 実装(アルゴリズム):
// - concat を 2 回呼び出します。
//
// 注意(重要):
// - 中間文字列を確保するため余分なコストが発生します。
//
// 計算量:
// - O(la + lb + lc)
//: concat3: 関数の概要
//:
//: [目的/もくてき]:
//: - concat3 が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn concat3 <(str,str,str)*>str> (a,b,c):
    let ab <str> concat a b;
    concat ab c

// StringBuilder: 文字列ビルダ
//
// 目的:
// - 複数の文字列を段階的に追加し、最後に 1 つへまとめます。
//
// 実装(アルゴリズム):
// - Vec<str> に部分文字列を保持します。
//
// 注意(重要):
// - sb_build は concat を繰り返すため O(n^2) になり得ます。
//
// 計算量:
// - 追加: ならし O(1)
// - build: O(n^2)
//: StringBuilder: 構造体の概要
//:
//: [目的/もくてき]:
//: - StringBuilder が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 定義そのものは O(1) です。
struct StringBuilder:
    parts <Vec<str>>

// string_builder_new: 空のビルダを作る
//
// 目的:
// - 空の StringBuilder を返します。
//
// 実装(アルゴリズム):
// - vec_new で Vec<str> を作ります。
//
// 注意(重要):
// - 初期容量は Vec の既定値に従います。
//
// 計算量:
// - O(1)
//: string_builder_new: 関数の概要
//:
//: [目的/もくてき]:
//: - string_builder_new が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn string_builder_new <()*>StringBuilder> ():
    StringBuilder vec_new<str>

// sb_append: 文字列を追加する
//
// 目的:
// - s をビルダに追加して返します。
//
// 実装(アルゴリズム):
// - 内部 Vec に push します。
//
// 注意(重要):
// - 返り値の StringBuilder を受け取り直してください。
//
// 計算量:
// - ならし O(1)
//: sb_append: 関数の概要
//:
//: [目的/もくてき]:
//: - sb_append が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sb_append <(StringBuilder,str)*>StringBuilder> (sb, s):
    let parts <Vec<str>> get sb "parts";
    let parts2 <Vec<str>> vec_push<str> parts s;
    StringBuilder parts2

// sb_append_i32: i32 を追加する
//
// 目的:
// - v を文字列化して追加します。
//
// 実装(アルゴリズム):
// - from_i32 を呼び、sb_append に渡します。
//
// 注意(重要):
// - 負数は from_i32 の制約に従います。
//
// 計算量:
// - O(d)
//: sb_append_i32: 関数の概要
//:
//: [目的/もくてき]:
//: - sb_append_i32 が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sb_append_i32 <(StringBuilder,i32)*>StringBuilder> (sb, v):
    let s <str> from_i32 v;
    sb_append sb s

// sb_build: 文字列を生成する
//
// 目的:
// - 追加された部分文字列を 1 つに連結して返します。
//
// 実装(アルゴリズム):
// - まず全パーツ長を合計して 1 回だけ領域を確保します。
// - 次に各パーツのバイト列を確保済み領域へ順にコピーします。
//
// 注意(重要):
// - 返り値は新規確保された文字列です。
//
// 計算量:
// - O(total_bytes + part_count)
//: sb_build: 関数の概要
//:
//: [目的/もくてき]:
//: - sb_build が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sb_build <(StringBuilder)*>str> (sb):
    let parts_vec <Vec<str>> get sb "parts";
    let n <i32> get parts_vec "len";
    let parts_data <i32> get parts_vec "data";
    let mut total <i32> 0;
    let mut idx0 <i32> 0;
    while lt idx0 n:
        do:
            let part <str> load<str> add parts_data mul idx0 size_of<str>;
            set total add total load_i32 part;
            set idx0 add idx0 1;
    let out <i32> alloc add 4 total;
    store_i32 out total;
    let mut idx <i32> 0;
    let mut dst <i32> 0;
    while lt idx n:
        do:
            let part <str> load<str> add parts_data mul idx size_of<str>;
            let plen <i32> load_i32 part;
            let mut i <i32> 0;
            while lt i plen:
                do:
                    let ch <i32> load_u8 add part add 4 i;
                    store_u8 add out add 4 add dst i ch;
                    set i add i 1;
            set dst add dst plen;
            set idx add idx 1;
    out

// str_eq: 文字列が等しいか判定する
//
// 目的:
// - a と b の内容が同じなら true を返します。
//
// 実装(アルゴリズム):
// - 長さが一致する場合のみ、バイト単位で比較します。
//
// 注意(重要):
// - 大文字小文字などの正規化は行いません。
//
// 計算量:
// - O(n)
//: str_eq: 関数の概要
//:
//: [目的/もくてき]:
//: - str_eq が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_eq <(str,str)->bool> (a,b):
    let la <i32> load_i32 a;
    let lb <i32> load_i32 b;
    if:
        eq la lb
        then str_eq_loop a b la 0
        else false

// str_eq_loop: 文字列比較の内部ループ
//
// 目的:
// - 先頭から len までを比較します。
//
// 実装(アルゴリズム):
// - インデックス i を進めながら 1 バイトずつ比較します。
//
// 注意(重要):
// - 呼び出し側で長さ一致を確認している前提です。
//
// 計算量:
// - O(n)
//: str_eq_loop: 関数の概要
//:
//: [目的/もくてき]:
//: - str_eq_loop が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_eq_loop <(str,str,i32,i32)->bool> (a,b,len,i):
    if:
        eq i len
        then:
            true
        else:
            let ba <i32> load_u8 add a add 4 i;
            let bb <i32> load_u8 add b add 4 i;
            if:
                eq ba bb
                then str_eq_loop a b len add i 1
                else false

// str_is_space: ASCII 空白文字か判定する
//
// 目的:
// - 空白文字（スペース/タブ/改行/CR）かどうかを返します。
//
// 実装(アルゴリズム):
// - 候補バイト値を if で順に比較します。
//
// 注意(重要):
// - UTF-8 の空白全般は扱いません（ASCII のみ）。
//
// 計算量:
// - O(1)
//: str_is_space: 関数の概要
//:
//: [目的/もくてき]:
//: - str_is_space が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_is_space <(i32)->bool> (b):
    if:
        eq b 32
        then true
        else:
            if:
                eq b 9
                then true
                else:
                    if:
                        eq b 10
                        then true
                        else:
                            if:
                                eq b 13
                                then true
                                else false

// str_starts_with: 先頭一致を判定する
//
// 目的:
// - s が prefix で始まるなら true を返します。
//
// 実装(アルゴリズム):
// - prefix の長さを確認し、前方 len バイトを比較します。
//
// 注意(重要):
// - UTF-8 のバイト列として比較します。
//
// 計算量:
// - O(n)
//: str_starts_with: 関数の概要
//:
//: [目的/もくてき]:
//: - str_starts_with が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_starts_with <(str,str)->bool> (s, prefix):
    let ls <i32> load_i32 s;
    let lp <i32> load_i32 prefix;
    if:
        lt ls lp
        then false
        else str_eq_loop s prefix lp 0

// str_eq_at: 指定位置からの一致判定
//
// 目的:
// - s の start 位置から len バイトが pat と一致するか返します。
//
// 実装(アルゴリズム):
// - インデックスを進めながら 1 バイトずつ比較します。
//
// 注意(重要):
// - 呼び出し側で範囲内であることを保証してください。
//
// 計算量:
// - O(n)
//: str_eq_at: 関数の概要
//:
//: [目的/もくてき]:
//: - str_eq_at が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_eq_at <(str,str,i32,i32,i32)->bool> (s, pat, start, len, i):
    if:
        eq i len
        then true
        else:
            let bs <i32> load_u8 add s add 4 add start i;
            let bp <i32> load_u8 add pat add 4 i;
            if:
                eq bs bp
                then str_eq_at s pat start len add i 1
                else false

// str_ends_with: 末尾一致を判定する
//
// 目的:
// - s が suffix で終わるなら true を返します。
//
// 実装(アルゴリズム):
// - s の末尾から長さ分を比較します。
//
// 注意(重要):
// - UTF-8 のバイト列として比較します。
//
// 計算量:
// - O(n)
//: str_ends_with: 関数の概要
//:
//: [目的/もくてき]:
//: - str_ends_with が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_ends_with <(str,str)->bool> (s, suffix):
    let ls <i32> load_i32 s;
    let lp <i32> load_i32 suffix;
    if:
        lt ls lp
        then false
        else:
            let start <i32> sub ls lp;
            str_eq_at s suffix start lp 0

// str_slice: 部分文字列を切り出す
//
// 目的:
// - [start, end) の範囲を新しい文字列として返します。
//
// 実装(アルゴリズム):
// - start/end を範囲内に収め、該当バイトをコピーします。
//
// 注意(重要):
// - start/end はバイト位置です（UTF-8 の文字境界は考慮しません）。
// - 範囲外は 0..len に丸めます。
//
// 計算量:
// - O(n)
//: str_slice: 関数の概要
//:
//: [目的/もくてき]:
//: - str_slice が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_slice <(str,i32,i32)*>str> (s, start, end):
    let len <i32> load_i32 s;
    let mut s0 <i32> start;
    let mut e0 <i32> end;
    if:
        lt s0 0
        then set s0 0
        else ()
    if:
        lt e0 s0
        then set e0 s0
        else ()
    if:
        lt len e0
        then set e0 len
        else ()
    let out_len <i32> sub e0 s0;
    let out <i32> alloc add 4 out_len;
    store_i32 out out_len;
    let mut i <i32> 0;
    while lt i out_len:
        do:
            let b <i32> load_u8 add s add 4 add s0 i;
            store_u8 add out add 4 i b;
            set i add i 1;
    out

// str_trim: 前後の空白を取り除く
//
// 目的:
// - 先頭と末尾の ASCII 空白を除去した文字列を返します。
//
// 実装(アルゴリズム):
// - 先頭から空白を飛ばし、末尾から空白を削ります。
// - 最後に str_slice で切り出します。
//
// 注意(重要):
// - 空白判定は ASCII のみです。
// - UTF-8 の文字境界は考慮しません。
//
// 計算量:
// - O(n)
//: str_trim: 関数の概要
//:
//: [目的/もくてき]:
//: - str_trim が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_trim <(str)*>str> (s):
    let len <i32> load_i32 s;
    let mut start <i32> 0;
    let mut end <i32> len;
    let mut done <i32> 0;
    while eq done 0:
        do:
            if:
                lt start end
                then:
                    let b <i32> load_u8 add s add 4 start;
                    if:
                        str_is_space b
                        then set start add start 1
                        else set done 1
                else:
                    set done 1
    let mut done2 <i32> 0;
    while eq done2 0:
        do:
            if:
                lt start end
                then:
                    let idx <i32> sub end 1;
                    let b <i32> load_u8 add s add 4 idx;
                    if:
                        str_is_space b
                        then set end sub end 1
                        else set done2 1
                else:
                    set done2 1
    str_slice s start end

// str_match_at: 位置一致を判定する（split 用）
//
// 目的:
// - s の pos から sep が一致するかを返します。
//
// 実装(アルゴリズム):
// - sep_len 文字分を順に比較します。
//
// 注意(重要):
// - 呼び出し側で pos+sep_len が範囲内であることを保証してください。
//
// 計算量:
// - O(n)
//: str_match_at: 関数の概要
//:
//: [目的/もくてき]:
//: - str_match_at が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_match_at <(str,str,i32,i32)*>bool> (s, sep, pos, sep_len):
    let mut i <i32> 0;
    let mut ok <i32> 1;
    while lt i sep_len:
        do:
            let bs <i32> load_u8 add s add 4 add pos i;
            let bp <i32> load_u8 add sep add 4 i;
            if:
                eq bs bp
                then set i add i 1
                else:
                    set ok 0
                    set i sep_len
    eq ok 1

// str_split: 区切り文字で分割する
//
// 目的:
// - s を sep で分割し、部分文字列の Vec を返します。
//
// 実装(アルゴリズム):
// - 走査しながら sep 一致位置で区切り、str_slice を積み上げます。
//
// 注意(重要):
// - sep が空文字列の場合は s だけを返します。
// - UTF-8 の文字境界は考慮しません。
//
// 計算量:
// - O(n * m)（n=文字列長, m=sep長）
//: str_split: 関数の概要
//:
//: [目的/もくてき]:
//: - str_split が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_split <(str,str)*>Vec<str>> (s, sep):
    let sep_len <i32> load_i32 sep;
    let mut out <Vec<str>> vec_new<str>;
    if:
        eq sep_len 0
        then:
            set out vec_push<str> out s
            out
        else:
            let s_len <i32> load_i32 s;
            let mut i <i32> 0;
            let mut start <i32> 0;
            while le add i sep_len s_len:
                do:
                    if:
                        str_match_at s sep i sep_len
                        then:
                            let part <str> str_slice s start i;
                            set out vec_push<str> out part;
                            set i add i sep_len;
                            set start i;
                        else:
                            set i add i 1;
            let tail <str> str_slice s start s_len;
            set out vec_push<str> out tail;
            out

// from_i32: i32 を文字列へ変換する
//
// 目的:
// - 非負の i32 を 10 進文字列に変換します。
//
// 実装(アルゴリズム):
// - 10 で割った余りを逆順に保存し、最後に反転して出力します。
//
// 注意(重要):
// - 負数は未対応のため "0" を返します（暫定動作）。
//
// 計算量:
// - O(d)  (d は桁数)
//: from_i32: 関数の概要
//:
//: [目的/もくてき]:
//: - from_i32 が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn from_i32 <(i32)*>str> (x):
    if:
        eq x 0
        then:
            let out0 <i32> alloc 5;
            store_i32 out0 1;
            store_u8 add out0 4 48;    // '0'
            out0
        else:
            if:
                cond:
                    lt x 0
                then:
                    let outn <i32> alloc 5;
                    store_i32 outn 1;
                    store_u8 add outn 4 48;
                    outn
                else:
                    let scratch <i32> alloc 16;
                    let mut idx <i32> 0;
                    let mut n <i32> x;

                    while lt 0 n:
                        do:
                            let rem <i32> mod_s n 10;
                            store_u8 add scratch idx add 48 rem;
                            set idx add idx 1;
                            set n div_s n 10;

                    let out <i32> alloc add 4 idx;
                    store_i32 out idx;

                    let mut i <i32> 0;
                    while lt i idx:
                        do:
                            let rev <i32> sub idx add i 1;
                            let b <i32> load_u8 add scratch rev;
                            store_u8 add out add 4 i b;
                            set i add i 1;

                    out

// to_i32: 文字列を i32 に変換する
//
// 目的:
// - 非負の 10 進文字列を i32 に変換します。
//
// 実装(アルゴリズム):
// - 1 バイトずつ読み取り、数値化して累積します。
// - 不正な文字があれば Err を返します。
//
// 注意(重要):
// - 符号やオーバーフローの厳密な検証は未対応です。
//
// 計算量:
// - O(n)
//: to_i32: 関数の概要
//:
//: [目的/もくてき]:
//: - to_i32 が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn to_i32 <(str)*>Result<i32,i32>> (s):
    let n <i32> load_i32 s;
    let mut i <i32> 0;
    let mut res <i32> 0;
    let mut ok <i32> 1;

    if:
        cond:
            eq n 0
        then:
            set ok 0;
        else:
            let first <i32> load_u8 add s 4;
            if:
                cond:
                    eq first 45
                then:
                    set ok 0;
                else:
                    while lt i n:
                        do:
                            let b <i32> load_u8 add s add 4 i;
                            let digit <i32> sub b 48;

                            if:
                                cond:
                                    lt digit 0
                                then:
                                    set ok 0;
                                    set i n;
                                else:
                                    if:
                                        cond:
                                            le digit 9
                                        then:
                                            set res add mul res 10 digit;
                                            set i add i 1;
                                        else:
                                            set ok 0;
                                            set i n;

    if:
        cond:
            eq ok 1
        then:
            Result::Ok<i32,i32> res
        else:
            Result::Err<i32,i32> 1

//: cast: 関数の概要
//:
//: [目的/もくてき]:
//: - cast が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
//: from_i64: 関数の概要
//:
//: [目的/もくてき]:
//: - from_i64 が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn from_i64 <(i64)*>str> (x):
    if:
        i64_eq x i64_extend_i32_u 0
        then:
            let out0 <i32> alloc 5;
            store_i32 out0 1;
            store_u8 add out0 4 48;
            out0
        else:
            let scratch <i32> alloc 32;
            let mut idx <i32> 0;
            let mut n <i64> x;
            let ten <i64> i64_extend_i32_u 10;
            while i64_ne n i64_extend_i32_u 0:
                do:
                    let mut rem <i64> i64_rem_s n ten;
                    if:
                        i64_lt_s rem i64_extend_i32_u 0
                        then:
                            set rem i64_sub i64_extend_i32_u 0 rem;
                        else:
                            ();
                    let d <i32> i32_wrap_i64 rem;
                    store_u8 add scratch idx add 48 d;
                    set idx add idx 1;
                    set n i64_div_s n ten;

            let neg <bool> i64_lt_s x i64_extend_i32_u 0;
            let out_len <i32> if neg add idx 1 idx;
            let out <i32> alloc add 4 out_len;
            store_i32 out out_len;

            let mut dst <i32> 0;
            if:
                neg
                then:
                    store_u8 add out 4 45;
                    set dst 1;
                else:
                    ();

            let mut i <i32> 0;
            while lt i idx:
                do:
                    let rev <i32> sub idx add i 1;
                    let b <i32> load_u8 add scratch rev;
                    store_u8 add out add 4 add dst i b;
                    set i add i 1;

            out

//: cast: 関数の概要
//:
//: [目的/もくてき]:
//: - cast が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
//: to_i64: 関数の概要
//:
//: [目的/もくてき]:
//: - to_i64 が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn to_i64 <(str)*>Result<i64,i32>> (s):
    let n <i32> load_i32 s;
    let mut i <i32> 0;
    let mut res <i64> i64_extend_i32_u 0;
    let mut ok <i32> 1;
    let mut neg <i32> 0;
    let ten <i64> i64_extend_i32_u 10;

    if:
        eq n 0
        then:
            set ok 0;
        else:
            let first <i32> load_u8 add s 4;
            if:
                eq first 45
                then:
                    set neg 1;
                    set i 1;
                else:
                    ();
            if:
                ge i n
                then:
                    set ok 0;
                else:
                    while lt i n:
                        do:
                            let b <i32> load_u8 add s add 4 i;
                            let digit <i32> sub b 48;
                            if:
                                or lt digit 0 gt digit 9
                                then:
                                    set ok 0;
                                    set i n;
                                else:
                                    let d64 <i64> i64_extend_i32_u digit;
                                    if:
                                        eq neg 1
                                        then:
                                            set res i64_sub i64_mul res ten d64;
                                        else:
                                            set res i64_add i64_mul res ten d64;
                                    set i add i 1;

    if:
        eq ok 1
        then:
            Result::Ok<i64,i32> res
        else:
            Result::Err<i64,i32> 1

//: cast: 関数の概要
//:
//: [目的/もくてき]:
//: - cast が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
//: from_f64: 関数の概要
//:
//: [目的/もくてき]:
//: - from_f64 が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn from_f64 <(f64)*>str> (x):
    if:
        f64_ne x x
        then:
            "nan"
        else:
            let neg <bool> f64_lt x f64_convert_i32_s 0;
            let absx <f64> if neg f64_neg x x;
            let int_part <i64> i64_trunc_f64_s absx;
            let int_f <f64> f64_convert_i64_s int_part;
            let mut frac <f64> f64_sub absx int_f;
            let int_s <str> from_i64 int_part;
            let mut sb <StringBuilder> string_builder_new;
            if:
                neg
                then:
                    set sb sb_append sb "-";
                else:
                    ();
            set sb sb_append sb int_s;

            let scratch <i32> alloc 6;
            let mut k <i32> 0;
            while lt k 6:
                do:
                    set frac f64_mul frac f64_convert_i32_s 10;
                    let d <i32> i32_trunc_f64_s frac;
                    store_u8 add scratch k add 48 d;
                    set frac f64_sub frac f64_convert_i32_s d;
                    set k add k 1;

            let mut trim <i32> 6;
            let mut done_trim <i32> 0;
            while and eq done_trim 0 lt 0 trim:
                do:
                    let b <i32> load_u8 add scratch sub trim 1;
                    if:
                        eq b 48
                        then:
                            set trim sub trim 1;
                        else:
                            set done_trim 1;

            if:
                gt trim 0
                then:
                    let frac_s <i32> alloc add 4 trim;
                    store_i32 frac_s trim;
                    let mut i <i32> 0;
                    while lt i trim:
                        do:
                            store_u8 add frac_s add 4 i load_u8 add scratch i;
                            set i add i 1;
                    set sb sb_append sb ".";
                    set sb sb_append sb frac_s;
                else:
                    ();

            sb_build sb

//: cast: 関数の概要
//:
//: [目的/もくてき]:
//: - cast が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
//: to_f64: 関数の概要
//:
//: [目的/もくてき]:
//: - to_f64 が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn to_f64 <(str)*>Result<f64,i32>> (s):
    let n <i32> load_i32 s;
    let mut i <i32> 0;
    let mut ok <i32> 1;
    let mut neg <i32> 0;
    let mut int_part <f64> f64_convert_i32_s 0;
    let mut frac_part <f64> f64_convert_i32_s 0;
    let mut frac_scale <f64> f64_convert_i32_s 1;
    let mut has_digit <i32> 0;
    let ten <f64> f64_convert_i32_s 10;
    let mut out_res <Result<f64,i32>> Result::Err<f64,i32> 1;

    if:
        eq n 0
        then:
            set ok 0;
        else:
            let first <i32> load_u8 add s 4;
            if:
                eq first 45
                then:
                    set neg 1;
                    set i 1;
                else:
                    if:
                        eq first 43
                        then:
                            set i 1;
                        else:
                            ();

            while and eq ok 1 lt i n:
                do:
                    let b <i32> load_u8 add s add 4 i;
                    let d <i32> sub b 48;
                    if:
                        and ge d 0 le d 9
                        then:
                            set has_digit 1;
                            let scaled <f64> f64_mul int_part ten;
                            let dv <f64> f64_convert_i32_s d;
                            let next_int <f64> f64_add scaled dv;
                            set int_part next_int;
                            set i add i 1;
                        else:
                            set ok 2;

            if:
                and eq ok 2 lt i n
                then:
                    let dot <i32> load_u8 add s add 4 i;
                    if:
                        eq dot 46
                        then:
                            set ok 1;
                            set i add i 1;
                            while and eq ok 1 lt i n:
                                do:
                                    let b <i32> load_u8 add s add 4 i;
                                    let d <i32> sub b 48;
                                    if:
                                        and ge d 0 le d 9
                                        then:
                                            set has_digit 1;
                                            let next_scale <f64> f64_div frac_scale ten;
                                            set frac_scale next_scale;
                                            let dv <f64> f64_convert_i32_s d;
                                            let addv <f64> f64_mul dv frac_scale;
                                            let next_frac <f64> f64_add frac_part addv;
                                            set frac_part next_frac;
                                            set i add i 1;
                                        else:
                                            set ok 2;
                        else:
                            set ok 0;
                else:
                    ();

            let mut exp_val <i32> 0;
            let mut exp_neg <i32> 0;
            if:
                and eq ok 2 lt i n
                then:
                    let eb <i32> load_u8 add s add 4 i;
                    if:
                        or eq eb 101 eq eb 69
                        then:
                            set i add i 1;
                            if:
                                lt i n
                                then:
                                    let sb <i32> load_u8 add s add 4 i;
                                    if:
                                        eq sb 45
                                        then:
                                            set exp_neg 1;
                                            set i add i 1;
                                        else:
                                            if:
                                                eq sb 43
                                                then:
                                                    set i add i 1;
                                                else:
                                                    ();
                                else:
                                    set ok 0;

                            let mut exp_digits <i32> 0;
                            while and eq ok 2 lt i n:
                                do:
                                    let b <i32> load_u8 add s add 4 i;
                                    let d <i32> sub b 48;
                                    if:
                                        and ge d 0 le d 9
                                        then:
                                            set exp_digits 1;
                                            set exp_val add mul exp_val 10 d;
                                            set i add i 1;
                                        else:
                                            set ok 0;
                            if:
                                eq exp_digits 0
                                then:
                                    set ok 0;
                                else:
                                    ();
                        else:
                            ();
                else:
                    ();

            if:
                ne i n
                then:
                    set ok 0;
                else:
                    ();

            if:
                eq has_digit 0
                then:
                    set ok 0;
                else:
                    ();

            let mut out <f64> f64_add int_part frac_part;
            let mut k <i32> 0;
            while and eq ok 2 lt k exp_val:
                do:
                    if:
                        eq exp_neg 1
                        then:
                            let next_out <f64> f64_div out ten;
                            set out next_out;
                        else:
                            let next_out <f64> f64_mul out ten;
                            set out next_out;
                    set k add k 1;

            if:
                eq ok 2
                then:
                    if:
                        eq neg 1
                        then:
                            let signed_out <f64> f64_neg out;
                            set out_res Result::Ok<f64,i32> signed_out;
                        else:
                            set out_res Result::Ok<f64,i32> out;
                else:
                    set out_res Result::Err<f64,i32> 1;

    out_res

//: cast: 関数の概要
//:
//: [目的/もくてき]:
//: - cast が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
//: from_f32: 関数の概要
//:
//: [目的/もくてき]:
//: - from_f32 が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn from_f32 <(f32)*>str> (x):
    from_f64 f64_promote_f32 x

//: cast: 関数の概要
//:
//: [目的/もくてき]:
//: - cast が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
//: to_f32: 関数の概要
//:
//: [目的/もくてき]:
//: - to_f32 が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn to_f32 <(str)*>Result<f32,i32>> (s):
    match to_f64 s:
        Result::Ok v64:
            Result::Ok<f32,i32> f32_demote_f64 v64
        Result::Err e:
            Result::Err<f32,i32> e

// find: 部分文字列検索（未実装）
//
// 目的:
// - s 内で pat が見つかれば位置を返します。
//
// 実装(アルゴリズム):
// - 現在は未実装のため None を返します。
//
// 注意(重要):
// - 本関数は常に None を返します。
//
// 計算量:
// - O(1)（未実装）
//: find: 関数の概要
//:
//: [目的/もくてき]:
//: - find が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn find <(str,str)*>Option<i32>> (_s, _pat):
    Option::None<i32>
