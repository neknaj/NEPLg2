//: string: alloc/string.nepl に関する機能を提供するライブラリ
//:
//: [目的/もくてき]:
//: - このモジュールの公開 API を提供します。
//: - 実装の変更時に最小限の doctest 実行経路を維持します。
//:
//: [注意/ちゅうい]:
//: - 詳細な関数別ドキュメントは段階的に追記します。
//:
//: neplg2:test[skip]
//: ```neplg2
//:| #entry main
//:| #target wasi
//: ()
//: ```

#indent 4

#import "core/mem" as *
#import "core/result" as *
#import "core/option" as *
#import "core/math" as *
#import "alloc/vec" as *
#import "core/field" as *

// string: 文字列操作（長さ付きUTF-8）
//
// 目的:
// - [len:i32][bytes...] 形式の UTF-8 文字列を扱う関数群を提供します。
//
// 実装(アルゴリズム):
// - 文字列はヒープに確保し、先頭 4 バイトに長さを格納します。
//
// 注意(重要):
// - 文字列は NUL 終端ではありません。
// - 現状の from_i32/to_i32 は非負の整数のみをサポートします。
//
// 計算量:
// - 連結や変換は O(n)

// len: 文字列の長さを返す
//
// 目的:
// - 文字列のバイト長を返します。
//
// 実装(アルゴリズム):
// - 先頭 4 バイトの長さを読み出します。
//
// 注意(重要):
// - UTF-8 のバイト長であり、文字数とは一致しません。
//
// 計算量:
// - O(1)
//: len: 関数の概要
//:
//: [目的/もくてき]:
//: - len が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn len <(str)->i32> (s):
    load_i32 s

// concat: 2つの文字列を連結する
//
// 目的:
// - a と b を連結した新しい文字列を返します。
//
// 実装(アルゴリズム):
// - 長さを計算し、新領域を確保して順にコピーします。
//
// 注意(重要):
// - 新しいバッファを確保するため O(n) のコストがかかります。
//
// 計算量:
// - O(la + lb)
//: concat: 関数の概要
//:
//: [目的/もくてき]:
//: - concat が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn concat <(str,str)*>str> (a,b):
    let la <i32> load_i32 a;
    let lb <i32> load_i32 b;
    let total <i32> add la lb;
    let out <i32> alloc add 4 total;
    store_i32 out total;
    let mut i <i32> 0;
    while lt i la:
        do:
            let ch <i32> load_u8 add a add 4 i;
            store_u8 add out add 4 i ch;
            set i add i 1;
    let mut j <i32> 0;
    while lt j lb:
        do:
            let ch <i32> load_u8 add b add 4 j;
            store_u8 add out add 4 add la j ch;
            set j add j 1;
    out

// concat3: 3つの文字列を連結する
//
// 目的:
// - a,b,c を連結した文字列を返します。
//
// 実装(アルゴリズム):
// - concat を 2 回呼び出します。
//
// 注意(重要):
// - 中間文字列を確保するため余分なコストが発生します。
//
// 計算量:
// - O(la + lb + lc)
//: concat3: 関数の概要
//:
//: [目的/もくてき]:
//: - concat3 が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn concat3 <(str,str,str)*>str> (a,b,c):
    let ab <str> concat a b;
    concat ab c

// StringBuilder: 文字列ビルダ
//
// 目的:
// - 複数の文字列を段階的に追加し、最後に 1 つへまとめます。
//
// 実装(アルゴリズム):
// - Vec<str> に部分文字列を保持します。
//
// 注意(重要):
// - sb_build は concat を繰り返すため O(n^2) になり得ます。
//
// 計算量:
// - 追加: ならし O(1)
// - build: O(n^2)
//: StringBuilder: 構造体の概要
//:
//: [目的/もくてき]:
//: - StringBuilder が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 定義そのものは O(1) です。
struct StringBuilder:
    parts <Vec<str>>

// string_builder_new: 空のビルダを作る
//
// 目的:
// - 空の StringBuilder を返します。
//
// 実装(アルゴリズム):
// - vec_new で Vec<str> を作ります。
//
// 注意(重要):
// - 初期容量は Vec の既定値に従います。
//
// 計算量:
// - O(1)
//: string_builder_new: 関数の概要
//:
//: [目的/もくてき]:
//: - string_builder_new が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn string_builder_new <()*>StringBuilder> ():
    StringBuilder vec_new<str>

// sb_append: 文字列を追加する
//
// 目的:
// - s をビルダに追加して返します。
//
// 実装(アルゴリズム):
// - 内部 Vec に push します。
//
// 注意(重要):
// - 返り値の StringBuilder を受け取り直してください。
//
// 計算量:
// - ならし O(1)
//: sb_append: 関数の概要
//:
//: [目的/もくてき]:
//: - sb_append が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sb_append <(StringBuilder,str)*>StringBuilder> (sb, s):
    let parts <Vec<str>> get sb "parts";
    let parts2 <Vec<str>> vec_push<str> parts s;
    StringBuilder parts2

// sb_append_i32: i32 を追加する
//
// 目的:
// - v を文字列化して追加します。
//
// 実装(アルゴリズム):
// - from_i32 を呼び、sb_append に渡します。
//
// 注意(重要):
// - 負数は from_i32 の制約に従います。
//
// 計算量:
// - O(d)
//: sb_append_i32: 関数の概要
//:
//: [目的/もくてき]:
//: - sb_append_i32 が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sb_append_i32 <(StringBuilder,i32)*>StringBuilder> (sb, v):
    let s <str> from_i32 v;
    sb_append sb s

// sb_build: 文字列を生成する
//
// 目的:
// - 追加された部分文字列を 1 つに連結して返します。
//
// 実装(アルゴリズム):
// - まず全パーツ長を合計して 1 回だけ領域を確保します。
// - 次に各パーツのバイト列を確保済み領域へ順にコピーします。
//
// 注意(重要):
// - 返り値は新規確保された文字列です。
//
// 計算量:
// - O(total_bytes + part_count)
//: sb_build: 関数の概要
//:
//: [目的/もくてき]:
//: - sb_build が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn sb_build <(StringBuilder)*>str> (sb):
    let parts_vec <Vec<str>> get sb "parts";
    let n <i32> get parts_vec "len";
    let parts_data <i32> get parts_vec "data";
    let mut total <i32> 0;
    let mut idx0 <i32> 0;
    while lt idx0 n:
        do:
            let part <str> load<str> add parts_data mul idx0 size_of<str>;
            set total add total load_i32 part;
            set idx0 add idx0 1;
    let out <i32> alloc add 4 total;
    store_i32 out total;
    let mut idx <i32> 0;
    let mut dst <i32> 0;
    while lt idx n:
        do:
            let part <str> load<str> add parts_data mul idx size_of<str>;
            let plen <i32> load_i32 part;
            let mut i <i32> 0;
            while lt i plen:
                do:
                    let ch <i32> load_u8 add part add 4 i;
                    store_u8 add out add 4 add dst i ch;
                    set i add i 1;
            set dst add dst plen;
            set idx add idx 1;
    out

// str_eq: 文字列が等しいか判定する
//
// 目的:
// - a と b の内容が同じなら true を返します。
//
// 実装(アルゴリズム):
// - 長さが一致する場合のみ、バイト単位で比較します。
//
// 注意(重要):
// - 大文字小文字などの正規化は行いません。
//
// 計算量:
// - O(n)
//: str_eq: 関数の概要
//:
//: [目的/もくてき]:
//: - str_eq が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_eq <(str,str)->bool> (a,b):
    let la <i32> load_i32 a;
    let lb <i32> load_i32 b;
    if:
        eq la lb
        then str_eq_loop a b la 0
        else false

// str_eq_loop: 文字列比較の内部ループ
//
// 目的:
// - 先頭から len までを比較します。
//
// 実装(アルゴリズム):
// - インデックス i を進めながら 1 バイトずつ比較します。
//
// 注意(重要):
// - 呼び出し側で長さ一致を確認している前提です。
//
// 計算量:
// - O(n)
//: str_eq_loop: 関数の概要
//:
//: [目的/もくてき]:
//: - str_eq_loop が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_eq_loop <(str,str,i32,i32)->bool> (a,b,len,i):
    if:
        eq i len
        then:
            true
        else:
            let ba <i32> load_u8 add a add 4 i;
            let bb <i32> load_u8 add b add 4 i;
            if:
                eq ba bb
                then str_eq_loop a b len add i 1
                else false

// str_is_space: ASCII 空白文字か判定する
//
// 目的:
// - 空白文字（スペース/タブ/改行/CR）かどうかを返します。
//
// 実装(アルゴリズム):
// - 候補バイト値を if で順に比較します。
//
// 注意(重要):
// - UTF-8 の空白全般は扱いません（ASCII のみ）。
//
// 計算量:
// - O(1)
//: str_is_space: 関数の概要
//:
//: [目的/もくてき]:
//: - str_is_space が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_is_space <(i32)->bool> (b):
    if:
        eq b 32
        then true
        else:
            if:
                eq b 9
                then true
                else:
                    if:
                        eq b 10
                        then true
                        else:
                            if:
                                eq b 13
                                then true
                                else false

// str_starts_with: 先頭一致を判定する
//
// 目的:
// - s が prefix で始まるなら true を返します。
//
// 実装(アルゴリズム):
// - prefix の長さを確認し、前方 len バイトを比較します。
//
// 注意(重要):
// - UTF-8 のバイト列として比較します。
//
// 計算量:
// - O(n)
//: str_starts_with: 関数の概要
//:
//: [目的/もくてき]:
//: - str_starts_with が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_starts_with <(str,str)->bool> (s, prefix):
    let ls <i32> load_i32 s;
    let lp <i32> load_i32 prefix;
    if:
        lt ls lp
        then false
        else str_eq_loop s prefix lp 0

// str_eq_at: 指定位置からの一致判定
//
// 目的:
// - s の start 位置から len バイトが pat と一致するか返します。
//
// 実装(アルゴリズム):
// - インデックスを進めながら 1 バイトずつ比較します。
//
// 注意(重要):
// - 呼び出し側で範囲内であることを保証してください。
//
// 計算量:
// - O(n)
//: str_eq_at: 関数の概要
//:
//: [目的/もくてき]:
//: - str_eq_at が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_eq_at <(str,str,i32,i32,i32)->bool> (s, pat, start, len, i):
    if:
        eq i len
        then true
        else:
            let bs <i32> load_u8 add s add 4 add start i;
            let bp <i32> load_u8 add pat add 4 i;
            if:
                eq bs bp
                then str_eq_at s pat start len add i 1
                else false

// str_ends_with: 末尾一致を判定する
//
// 目的:
// - s が suffix で終わるなら true を返します。
//
// 実装(アルゴリズム):
// - s の末尾から長さ分を比較します。
//
// 注意(重要):
// - UTF-8 のバイト列として比較します。
//
// 計算量:
// - O(n)
//: str_ends_with: 関数の概要
//:
//: [目的/もくてき]:
//: - str_ends_with が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_ends_with <(str,str)->bool> (s, suffix):
    let ls <i32> load_i32 s;
    let lp <i32> load_i32 suffix;
    if:
        lt ls lp
        then false
        else:
            let start <i32> sub ls lp;
            str_eq_at s suffix start lp 0

// str_slice: 部分文字列を切り出す
//
// 目的:
// - [start, end) の範囲を新しい文字列として返します。
//
// 実装(アルゴリズム):
// - start/end を範囲内に収め、該当バイトをコピーします。
//
// 注意(重要):
// - start/end はバイト位置です（UTF-8 の文字境界は考慮しません）。
// - 範囲外は 0..len に丸めます。
//
// 計算量:
// - O(n)
//: str_slice: 関数の概要
//:
//: [目的/もくてき]:
//: - str_slice が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_slice <(str,i32,i32)*>str> (s, start, end):
    let len <i32> load_i32 s;
    let mut s0 <i32> start;
    let mut e0 <i32> end;
    if:
        lt s0 0
        then set s0 0
        else ()
    if:
        lt e0 s0
        then set e0 s0
        else ()
    if:
        lt len e0
        then set e0 len
        else ()
    let out_len <i32> sub e0 s0;
    let out <i32> alloc add 4 out_len;
    store_i32 out out_len;
    let mut i <i32> 0;
    while lt i out_len:
        do:
            let b <i32> load_u8 add s add 4 add s0 i;
            store_u8 add out add 4 i b;
            set i add i 1;
    out

// str_trim: 前後の空白を取り除く
//
// 目的:
// - 先頭と末尾の ASCII 空白を除去した文字列を返します。
//
// 実装(アルゴリズム):
// - 先頭から空白を飛ばし、末尾から空白を削ります。
// - 最後に str_slice で切り出します。
//
// 注意(重要):
// - 空白判定は ASCII のみです。
// - UTF-8 の文字境界は考慮しません。
//
// 計算量:
// - O(n)
//: str_trim: 関数の概要
//:
//: [目的/もくてき]:
//: - str_trim が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_trim <(str)*>str> (s):
    let len <i32> load_i32 s;
    let mut start <i32> 0;
    let mut end <i32> len;
    let mut done <i32> 0;
    while eq done 0:
        do:
            if:
                lt start end
                then:
                    let b <i32> load_u8 add s add 4 start;
                    if:
                        str_is_space b
                        then set start add start 1
                        else set done 1
                else:
                    set done 1
    let mut done2 <i32> 0;
    while eq done2 0:
        do:
            if:
                lt start end
                then:
                    let idx <i32> sub end 1;
                    let b <i32> load_u8 add s add 4 idx;
                    if:
                        str_is_space b
                        then set end sub end 1
                        else set done2 1
                else:
                    set done2 1
    str_slice s start end

// str_match_at: 位置一致を判定する（split 用）
//
// 目的:
// - s の pos から sep が一致するかを返します。
//
// 実装(アルゴリズム):
// - sep_len 文字分を順に比較します。
//
// 注意(重要):
// - 呼び出し側で pos+sep_len が範囲内であることを保証してください。
//
// 計算量:
// - O(n)
//: str_match_at: 関数の概要
//:
//: [目的/もくてき]:
//: - str_match_at が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_match_at <(str,str,i32,i32)*>bool> (s, sep, pos, sep_len):
    let mut i <i32> 0;
    let mut ok <i32> 1;
    while lt i sep_len:
        do:
            let bs <i32> load_u8 add s add 4 add pos i;
            let bp <i32> load_u8 add sep add 4 i;
            if:
                eq bs bp
                then set i add i 1
                else:
                    set ok 0
                    set i sep_len
    eq ok 1

// str_split: 区切り文字で分割する
//
// 目的:
// - s を sep で分割し、部分文字列の Vec を返します。
//
// 実装(アルゴリズム):
// - 走査しながら sep 一致位置で区切り、str_slice を積み上げます。
//
// 注意(重要):
// - sep が空文字列の場合は s だけを返します。
// - UTF-8 の文字境界は考慮しません。
//
// 計算量:
// - O(n * m)（n=文字列長, m=sep長）
//: str_split: 関数の概要
//:
//: [目的/もくてき]:
//: - str_split が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn str_split <(str,str)*>Vec<str>> (s, sep):
    let sep_len <i32> load_i32 sep;
    let mut out <Vec<str>> vec_new<str>;
    if:
        eq sep_len 0
        then:
            set out vec_push<str> out s
            out
        else:
            let s_len <i32> load_i32 s;
            let mut i <i32> 0;
            let mut start <i32> 0;
            while le add i sep_len s_len:
                do:
                    if:
                        str_match_at s sep i sep_len
                        then:
                            let part <str> str_slice s start i;
                            set out vec_push<str> out part;
                            set i add i sep_len;
                            set start i;
                        else:
                            set i add i 1;
            let tail <str> str_slice s start s_len;
            set out vec_push<str> out tail;
            out

// from_i32: i32 を文字列へ変換する
//
// 目的:
// - 非負の i32 を 10 進文字列に変換します。
//
// 実装(アルゴリズム):
// - 10 で割った余りを逆順に保存し、最後に反転して出力します。
//
// 注意(重要):
// - 負数は未対応のため "0" を返します（暫定動作）。
//
// 計算量:
// - O(d)  (d は桁数)
//: cast: 関数の概要
//:
//: [目的/もくてき]:
//: - cast が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn cast from_i32;
//: from_i32: 関数の概要
//:
//: [目的/もくてき]:
//: - from_i32 が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn from_i32 <(i32)*>str> (x):
    if:
        eq x 0
        then:
            let out0 <i32> alloc 5;
            store_i32 out0 1;
            store_u8 add out0 4 48;    // '0'
            out0
        else:
            if:
                cond:
                    lt x 0
                then:
                    let outn <i32> alloc 5;
                    store_i32 outn 1;
                    store_u8 add outn 4 48;
                    outn
                else:
                    let scratch <i32> alloc 16;
                    let mut idx <i32> 0;
                    let mut n <i32> x;

                    while lt 0 n:
                        do:
                            let rem <i32> mod_s n 10;
                            store_u8 add scratch idx add 48 rem;
                            set idx add idx 1;
                            set n div_s n 10;

                    let out <i32> alloc add 4 idx;
                    store_i32 out idx;

                    let mut i <i32> 0;
                    while lt i idx:
                        do:
                            let rev <i32> sub idx add i 1;
                            let b <i32> load_u8 add scratch rev;
                            store_u8 add out add 4 i b;
                            set i add i 1;

                    out

// to_i32: 文字列を i32 に変換する
//
// 目的:
// - 非負の 10 進文字列を i32 に変換します。
//
// 実装(アルゴリズム):
// - 1 バイトずつ読み取り、数値化して累積します。
// - 不正な文字があれば Err を返します。
//
// 注意(重要):
// - 符号やオーバーフローの厳密な検証は未対応です。
//
// 計算量:
// - O(n)
//: cast: 関数の概要
//:
//: [目的/もくてき]:
//: - cast が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn cast to_i32;
//: to_i32: 関数の概要
//:
//: [目的/もくてき]:
//: - to_i32 が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn to_i32 <(str)*>Result<i32,i32>> (s):
    let n <i32> load_i32 s;
    let mut i <i32> 0;
    let mut res <i32> 0;
    let mut ok <i32> 1;

    if:
        cond:
            eq n 0
        then:
            set ok 0;
        else:
            let first <i32> load_u8 add s 4;
            if:
                cond:
                    eq first 45
                then:
                    set ok 0;
                else:
                    while lt i n:
                        do:
                            let b <i32> load_u8 add s add 4 i;
                            let digit <i32> sub b 48;

                            if:
                                cond:
                                    lt digit 0
                                then:
                                    set ok 0;
                                    set i n;
                                else:
                                    if:
                                        cond:
                                            le digit 9
                                        then:
                                            set res add mul res 10 digit;
                                            set i add i 1;
                                        else:
                                            set ok 0;
                                            set i n;

    if:
        cond:
            eq ok 1
        then:
            Result::Ok<i32,i32> res
        else:
            Result::Err<i32,i32> 1

// find: 部分文字列検索（未実装）
//
// 目的:
// - s 内で pat が見つかれば位置を返します。
//
// 実装(アルゴリズム):
// - 現在は未実装のため None を返します。
//
// 注意(重要):
// - 本関数は常に None を返します。
//
// 計算量:
// - O(1)（未実装）
//: find: 関数の概要
//:
//: [目的/もくてき]:
//: - find が担う機能を提供します。
//:
//: [実装/じっそう]:
//: - 前置記法・オフサイドルール前提で読みやすく保つ構造です。
//:
//: [注意/ちゅうい]:
//: - 型引数や所有権の制約は呼び出し側で満たしてください。
//:
//: [計算量/けいさんりょう]:
//: - 実装に依存します。
fn find <(str,str)*>Option<i32>> (_s, _pat):
    Option::None<i32>
