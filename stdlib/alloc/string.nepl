#indent 4

#import "core/mem" as *
#import "core/result" as *
#import "core/option" as *
#import "core/math" as *

// string: 文字列操作（長さ付きUTF-8）
//
// 目的:
// - [len:i32][bytes...] 形式の UTF-8 文字列を扱う関数群を提供します。
//
// 実装(アルゴリズム):
// - 文字列はヒープに確保し、先頭 4 バイトに長さを格納します。
//
// 注意(重要):
// - 文字列は NUL 終端ではありません。
// - 現状の from_i32/to_i32 は非負の整数のみをサポートします。
//
// 計算量:
// - 連結や変換は O(n)

// len: 文字列の長さを返す
//
// 目的:
// - 文字列のバイト長を返します。
//
// 実装(アルゴリズム):
// - 先頭 4 バイトの長さを読み出します。
//
// 注意(重要):
// - UTF-8 のバイト長であり、文字数とは一致しません。
//
// 計算量:
// - O(1)
fn len <(str)->i32> (s):
    load_i32 s

// concat: 2つの文字列を連結する
//
// 目的:
// - a と b を連結した新しい文字列を返します。
//
// 実装(アルゴリズム):
// - 長さを計算し、新領域を確保して順にコピーします。
//
// 注意(重要):
// - 新しいバッファを確保するため O(n) のコストがかかります。
//
// 計算量:
// - O(la + lb)
fn concat <(str,str)*>str> (a,b):
    let la <i32> load_i32 a;
    let lb <i32> load_i32 b;
    let total <i32> add la lb;
    let out <i32> alloc add 4 total;
    store_i32 out total;
    let mut i <i32> 0;
    while lt i la:
        let ch <i32> load_u8 add a add 4 i;
        store_u8 add out add 4 i ch;
        set i add i 1;
    let mut j <i32> 0;
    while lt j lb:
        let ch <i32> load_u8 add b add 4 j;
        store_u8 add out add 4 add la j ch;
        set j add j 1;
    out

// concat3: 3つの文字列を連結する
//
// 目的:
// - a,b,c を連結した文字列を返します。
//
// 実装(アルゴリズム):
// - concat を 2 回呼び出します。
//
// 注意(重要):
// - 中間文字列を確保するため余分なコストが発生します。
//
// 計算量:
// - O(la + lb + lc)
fn concat3 <(str,str,str)*>str> (a,b,c):
    let ab <str> concat a b;
    concat ab c

// str_eq: 文字列が等しいか判定する
//
// 目的:
// - a と b の内容が同じなら true を返します。
//
// 実装(アルゴリズム):
// - 長さが一致する場合のみ、バイト単位で比較します。
//
// 注意(重要):
// - 大文字小文字などの正規化は行いません。
//
// 計算量:
// - O(n)
fn str_eq <(str,str)->bool> (a,b):
    let la <i32> load_i32 a;
    let lb <i32> load_i32 b;
    if:
        eq la lb
        then str_eq_loop a b la 0
        else false

// str_eq_loop: 文字列比較の内部ループ
//
// 目的:
// - 先頭から len までを比較します。
//
// 実装(アルゴリズム):
// - インデックス i を進めながら 1 バイトずつ比較します。
//
// 注意(重要):
// - 呼び出し側で長さ一致を確認している前提です。
//
// 計算量:
// - O(n)
fn str_eq_loop <(str,str,i32,i32)->bool> (a,b,len,i):
    if:
        eq i len
        then:
            true
        else:
            let ba <i32> load_u8 add a add 4 i;
            let bb <i32> load_u8 add b add 4 i;
            if:
                eq ba bb
                then str_eq_loop a b len add i 1
                else false

// from_i32: i32 を文字列へ変換する
//
// 目的:
// - 非負の i32 を 10 進文字列に変換します。
//
// 実装(アルゴリズム):
// - 10 で割った余りを逆順に保存し、最後に反転して出力します。
//
// 注意(重要):
// - 負数は未対応のため "0" を返します（暫定動作）。
//
// 計算量:
// - O(d)  (d は桁数)
fn from_i32 <(i32)*>str> (x):
    if:
        eq x 0
        then:
            let out0 <i32> alloc 5;
            store_i32 out0 1;
            store_u8 add out0 4 48;    // '0'
            out0
        else:
            if:
                cond:
                    lt x 0
                then:
                    let outn <i32> alloc 5;
                    store_i32 outn 1;
                    store_u8 add outn 4 48;
                    outn
                else:
                    let scratch <i32> alloc 16;
                    let mut idx <i32> 0;
                    let mut n <i32> x;

                    while lt 0 n:
                        let rem <i32> mod_s n 10;
                        store_u8 add scratch idx add 48 rem;
                        set idx add idx 1;
                        set n div_s n 10;

                    let out <i32> alloc add 4 idx;
                    store_i32 out idx;

                    let mut i <i32> 0;
                    while lt i idx:
                        let rev <i32> sub idx add i 1;
                        let b <i32> load_u8 add scratch rev;
                        store_u8 add out add 4 i b;
                        set i add i 1;

                    out

// to_i32: 文字列を i32 に変換する
//
// 目的:
// - 非負の 10 進文字列を i32 に変換します。
//
// 実装(アルゴリズム):
// - 1 バイトずつ読み取り、数値化して累積します。
// - 不正な文字があれば Err を返します。
//
// 注意(重要):
// - 符号やオーバーフローの厳密な検証は未対応です。
//
// 計算量:
// - O(n)
fn to_i32 <(str)*>Result<i32,i32>> (s):
    let n <i32> load_i32 s;
    let mut i <i32> 0;
    let mut res <i32> 0;
    let mut ok <i32> 1;

    if:
        cond:
            eq n 0
        then:
            set ok 0;
        else:
            let first <i32> load_u8 add s 4;
            if:
                cond:
                    eq first 45
                then:
                    set ok 0;
                else:
                    while lt i n:
                        let b <i32> load_u8 add s add 4 i;
                        let digit <i32> sub b 48;

                        if:
                            cond:
                                lt digit 0
                            then:
                                set ok 0;
                                set i n;
                            else:
                                if:
                                    cond:
                                        le digit 9
                                    then:
                                        set res add mul res 10 digit;
                                        set i add i 1;
                                    else:
                                        set ok 0;
                                        set i n;

    if:
        cond:
            eq ok 1
        then:
            Result::Ok <i32,i32> res
        else:
            Result::Err <i32,i32> 1

// find: 部分文字列検索（未実装）
//
// 目的:
// - s 内で pat が見つかれば位置を返します。
//
// 実装(アルゴリズム):
// - 現在は未実装のため None を返します。
//
// 注意(重要):
// - 本関数は常に None を返します。
//
// 計算量:
// - O(1)（未実装）
fn find <(str,str)*>Option<i32>> (_s, _pat):
    Option::None <i32>
