#indent 4
#target wasi
#import "core/mem" as *
#import "core/math" as *
#import "core/option" as *
#import "std/stdio" as *
#import "alloc/string" as *
#import "alloc/vec" as *
#import "core/field" as *

// kpread: 競技プログラミング用高速スキャナ
//
// 目的:
// - 標準入力を一度に読み込み、空白区切りのトークンを高速にパースします。
// - i32、長さ N の配列、H x W 行列、EOF までの読み込みなどのヘルパーを提供します。
//
// 実装(アルゴリズム):
// - WASI fd_read をループで使用し、拡張可能なヒープバッファに入力を読み込みます。
// - カーソル (pos) を保持し、スキャン中に進めます。
//
// 注意(重要):
// - スキャナは入力全体をメモリに保持します (O(bytes))。
// - scanner_read_i32 は次のトークンが整数であることを前提としています。
//   (次のトークンが整数でない場合、進まずに 0 を返す可能性があります。)
//   scanner_read_all_i32 は防御的であり、非整数トークンをスキップします。
//
// 計算量:
// - 標準入力の読み込み: O(bytes)
// - スキャン: O(bytes)
// - 整数のパース: O(digits)

// スキャナヘッダのレイアウト (ヒープ上の 12 バイト)
// - [0] buf_ptr: 入力バッファの開始位置
// - [4] len:     バッファの長さ
// - [8] pos:     現在のカーソル位置

// scanner_new: 標準入力をすべて読み込みスキャナを作成する
//
// 目的:
// - 標準入力を完全に読み込み、スキャナハンドル（ポインタ）を返します。
//
// 実装(アルゴリズム):
// - cap=65536 で開始します。一杯になったら 2 倍に拡張して続行します。
// - 0 バイト (EOF) または errno != 0 が返るまで fd_read を呼び出します。
// - 12 バイトのヘッダ [buf,len,pos] を確保して返します。
//
// 注意(重要):
// - 返り値は 12 バイトのスキャナヘッダへのポインタです。
// - 本モジュールは入力バッファの解放 API を提供していません（後で追加可能です）。
//
// 計算量:
// - O(bytes)
fn scanner_new <()*>i32> ():
    let mut cap <i32> 65536;
    let mut buf <i32> alloc cap;
    let mut len <i32> 0;

    // Temporary objects for WASI fd_read
    let iov <i32> alloc 8;
    let nread_ptr <i32> alloc 4;

    let mut done <i32> 0;
    while eq done 0:
        do:
            if:
                eq len cap
                then:
                    let new_cap <i32> mul cap 2;
                    let new_buf <i32> realloc buf cap new_cap;
                    set buf new_buf;
                    set cap new_cap;
                else:
                    ()

            store_i32 iov add buf len;
            store_i32 add iov 4 sub cap len;
            store_i32 nread_ptr 0;

            let errno <i32> fd_read 0 iov 1 nread_ptr;
            if:
                ne errno 0
                then:
                    set done 1;
                else:
                    let n <i32> load_i32 nread_ptr;
                    if:
                        eq n 0
                        then:
                            set done 1;
                        else:
                            set len add len n;

    // Free temporaries; the main input buffer stays alive.
    dealloc iov 8;
    dealloc nread_ptr 4;

    let sc <i32> alloc 12;
    store_i32 sc buf;
    store_i32 add sc 4 len;
    store_i32 add sc 8 0;
    sc

// scanner_skip_ws: ASCII 空白（および先頭の BOM）をスキップする
//
// 目的:
// - pos を次のトークンの開始位置まで進めます。
//
// 実装(アルゴリズム):
// - pos==0 の場合、UTF-8 BOM (EF BB BF) または UTF-16 BOM (FF FE / FE FF) を検出してスキップします。
// - その後、NUL、スペース、タブ、\n、\r をスキップします。
//
// 注意(重要):
// - ASCII 空白のみを扱います。これはコンテスト入力を意図しています。
// - NUL は空白として扱われます。
//
// 計算量:
// - O(スキップしたバイト数)
fn scanner_skip_ws <(i32)*>()> (sc):
    let buf <i32> load_i32 sc;
    let len <i32> load_i32 add sc 4;
    let mut p <i32> load_i32 add sc 8;

    // BOM skip (kept for compatibility)
    if:
        eq p 0
        then:
            if:
                ge len 2
                then:
                    let b0 <i32> load_u8 buf;
                    let b1 <i32> load_u8 add buf 1;
                    if:
                        ge len 3
                        then:
                            let b2 <i32> load_u8 add buf 2;
                            // UTF-8 BOM: EF BB BF
                            if:
                                and and eq b0 239 eq b1 187 eq b2 191
                                then:
                                    set p 3;
                                else:
                                    // UTF-16 BOM: FF FE or FE FF
                                    if:
                                        or and eq b0 255 eq b1 254 and eq b0 254 eq b1 255
                                        then:
                                            set p 2;
                                        else:
                                            ()
                        else:
                            if:
                                or and eq b0 255 eq b1 254 and eq b0 254 eq b1 255
                                then:
                                    set p 2;
                                else:
                                    ()
                else:
                    ()
        else:
            ()

    let mut done <i32> 0;
    while eq done 0:
        if:
            lt p len
            then:
                let byte <i32> load_u8 add buf p;
                if:
                    eq byte 0
                    then:
                        set p add p 1;
                    else:
                        if:
                            or eq byte 32 or eq byte 10 or eq byte 13 eq byte 9
                            then:
                                set p add p 1;
                            else:
                                set done 1;
            else:
                set done 1;

    store_i32 add sc 8 p;
    ()

// scanner_is_eof: トークンが残っていないか確認する
//
// 目的:
// - 空白のみが残っている場合に true を返します。
//
// 実装(アルゴリズム):
// - scanner_skip_ws を呼び出し、pos と len を比較します。
//
// 計算量:
// - O(スキップした空白数)
fn scanner_is_eof <(i32)*>bool> (sc):
    scanner_skip_ws sc;
    let len <i32> load_i32 add sc 4;
    let p <i32> load_i32 add sc 8;
    ge p len

// scanner_skip_token: アロケーションなしで 1 トークン消費する
//
// 目的:
// - 文字列を作成せずに pos を 1 トークン分（空白区切り）進めます。
// - scanner_read_all_i32 で進行を保証するために使用されます。
//
// 実装(アルゴリズム):
// - 空白をスキップし、次の空白まで進めます。
//
// 計算量:
// - O(トークン長)
fn scanner_skip_token <(i32)*>()> (sc):
    scanner_skip_ws sc;
    let buf <i32> load_i32 sc;
    let len <i32> load_i32 add sc 4;
    let mut p <i32> load_i32 add sc 8;

    let mut done <i32> 0;
    while eq done 0:
        if:
            lt p len
            then:
                let byte <i32> load_u8 add buf p;
                if:
                    or eq byte 32 or eq byte 10 or eq byte 13 eq byte 9
                    then:
                        set done 1;
                    else:
                        set p add p 1;
            else:
                set done 1;

    store_i32 add sc 8 p;
    ()

// scanner_read_token: 次のトークンを文字列として読み込む
//
// 目的:
// - 次の空白区切りトークンを str として返します。
//
// 実装(アルゴリズム):
// - 空白をスキップしてトークンの終わりを見つけ、新しい文字列領域にバイトをコピーします。
//
// 注意(重要):
// - トークンごとにアロケーションが発生します。整数のみが必要な場合、大量の入力では避けてください。
// - EOF の場合は "" を返します。
//
// 計算量:
// - O(トークン長)
fn scanner_read_token <(i32)*>str> (sc):
    scanner_skip_ws sc;
    let buf <i32> load_i32 sc;
    let len <i32> load_i32 add sc 4;
    let start <i32> load_i32 add sc 8;
    let mut p <i32> start;

    let mut done <i32> 0;
    while eq done 0:
        if:
            lt p len
            then:
                let byte <i32> load_u8 add buf p;
                if:
                    or eq byte 32 or eq byte 10 or eq byte 13 eq byte 9
                    then:
                        set done 1;
                    else:
                        set p add p 1;
            else:
                set done 1;

    let tlen <i32> sub p start;
    if:
        eq tlen 0
        then:
            ""
        else:
            let s <i32> alloc add 4 tlen;
            store_i32 s tlen;
            let mut i <i32> 0;
            while lt i tlen:
                do:
                    store_u8 add s add 4 i load_u8 add buf add start i;
                    set i add i 1;
            store_i32 add sc 8 p;
            s

// scanner_read_i32: 次のトークンを i32 として読み込む（符号付き 10 進数）
//
// 目的:
// - 次のトークンを 10 進符号付き整数としてパースします。
//
// 実装(アルゴリズム):
// - オプションの先頭 '-' を処理し、val=val*10+digit で数字をパースします。
//
// 注意(重要):
// - 次のトークンが整数トークンでない場合、進まずに 0 を返す可能性があります。
// - EOF の場合は 0 を返します。
//
// 計算量:
// - O(桁数)
fn scanner_read_i32 <(i32)*>i32> (sc):
    scanner_skip_ws sc;
    let buf <i32> load_i32 sc;
    let len <i32> load_i32 add sc 4;
    let mut p <i32> load_i32 add sc 8;
    if:
        ge p len
        then:
            0
        else:
            let mut sign <i32> 1;
            let b0 <i32> load_u8 add buf p;
            if:
                eq b0 45
                then:
                    set sign -1;
                    set p add p 1;
                else:
                    ();

            let mut val <i32> 0;
            let mut done <i32> 0;
            while eq done 0:
                if:
                    lt p len
                    then:
                        let byte <i32> load_u8 add buf p;
                        if:
                            eq byte 0
                            then:
                                set p add p 1;
                            else:
                                if:
                                    and ge byte 48 le byte 57
                                    then:
                                        set val add mul val 10 sub byte 48;
                                        set p add p 1;
                                    else:
                                        set done 1;
                    else:
                        set done 1;

            store_i32 add sc 8 p;
            mul val sign

// scanner_read_vec_i32: n 個の i32 値を読み込む
//
// 目的:
// - n 個の整数を Vec<i32> に読み込みます。
//
// 計算量:
// - O(n)
fn scanner_read_vec_i32 <(i32, i32)*>Vec<i32>> (sc, n):
    let mut v <Vec<i32>> vec_new<i32>;
    let mut i <i32> 0;
    while lt i n:
        do:
            set v vec_push<i32> v scanner_read_i32 sc;
            set i add i 1;
    v

// scanner_read_matrix_i32: h x w の整数行列を読み込む
//
// 目的:
// - w 個の整数からなる行を h 行読み込み、Vec<Vec<i32>> を返します。
//
// 計算量:
// - O(h*w)
fn scanner_read_matrix_i32 <(i32, i32, i32)*>Vec<Vec<i32>>> (sc, h, w):
    let mut res <Vec<Vec<i32>>> vec_new<Vec<i32>>;
    let mut i <i32> 0;
    while lt i h:
        do:
            set res vec_push<Vec<i32>> res scanner_read_vec_i32 sc w;
            set i add i 1;
    res

// scanner_read_all_i32: EOF までの残りの整数トークンをすべて読み込む
//
// 目的:
// - 現在のカーソルから EOF までスキャンし、整数トークンを Vec<i32> に収集します。
//
// 実装(アルゴリズム):
// - 空白をスキップします。EOF なら停止します。
// - 次の非空白バイトが '-' または '0'..'9' なら整数を読み込みます。
// - それ以外の場合、進行を保証するために 1 トークンをスキップします（防御的）。
//
// 注意(重要):
// - 非整数トークンは破棄されます。
//
// 計算量:
// - O(残りのバイト数)
fn scanner_read_all_i32 <(i32)*>Vec<i32>> (sc):
    let mut out <Vec<i32>> vec_new<i32>;
    let mut done <i32> 0;

    while eq done 0:
        do:
            scanner_skip_ws sc;
            let buf <i32> load_i32 sc;
            let len <i32> load_i32 add sc 4;
            let p <i32> load_i32 add sc 8;

            if:
                ge p len
                then:
                    set done 1;
                else:
                    let b <i32> load_u8 add buf p;
                    if:
                        or eq b 45 and ge b 48 le b 57
                        then:
                            set out vec_push<i32> out scanner_read_i32 sc;
                        else:
                            // Not an integer token; consume it to guarantee progress.
                            scanner_skip_token sc;
                            ();

    out

// -------- 一般的なコンテスト入力ヘルパー (A / L,R / H を Vec として扱う) --------

// NAInput: 以下の形式の入力
//   N
//   A1 A2 ... AN
struct NAInput:
    n <i32>
    a <Vec<i32>>

// IntervalQueriesInput: 以下の形式の入力
//   N Q
//   L1 R1
//   ...
//   LQ RQ
//
// 注意(重要):
// - 区間クエリでよくあるコンテスト形式です。
// - Q は多くの問題文での M に相当します。
struct IntervalQueriesInput:
    n <i32>
    q <i32>
    left <Vec<i32>>
    right <Vec<i32>>

// QueryTuplesInput: 以下の形式の入力
//   N Q
//   x1_1 x1_2 ... x1_K
//   ...
//   xQ_1 xQ_2 ... xQ_K
//
// 注意(重要):
// - 値を列優先順序 (column-major order) で格納します:
//     cols[c][i] は i 番目のタプルの c 番目の値です。
// - これは 2xQ (L,R) を 3xQ, 4xQ, ... に自然に一般化したものです。
struct QueryTuplesInput:
    n <i32>
    q <i32>
    k <i32>
    cols <Vec<Vec<i32>>>

// NDRHInput: 以下の形式の入力
//   N D R
//   H1 H2 ... HN
struct NDRHInput:
    n <i32>
    d <i32>
    r <i32>
    h <Vec<i32>>



// scanner_read_na_i32: (N, A[1..N]) を読み込む
//
// 目的:
// - "N の後に N 個の整数" という形式を読み込み、A を Vec<i32> として返します。
//
// 計算量:
// - O(n)
fn scanner_read_na_i32 <(i32)*>NAInput> (sc):
    let n <i32> scanner_read_i32 sc;
    let a <Vec<i32>> scanner_read_vec_i32 sc n;
    NAInput n a

// scanner_read_interval_queries_i32: (N, Q, left[1..Q], right[1..Q]) を読み込む
//
// 目的:
// - Q 個の区間を読み込み、左端/右端を別々のベクタとして返します。
//
// 計算量:
// - O(q)
fn scanner_read_interval_queries_i32 <(i32)*>IntervalQueriesInput> (sc):
    let n <i32> scanner_read_i32 sc;
    let q <i32> scanner_read_i32 sc;

    let mut left <Vec<i32>> vec_new<i32>;
    let mut right <Vec<i32>> vec_new<i32>;

    let mut i <i32> 0;
    while lt i q:
        do:
            set left vec_push<i32> left scanner_read_i32 sc;
            set right vec_push<i32> right scanner_read_i32 sc;
            set i add i 1;

    IntervalQueriesInput n q left right


// scanner_read_query_tuples_i32: (N, Q, K 列) を列ベクタとして読み込む
//
// 目的:
// - 各行が K 個の整数を持つ Q 行を読み込みます。
// - 列アクセスを容易にするため、結果を K 個の列 (Vec<Vec<i32>>) として格納します。
//
// 注意(重要):
// - L/R が必要な場合は k=2 で呼び出し、cols[0], cols[1] を取得してください。
// - 3xQ, 4xQ, ... の場合は k=3,4,... を渡します。
//
// 計算量:
// - O(q * k)
fn scanner_read_query_tuples_i32 <(i32, i32)*>QueryTuplesInput> (sc, k):
    let n <i32> scanner_read_i32 sc;
    let q <i32> scanner_read_i32 sc;

    let mut cols <Vec<Vec<i32>>> vec_new<Vec<i32>>;

    // Initialize k empty columns
    let mut c0 <i32> 0;
    while lt c0 k:
        do:
            set cols vec_push<Vec<i32>> cols vec_new<i32>;
            set c0 add c0 1;

    // Fill columns
    let mut i <i32> 0;
    while lt i q:
        do:
            let mut c <i32> 0;
            while lt c k:
                do:
                    let x <i32> scanner_read_i32 sc;

                    // cols[c].push(x)
                    let col <Vec<i32>> unwrap<Vec<i32>> vec_get<Vec<i32>> cols c;
                    let new_col <Vec<i32>> vec_push<i32> col x;
                    vec_set<Vec<i32>> cols c new_col;

                    set c add c 1;

            set i add i 1;

    QueryTuplesInput n q k cols


// query_tuples_col_i32: QueryTuplesInput から c 番目の列を取得する
//
// 注意(重要):
// - cols[c] に格納されている Vec<i32> を返します。
// - インデックスは 0 <= c < t.k を満たす必要があります。
fn query_tuples_col_i32 <(QueryTuplesInput, i32)->Vec<i32>> (t, c):
    unwrap<Vec<i32>> vec_get<Vec<i32>> (get t "cols") c

// scanner_read_ndrh_i32: (N, D, R, H[1..N]) を読み込む
//
// 目的:
// - "N D R の後に N 個の整数" という形式を読み込み、H を Vec<i32> として返します。
//
// 計算量:
// - O(n)
fn scanner_read_ndrh_i32 <(i32)*>NDRHInput> (sc):
    let n <i32> scanner_read_i32 sc;
    let d <i32> scanner_read_i32 sc;
    let r <i32> scanner_read_i32 sc;
    let h <Vec<i32>> scanner_read_vec_i32 sc n;
    NDRHInput n d r h
