//: kpwrite: kp/kpwrite.nepl に関する機能を提供するライブラリ
//:
//: [目的/もくてき]:
//: - このモジュールの公開 API を提供します。
//: - 実装の変更時に最小限の doctest 実行経路を維持します。
//:
//: [注意/ちゅうい]:
//: - 利用時は各関数の「目的」「注意」「計算量」を確認してください。
//:
//: neplg2:test[skip]
//: ```neplg2
//:| #entry main
//:| #target wasi
//: ()
//: ```

// == kpwrite.nepl ==

#indent 4
#target wasi

#import "core/mem" as *
#import "core/math" as *
#import "std/stdio" as *

//: writer_new: 競プロ向けのバッファ付き stdout writer を作る
//:
//: 目的:
//: - 出力を内部バッファに溜め、fd_write の呼び出し回数を減らします。
//:
//: 実装:
//: - ヒープ上に [buf_ptr, cap, len, iov_ptr, nw_ptr] のヘッダ(20B)を置きます。
//: - iov(8B) と nw(4B) は 1 回だけ確保して使い回します。
//:
//: 計算量:
//: - O(1)
fn writer_new <()*>i32> ():
    let mut cap <i32> 4096;
    let mut buf <i32> alloc cap;
    if:
        eq buf 0
        then:
            set cap 1024;
            set buf alloc cap;
            ()
        else:
            ();
    if:
        eq buf 0
        then:
            set cap 256;
            set buf alloc cap;
            ()
        else:
            ();
    let iov <i32> alloc 8;
    let nw  <i32> alloc 4;

    let w <i32> alloc 20;
    store_i32 w buf;
    store_i32 add w 4 cap;
    store_i32 add w 8 0;
    store_i32 add w 12 iov;
    store_i32 add w 16 nw;
    w

//: writer_free: writer の確保領域を解放する
//:
//: 注意:
//: - 未 flush のデータは捨てられます。必要なら先に writer_flush を呼んでください。
//:
//: 計算量:
//: - O(1)
fn writer_free <(i32)*>()> (w):
    let buf <i32> load_i32 w;
    let cap <i32> load_i32 add w 4;
    let iov <i32> load_i32 add w 12;
    let nw  <i32> load_i32 add w 16;

    dealloc buf cap;
    dealloc iov 8;
    dealloc nw 4;
    dealloc w 20;
    ()

//: writer_flush: バッファ内容を stdout に書き出す
//:
//: 実装:
//: - fd_write は部分書き込みの可能性があるので off を進めるループにします。
//: - 競プロ用途として、エラー時は打ち切って len=0 にします（簡易）。
//:
//: 計算量:
//: - O(len)
fn writer_flush <(i32)*>()> (w):
    let buf <i32> load_i32 w;
    let cap <i32> load_i32 add w 4;
    let write_len <i32> load_i32 add w 8;

    if:
        or eq write_len 0 le cap 0
        then:
            ()
        else:
            let iov <i32> load_i32 add w 12;
            let nw  <i32> load_i32 add w 16;

            let mut off <i32> 0;
            let mut done <i32> 0;

            while eq done 0:
                if:
                    ge off write_len
                    then:
                        set done 1;
                        ()
                    else:
                        store_i32 iov add buf off;
                        store_i32 add iov 4 sub write_len off;
                        store_i32 nw 0;

                        let errno <i32> fd_write 1 iov 1 nw;
                        if:
                            ne errno 0
                            then:
                                set done 1;
                                ()
                            else:
                                let n <i32> load_i32 nw;
                                if:
                                    eq n 0
                                    then:
                                        set done 1;
                                        ()
                                    else:
                                        set off add off n;
                                        ();

            store_i32 add w 8 0;
            ()

//: writer_ensure: need バイト分の空きを確保する（足りなければ flush）
//:
//: 注意:
//: - need が cap を超えるケースは呼び出し側で避けてください（この版は最小実装）。
fn writer_ensure <(i32,i32)*>()> (w, need):
    let cap <i32> load_i32 add w 4;
    let write_len <i32> load_i32 add w 8;
    if:
        le add write_len need cap
        then:
            ()
        else:
            writer_flush w;
            ()

//: writer_put_u8: 1 バイト追記する
//:
//: 計算量:
//: - O(1)（flush が入ると O(len)）
fn writer_put_u8 <(i32,i32)*>()> (w, b):
    let cap <i32> load_i32 add w 4;
    if:
        le cap 0
        then:
            ()
        else:
            writer_ensure w 1;
            let buf <i32> load_i32 w;
            let write_len <i32> load_i32 add w 8;
            store_u8 add buf write_len b;
            store_i32 add w 8 add write_len 1;
            ()

//: writer_writeln: 改行 '\n' を出力する
fn writer_writeln <(i32)*>()> (w):
    writer_put_u8 w 10

//: writer_write_str: str を追記する
//:
//: 注意:
//: - str は [len][bytes] 形式なので、bytes 先頭は add s 4 です。
fn writer_write_str <(i32,str)*>()> (w, s):
    let cap <i32> load_i32 add w 4;
    let n <i32> load_i32 s;

    if:
        or le n 0 le cap 0
        then:
            ()
        else:
            writer_ensure w n;

            let buf <i32> load_i32 w;
            let write_len <i32> load_i32 add w 8;
            let src <i32> add s 4;

            let mut i <i32> 0;
            while lt i n:
                do:
                    store_u8 add buf add write_len i load_u8 add src i;
                    set i add i 1;

            store_i32 add w 8 add write_len n;
            ()

//: writer_write_i32: i32 を 10 進で出力する（alloc なし）
//:
//: 実装:
//: - INT_MIN は abs overflow するので定数文字列で処理します。
//: - それ以外は桁数 d を数えて、バッファ末尾から埋めます（反転不要）。
//:
//: 計算量:
//: - O(桁数)
fn writer_write_i32 <(i32,i32)*>()> (w, v):
    if:
        eq v -2147483648
        then:
            writer_write_str w "-2147483648";
            ()
        else:
            if:
                eq v 0
                then:
                    writer_put_u8 w 48;
                    ()
                else:
                    let mut x <i32> v;

                    if:
                        lt x 0
                        then:
                            writer_put_u8 w 45;   // '-'
                            let zero <i32> 0;
                            set x sub zero x;
                            ()
                        else:
                            ();

                    // 桁数を数える
                    let mut t <i32> x;
                    let mut d <i32> 0;
                    while lt 0 t:
                        do:
                            set d add d 1;
                            set t div_s t 10;

                    writer_ensure w d;

                    let buf <i32> load_i32 w;
                    let old_len <i32> load_i32 add w 8;
                    store_i32 add w 8 add old_len d;

                    let mut n <i32> x;
                    let mut i <i32> 0;
                    let endm1 <i32> sub add old_len d 1;

                    while lt i d:
                        do:
                            let rem <i32> mod_s n 10;
                            let off <i32> sub endm1 i;
                            let code <i32> add 48 rem;
                            store_u8 add buf off code;
                            set n div_s n 10;
                            set i add i 1;

                    ()

//: writer_write_u64: i64 ビット列を符号なし 10 進として出力する
//:
//: 目的:
//: - `u64` 相当値を 10 進文字列で出力します。
//:
//: 実装:
//: - `div_u` / `rem_u` で桁を逆順に取り出し、末尾から埋めます。
//: - 内部表現は `i64` ですが、比較・除算・剰余は unsigned 系を使います。
//:
//: 注意:
//: - 引数型は `i64` ですが、`u64` ビット列として解釈されます。
//:
//: 計算量:
//: - O(桁数)
fn writer_write_u64 <(i32,i64)*>()> (w, v):
    let zero <i64> i64_extend_i32_u 0;
    let ten <i64> i64_extend_i32_u 10;
    if:
        i64_eq v zero
        then:
            writer_put_u8 w 48;
            ()
        else:
            let mut t <i64> v;
            let mut d <i32> 0;
            while i64_gt_u t zero:
                do:
                    set d add d 1;
                    set t i64_div_u t ten;

            writer_ensure w d;

            let buf <i32> load_i32 w;
            let old_len <i32> load_i32 add w 8;
            store_i32 add w 8 add old_len d;

            let mut n <i64> v;
            let mut i <i32> 0;
            let endm1 <i32> sub add old_len d 1;
            while lt i d:
                do:
                    let rem64 <i64> i64_rem_u n ten;
                    let rem <i32> i32_wrap_i64 rem64;
                    let off <i32> sub endm1 i;
                    let code <i32> add 48 rem;
                    store_u8 add buf off code;
                    set n i64_div_u n ten;
                    set i add i 1;

            ()

//: writer_write_i64: i64 を符号付き 10 進で出力する
//:
//: 目的:
//: - `i64` を符号付き 10 進文字列として出力します。
//:
//: 実装:
//: - 負数の場合は `-` を出力し、`0 - v` を unsigned として `writer_write_u64` に渡します。
//: - `i64::MIN` も 2 の補数のまま安全に処理できます。
//:
//: 計算量:
//: - O(桁数)
fn writer_write_i64 <(i32,i64)*>()> (w, v):
    let zero <i64> i64_extend_i32_u 0;
    if:
        i64_lt_s v zero
        then:
            writer_put_u8 w 45;
            let abs_u <i64> i64_sub zero v;
            writer_write_u64 w abs_u;
            ()
        else:
            writer_write_u64 w v;
            ()

//: writer_write_f64_fixed: f64 を固定小数点で出力する
//:
//: 目的:
//: - `v` を小数点以下 `precision` 桁で出力します。
//:
//: 実装:
//: - 符号、整数部、少数部を順に出力します。
//: - 少数部は 10 倍を繰り返して 1 桁ずつ生成します。
//:
//: 注意:
//: - `NaN` / `inf` は未対応です。
//:
//: 計算量:
//: - O(precision + 桁数)
fn writer_write_f64_fixed <(i32,f64,i32)*>()> (w, v, precision):
    let mut x <f64> v;
    let zero <f64> f64_convert_i32_u 0;
    let is_neg <bool> f64_lt x zero;
    if:
        is_neg
        then:
            writer_put_u8 w 45;
            let nx <f64> f64_neg x;
            set x nx;
            ()
        else:
            ();

    let int_part <i64> i64_trunc_f64_u x;
    writer_write_u64 w int_part;

    if:
        le precision 0
        then:
            ()
        else:
            writer_put_u8 w 46;
            let int_as_f64 <f64> f64_convert_i64_u int_part;
            let mut frac <f64> f64_sub x int_as_f64;
            let ten <f64> f64_convert_i32_u 10;
            let mut i <i32> 0;
            while lt i precision:
                do:
                    let frac10 <f64> f64_mul frac ten;
                    set frac frac10;
                    let digit <i32> i32_trunc_f64_u frac;
                    writer_put_u8 w add 48 digit;
                    let digit_f <f64> f64_convert_i32_u digit;
                    let next_frac <f64> f64_sub frac digit_f;
                    set frac next_frac;
                    set i add i 1;
            ()

//: writer_write_f64: f64 を小数点以下 6 桁で出力する
//:
//: 計算量:
//: - O(桁数)
fn writer_write_f64 <(i32,f64)*>()> (w, v):
    writer_write_f64_fixed w v 6

//: writer_write_f32_fixed: f32 を固定小数点で出力する
//:
//: 計算量:
//: - O(precision + 桁数)
fn writer_write_f32_fixed <(i32,f32,i32)*>()> (w, v, precision):
    let v64 <f64> f64_promote_f32 v;
    writer_write_f64_fixed w v64 precision

//: writer_write_f32: f32 を小数点以下 6 桁で出力する
//:
//: 計算量:
//: - O(桁数)
fn writer_write_f32 <(i32,f32)*>()> (w, v):
    writer_write_f32_fixed w v 6

//: writer_write_space: 半角スペースを 1 文字出力する
//:
//: [目的/もくてき]:
//: - 競技プログラミングで頻出の「値を空白区切りで出力する」処理を簡潔にします。
//:
//: [実装/じっそう]:
//: - `writer_put_u8` で ASCII 32 (`' '`) を 1 バイト出力します。
//:
//: [計算量/けいさんりょう]:
//: - O(1)
//:
//: neplg2:test[stdio, normalize_newlines]
//: stdout: "1 2\n"
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "kp/kpwrite" as *
//: fn main <()*> ()> ():
//:     let w <i32> writer_new;
//:     writer_write_i32 w 1;
//:     writer_write_space w;
//:     writer_write_i32 w 2;
//:     writer_writeln w;
//:     writer_flush w;
//:     writer_free w
//: ```
fn writer_write_space <(i32)*>()> (w):
    writer_put_u8 w 32

//: writer_write_i32_ln: i32 を出力して改行する
//:
//: [目的/もくてき]:
//: - `writer_write_i32` と `writer_writeln` の定型連結を 1 呼び出しで提供します。
//:
//: [実装/じっそう]:
//: - 数値を出力した後、改行 `\n` を続けて出力します。
//:
//: [計算量/けいさんりょう]:
//: - O(桁数)
//:
//: neplg2:test[stdio, normalize_newlines]
//: stdout: "123\n"
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "kp/kpwrite" as *
//: fn main <()*> ()> ():
//:     let w <i32> writer_new;
//:     writer_write_i32_ln w 123;
//:     writer_flush w;
//:     writer_free w
//: ```
fn writer_write_i32_ln <(i32,i32)*>()> (w, v):
    writer_write_i32 w v;
    writer_writeln w

//: writer_write_i64_ln: i64 を出力して改行する
//:
//: [目的/もくてき]:
//: - `writer_write_i64` と `writer_writeln` をまとめ、64bit 出力の定型を簡潔にします。
//:
//: [実装/じっそう]:
//: - 数値本体を 10 進で出力し、末尾に改行を付与します。
//:
//: [計算量/けいさんりょう]:
//: - O(桁数)
//:
//: neplg2:test[stdio, normalize_newlines]
//: stdout: "42\n"
//: ```neplg2
//:| #entry main
//:| #target wasi
//:| #import "kp/kpwrite" as *
//: fn main <()*> ()> ():
//:     let w <i32> writer_new;
//:     writer_write_i64_ln w i64_extend_i32_u 42;
//:     writer_flush w;
//:     writer_free w
//: ```
fn writer_write_i64_ln <(i32,i64)*>()> (w, v):
    writer_write_i64 w v;
    writer_writeln w

//: writer_write_f64_ln: f64 を出力して改行する
fn writer_write_f64_ln <(i32,f64)*>()> (w, v):
    writer_write_f64 w v;
    writer_writeln w

//: writer_write_f32_ln: f32 を出力して改行する
fn writer_write_f32_ln <(i32,f32)*>()> (w, v):
    writer_write_f32 w v;
    writer_writeln w
