# Neknaj Expression Prefix Language - General-purpose 2

NEPLG1が迷走しているため、一度最小構成の言語として再度開発をし直す  

NEPLG1では様々な機能の共存を図ったが、一度これを廃し、核となる機能、特徴的な機能のみをもつシンプルな実装として完成させる  

試作であるのでターゲットはwasmのみとする

## 書き方

この言語の特徴は式指向と前置記法である  
中置演算を廃し、全てを前置記法で書く  
型注釈や制御構造など、あらゆるものを前置する  

このNEPLG2ではオフサイドルール、インデントのみを用いて入れ子構造を記述する  
オフサイドルールと{}の共存は可能であると判断しNEPLG1ではその共存を図ったが、複雑になりすぎて試作品としては不適切だと判断した  

## コード例

先ずはコード例を提示し、次いで詳細に説明する

```neplg2
#entry main
#indent 4
#target wasi

fn main <()*>()> ():
    #import "std/stdio"
    #use std::stdio::*
    
    let mut x <i32> 0;
    
    while lt x 100:
        set x add x x;
        set x:
            sub x:
                x
    
    <()> print_i32 x;
    
    set x sub x 10;
    print_i32 x;
    
    <()> print_i32 if lt x 80 sub x 20 add 20 x;
    print_i32:
        <i32> if:
            cond:
                lt x 80
            then:
                sub x 20
            else:
                add 20 x

#if[target=wasm]
fn add <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.add

#if[target=wasm]
fn sub <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.sub

```


## 型

式は必ずただ1つの型をもつ  
`()`はunit型、或いはunit型の値を表す定数である  
`.`は何かの型を表し、`.label`のようにラベルを追加できる 同じラベルねものは同じ型を表す ラベルの名前解決は他の識別子と同様のルールに従う  
スタックを簡約しながら先頭から読んでいく  

`a->b`は純粋関数を表し、aが引数、bが戻り値であることを示す aは`()`の中に任意個追加できる  
`a*>b`は副作用などを持つ関数を表す  
`a->b`の関数から`a*>b`の関数は呼べない (逆は可能)  

### 式の範囲の判定
型のスタックを用いながら言語処理を進めます  
関数でないものは単体で式である 例えば`1`の型は`i32`であり、式である  
関数は式ではない 例えば`add`の型は`(i32,i32)->i32`であり、式ではない (試作品であるため一旦高階関数の機能は無しにします)  
関数は引数が揃った時点で簡約される 例えばスタックが `[ (i32,i32)->i32, i32, i32 ]`であれば`[ i32 ]`と簡約される  
`add sub 1 2 3`という式において、`sub`から始まる式は`sub`まで読んだ時点で`[ (i32,i32)->i32, (i32,i32)->i32 ]`、`2`まで読んだ時点でスタックが`[ (i32,i32)->i32, i32 ]`となり、長さが等しくなるので、`sub 1 2`が1つの式であることがわかる また、`1`も式であるし、`add sub 1 2 3`も式である  

## 制御構造とか
`if`や`while`なども式を成します  
例えば`if`の型は`(bool,.x,.x)->.x`となる  
`if`では任意に`then`や`else`を挿入できる (不正な位置への挿入は不可 然るべき位置に挿入できる)  
`while`の型は`(bool,())->()`
制御構造ではないもの  
`let name`や`let mut name`や`set name`は`(.x)->()` (`let`ではなく`let name`までで一塊であり、`let name`が`(.x)->()`)  
letやlet mutで型推論によって変数の型`.x`を確定する  
setではletやlet mutで定義した`.x`に則る (`.label`の説明でおこなった処理と同一)



## `:`ブロック オフサイドルール
`:`を用いて改行した次の行ではインデントが1つ増える  
`:`を書いた行のインデントになった時点でそのブロックが終了し、ブロックは1つの式を成す  
`;`は`:`ブロックの直下の式で使えるスタック復帰命令である  
インデントの不正はエラーになります  
`:`は任意の行末で使用できます  
`:`ブロックの`:`の後ろには空白とコメントしか使えません  
`:`ブロックは式であるため、他の式と同様に関数呼び出しの引数などに使うことができます 

`:` が1つの式となるのは、無名のブロックと、`while`、および`if`の`then``else`に適用される  
`if`や`struct`、`enum`などは式を成すものではない  

## 型注釈
`<T>`のように`<``>`で囲まれた型名は型注釈である  
型注釈`<T>`は何もしない関数`(.T)->.T`と見做し、型推論で関数と纏めて処理される  
つまり、型注釈は続く「式」に対して、関数呼び出しと同じように振舞う  

### 例
`let mut neg <bool> lt n 0;`
negという名前の変数を宣言し、その値は`<bool> lt n 0`である
式 `<bool> lt n 0` は、 式 `lt n 0` はboolであるという型注釈
式 `lt n 0`は、nと0の大小比較

## 型推論
型推論は読んでいる時点で既に判明している情報のみを用いて行う  
そのために型注釈や関数名などあらゆるものを前置している  
型推論では全ての式にたいする具体的な型を決定する  
`.label`を用いて書かれた関数定義などには具体的な型は決定できないが、`.label`を含めた状態で決定しておく  
ただ、これは試作なので、定義での多相は扱わないことにする  
entryに指定された関数は、`.label`を含まない、完全に具体的な型として決定できるはずである  
決定できなかった場合、型推論の失敗であり、エラーメッセージを出す  
また、矛盾が発生した場合などにも、エラーメッセージを出す  

## `#`

`#`の行は特別な意味をもつ行である  
`#entry`はプログラムの起点を指定する entryのないライブラリなどでは指定しません  
`#indent`はインデントの仕方を示す 規定はspace4つである
`#target`はプログラムのターゲットを指定する  
`#import`は標準ライブラリやライブラリなどで解決されるプログラムを読み込む  
`#use`はネストされた名前のエイリアスを作成する  
`#if[]`は特定の条件でのみ有効となるコードを表す  
`#wasm`は生WASMの命令をWATを用いて埋め込めます target=wasm の中でしか使えません `#wasm`でもスタックの検査だけは行います  

## コメント
`//`の後ろがコメントになる


## 処理
前置記法を採用し、オフサイドルールを採用し、全てのコードを前から読むことができます  
トークナイズ、パース、型推論などの全てを、前から一回読んでいくだけで行うことができるはずです  
但し、これでは定義の巻き上げが行えません  
オフサイドルールによってスコープ内の定義を全て探せるはずなので、適切に順番に処理していけば定義の巻き上げにも対応できます  
定義の巻き上げはmutでないletのみに適用できます fnもletの糖衣構文なので定義の巻き上げが行えます

## 糖衣構文
`fn name`は`let name`の糖衣構文である ただし、nameの型`.x`は`a->b`か`a*>b`であるという制限を設ける  
`then:`や`else:`は`:`の糖衣構文である ただしこれはifのみで用いれるという制限を設ける

## リテラルなど
`i32`は小数点を含まない数字です`1` `2` `3`など
`f32`は小数点を含む数字です`1.0` `1.3`など
関数定義は`(args) expr`です
型注釈は`<T>`です



## 書き方例

### if

ベースが`if true 0 1`,`if true 0 if true 1 2`だとして
これに
「`:`つけたら改行してもいいよ」と
「`if`には`cond`と`then`と`else`つけてもいいよ」
を追加したらこうなりました

`"if" "cond"? <cond_expr> "then"? <then_expr> "else"? <else_expr>`  
"cond"キーワードと"then"キーワードと"else"キーワードは省略可能 (というよりは追加可能) であるが、 cond_exprとthen_exprとelse_exprは省略不可能  
それぞれで`:`による改行が適用可能になる  

ベースは`"if" <cond_expr> <then_expr> <else_expr>`
ここに、cond then else などのキーワードを適切に追加することができる
具体的には`<cond_expr>`を`"cond" <cond_expr>`のようにキーワードを付与できる
また、`if`に対する`:` つまり `if:` については、ブロックを成すものではなく、cond_expr then_expr else_expr を改行して表示できるようにするものである
`if:`は、具体的には、その次の行から式3つ分だけインデントを1つふやしてcond_expr then_expr else_expr とする 3行分ではなく式3つ分であるのは、cond_expr then_expr else_exprのそれぞれで通常の`:`ブロックを使用して複数行となる可能性があるためである
`cond`や`then`や`else`に対して付与された`:`は、`if`に対する付与ではないため、通常の`:`ブロックである
`cond:` は 通常の`:`と同じであり、1つのブロック式である
また、`"if" <cond_expr>`の後ろの`:`、`"if" <cond_expr> :`では、then_exprとelse_exprを改行して表示できるようにする
`"if" <cond_expr> :`は、具体的には、その次の行から式2つ分だけインデントを1つふやしてthen_expr else_expr とする
この`<cond_expr>`にもcondキーワードを付与できるようにするが、実用上は不要であろう

```
// 1行
if <cond_expr> <then_expr> <else_expr>
// cond_expr then_expr else_expr にはそれぞれキーワードを付与可能
if cond <cond_expr> then <then_expr> else <else_expr>
// 改行 `if:`では続くcond then elseをインデント付きで改行して記述可能
if:
    <cond_expr>
    <then_expr>
    <else_expr>
// 改行 `if <cond_expr>:`では続くcond then elseをインデント付きで改行して記述可能
if <cond_expr>:
    <then_expr>
    <else_expr>
// cond_expr then_expr else_expr にはそれぞれキーワードを付与可能
if:
    cond <cond_expr>
    then <then_expr>
    else <else_expr>
if <cond_expr>
    then <then_expr>
    else <else_expr>
if cond <cond_expr>
    then <then_expr>
    else <else_expr>
// cond then else に対する `:` は通常の`:`ブロック
if:
    cond:
        <cond_expr>
    then:
        <then_expr>
    else:
        <else_expr>
if <cond_expr>
    then:
        <then_expr>
    else:
        <else_expr>
if cond <cond_expr>
    then:
        <then_expr>
    else:
        <else_expr>
```

```neplg2

// 1行 if
if true 0 1

// 1行 if then else
if true then 0 else 1

// 複数行 if then else
if true:
    then 0
    else 1

// 複数行 if then else
if true:
    then:
        0
    else:
        1

// 複数行 if then else
if:
    true
    0
    1

// 複数行 if then else
if:
    true
    then:
        0
    else:
        1

if:
    cond:
        true
    then:
        0
    else:
        1

// 複数行 if then else
if:
    true
    then 0
    else 1

// 1行 if 組み合わせ
if true 0 if true 1 2
if true 0 else if true 1 else 2
if true then 0 else if true then 1 else 2

// 複数行 if else 組み合わせ

if:
    true
    then:
        0
    else:
        if:
            cond:
                true
            then:
                1
            else:
                2

if:
    true
    then:
        0
    else if:
        cond:
            true
        then:
            1
        else:
            2

```


### ブロック 文 セミコロン

`:`によってインデントでまとめられた複数の式をブロックという
ブロック自体は一つの式になり、一つの値を返す

ブロック直下の式を文という
ブロック直下でない式は単に式という

```
// ブロック
:
    <文>;
    <文>;
    <文>
:
    <文>
    <文>
    <文>
```

ブロックの値および型は、ブロックの最後の文によって決まる  
最後の文以外の結果は捨てる これは後述する`;`の存在に関係ない  
ブロックに3つの文があったとき、前2つの文は、その文の評価が終わった時点で結果の値を捨てる  

`;`は、その直前で、スタックがブロックの基準から値1つぶんだけ成長していることを確認する  
`;`は構文上、1行のみからなる文にしかつけることができない  
複数行からなる文、つまりブロックなどを含む文では、代わりにそのインデントルールが同様のことを確認することになる  
`;`は専らスタックの確認のみに用いられるものであり、省略することができる  


`:`に入った時点のスタックを`[ X ]`として説明する  

```
:
    // この時点で`[ X ]`
    add 1 2; // ok
    add 1 2 // ok
    add 1 2 3; // エラー
```

`:`の直下の式`add 1 2;`では、`;`の直前で`[ X, i32 ]`であり、`;`の直後で`[ X ]`となる  
`add 1 2 3;`では、`;`の直前で`[ X, i32, i32 ]`であり、スタックが長すぎるのでエラーである  

ブロックの値は、その最後の文の値になる  
最後の文の末尾に`;`がある場合、便宜上そのブロックの値は`()`とする  

```
// このブロックの値は11
<i32> :
    add 1 2; // ここで3をスタックから捨てる
    add 3 4  // ここで7をスタックから捨てる
    add 5 6 // これがブロックの値
```
```
// このブロックの値は()
<()> :
    add 1 2; // ここで3をスタックから捨てる
    add 3 4  // ここで7をスタックから捨てる
    add 5 6; // ここで11をスタックから捨てて、()がブロックの値
```

ブロック内に n 個の文があるとき：
1〜n-1 番目の文の結果は 必ず破棄
n 番目（最後の文）だけがブロックの値を決める
最後の文が ;付きなら、ブロックの値は ()
;なしなら、その文の値がブロックの値