# Neknaj Expression Prefix Language - General-purpose 2

NEPLG1が迷走しているため、一度最小構成の言語として再度開発をし直す  

NEPLG1では様々な機能の共存を図ったが、一度これを廃し、核となる機能、特徴的な機能のみをもつシンプルな実装として完成させる  

試作であるのでターゲットはwasmのみとする

## 書き方

この言語の特徴は式指向と前置記法である  
中置演算を廃し、全てを前置記法で書く  
型注釈や制御構造など、あらゆるものを前置する  

このNEPLG2ではオフサイドルール、インデントのみを用いて入れ子構造を記述する  
オフサイドルールと{}の共存は可能であると判断しNEPLG1ではその共存を図ったが、複雑になりすぎて試作品としては不適切だと判断した  

## コード例

先ずはコード例を提示し、次いで詳細に説明する

```neplg2
#entry main
#indent 4

fn main <()*>()> ():
    #import "std/stdio"
    #use std::stdio::*
    
    let mut x <i32> 0;
    
    while lt x 100:
        set x add x x;
        set x:
            sub x:
                x
    
    <()> print_i32 x;
    
    set x sub x 10;
    print_i32 x;
    
    <()> print_i32 if lt x 80 sub x 20 add 20 x;
    print_i32:
        <i32> if:
            lt x 80
        :
            sub x 20
        :
            add 20 x

#if[target=wasm]
fn add <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.add

#if[target=wasm]
fn sub <(i32,i32)->i32> (a,b):
    #wasm:
        local.get $a
        local.get $b
        i32.sub

```


## 型

式は必ずただ1つの型をもつ  
`()`はunit型、或いはunit型の値を表す定数である  
`.`は何かの型を表し、`.label`のようにラベルを追加できる 同じラベルねものは同じ型を表す ラベルの名前解決は他の識別子と同様のルールに従う  
スタックを簡約しながら先頭から読んでいく  

`a->b`は純粋関数を表し、aが引数、bが戻り値であることを示す aは`()`の中に任意個追加できる  
`a*>b`は副作用などを持つ関数を表す  
`a->b`の関数から`a*>b`の関数は呼べない (逆は可能)  

### 式の範囲の判定
型のスタックを用いながら言語処理を進めます  
関数でないものは単体で式である 例えば`1`の型は`i32`であり、式である  
関数は式ではない 例えば`add`の型は`(i32,i32)->i32`であり、式ではない (試作品であるため一旦高階関数の機能は無しにします)  
関数は引数が揃った時点で簡約される 例えばスタックが `[ (i32,i32)->i32, i32, i32 ]`であれば`[ i32 ]`と簡約される  
`add sub 1 2 3`という式において、`sub`から始まる式は`sub`まで読んだ時点で`[ (i32,i32)->i32, (i32,i32)->i32 ]`、`2`まで読んだ時点でスタックが`[ (i32,i32)->i32, i32 ]`となり、長さが等しくなるので、`sub 1 2`が1つの式であることがわかる また、`1`も式であるし、`add sub 1 2 3`も式である  

## 制御構造とか
`if`や`while`なども式を成します  
例えば`if`の型は`(bool,.x,.x)->.x`となる  
`while`の型は`(bool,())->()`
制御構造ではないもの  
`let name`や`let mut name`や`set name`は`(.x)->()` (`let`ではなく`let name`までで一塊であり、`let name`が`(.x)->()`)  
letやlet mutで型推論によって変数の型`.x`を確定する  
setではletやlet mutで定義した`.x`に則る (`.label`の説明でおこなった処理と同一)



## `:`ブロック オフサイドルール
`:`を用いて改行した次の行ではインデントが1つ増える  
`:`を書いた行のインデントになった時点でそのブロックが終了し、ブロックは1つの式を成す  
`;`は`:`ブロックの直下の式で使えるスタック復帰命令である  
`:`に入った時点のスタックを`[ X ]`として説明する  
`;`はスタックトップの値を1つポップして破棄して`:`に入った時点のスタックを`[ X ]`に戻ることを表す つまり`[ X, .x ]`を`[ X ]` とする `[ X, .x ]`以外であればエラーとなる   
`:`の直下の式`add 1 2;`では、`;`の直前で`[ X, i32 ]`であり、`;`の直後で`[ X ]`となる  
`add 1 2 3;`では、`;`の直前で`[ X, i32, i32 ]`であり、スタックが長すぎるのでエラーである  
最後の行に`;`がない場合、スタックが`[ X, .x ]`となるので、`:`ブロックの型は`.x`であったということである  
最後の行に`;`がある場合、`[ X ]`となるので便宜上`()`を積んで`:`ブロックの型は`()`としておく  
`[ X, (), .x ]`となったとき、便宜的に`[ X, .x ]`と簡約する (`;`の省略)  
インデントの不正はエラーになります  
`:`は任意の行末で使用できます  
`:`ブロックの`:`の後ろには空白とコメントしか使えません  
`:`ブロックは式であるため、他の式と同様に関数呼び出しの引数などに使うことができます  

## 型注釈
`<T>`のように`<``>`で囲まれた型名は型注釈である  
型注釈`<T>`は何もしない関数`(.T)->.T`と見做し、型推論で関数と纏めて処理される  

## 型推論
型推論は読んでいる時点で既に判明している情報のみを用いて行う  
そのために型注釈や関数名などあらゆるものを前置している  
型推論では全ての式にたいする具体的な型を決定する  
`.label`を用いて書かれた関数定義などには具体的な型は決定できないが、`.label`を含めた状態で決定しておく  
ただ、これは試作なので、定義での多相は扱わないことにする  
entryに指定された関数は、`.label`を含まない、完全に具体的な型として決定できるはずである  
決定できなかった場合、型推論の失敗であり、エラーメッセージを出す  
また、矛盾が発生した場合などにも、エラーメッセージを出す  

## `#`

`#`の行は特別な意味をもつ行である  
`#entry`はプログラムの起点を指定する entryのないライブラリなどでは指定しません  
`#indent`はインデントの仕方を示す 規定はspace4つである
`#import`は標準ライブラリやライブラリなどで解決されるプログラムを読み込む  
`#use`はネストされた名前のエイリアスを作成する  
`#if[]`は特定の条件でのみ有効となるコードを表す  
`#wasm`は生WASMの命令をWATを用いて埋め込めます target=wasm の中でしか使えません `#wasm`でもスタックの検査だけは行います  

## コメント
`//`の後ろがコメントになる


## 処理
前置記法を採用し、オフサイドルールを採用し、全てのコードを前から読むことができます  
トークナイズ、パース、型推論などの全てを、前から一回読んでいくだけで行うことができるはずです  
但し、これでは定義の巻き上げが行えません  
オフサイドルールによってスコープ内の定義を全て探せるはずなので、適切に順番に処理していけば定義の巻き上げにも対応できます  
定義の巻き上げはmutでないletのみに適用できます fnもletの糖衣構文なので定義の巻き上げが行えます

## 糖衣構文
`fn name`は`let name`の糖衣構文である ただし、nameの型`.x`は`a->b`か`a*>b`であるという制限を設ける  
`then:`や`else:`は`:`の糖衣構文である ただしこれはifのみで用いれるという制限を設ける

## リテラルなど
`i32`は小数点を含まない数字です`1` `2` `3`など
`f32`は小数点を含む数字です`1.0` `1.3`など
関数定義は`(args) expr`です
型注釈は`<T>`です