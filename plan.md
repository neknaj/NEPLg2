# Neknaj Expression Prefix Language - General-purpose 2

NEPLG1が迷走しているため、一度最小構成の言語として再度開発をし直す  

NEPLG1では様々な機能の共存を図ったが、一度これを廃し、核となる機能、特徴的な機能のみをもつシンプルな実装として完成させる  

## 書き方

この言語の特徴は式指向と前置記法である  
中置演算を廃し、全てを前置記法で書く  
型注釈や制御構造など、あらゆるものを前置する  

このNEPLG2ではオフサイドルール、インデントのみを用いて入れ子構造を記述する  
オフサイドルールと{}の共存は可能であると判断しNEPLG1ではその共存を図ったが、複雑になりすぎて試作品としては不適切だと判断した  

## コード例

先ずはコード例を提示し、次いで詳細に説明する

```neplg2
#entry main
#indent 4
#target wasi

#import "core/math" as *
#import "std/stdio" as *

fn main <()*> ()> ():
    let mut a <i32> 0;
    let mut b <i32> 1;
    let mut i <i32> 0;
    while lt i 10:
        print "fib = ";
        println_i32 a;
        let mut next add a b;
        set a b;
        set b next;
        set i add i 1;
```


## 型

式は必ずただ1つの型をもつ  
`()`はunit型、或いはunit型の値を表す定数である  
`.`は何かの型を表し、`.label`のようにラベルを追加できる 同じラベルねものは同じ型を表す ラベルの名前解決は他の識別子と同様のルールに従う  
スタックを簡約しながら先頭から読んでいく  

`a->b`は純粋関数を表し、aが引数、bが戻り値であることを示す aは`()`の中に任意個追加できる  
`a*>b`は副作用などを持つ関数を表す  
`a->b`の関数から`a*>b`の関数は呼べない (逆は可能)  

### 式の範囲の判定
型のスタックを用いながら言語処理を進めます  
関数でないものは単体で式である 例えば`1`の型は`i32`であり、式である  
関数は式ではない 例えば`add`の型は`(i32,i32)->i32`であり、式ではない (試作品であるため一旦高階関数の機能は無しにします)  
関数は引数が揃った時点で簡約される 例えばスタックが `[ (i32,i32)->i32, i32, i32 ]`であれば`[ i32 ]`と簡約される  
`add sub 1 2 3`という式において、`sub`から始まる式は`sub`まで読んだ時点で`[ (i32,i32)->i32, (i32,i32)->i32 ]`、`2`まで読んだ時点でスタックが`[ (i32,i32)->i32, i32 ]`となり、長さが等しくなるので、`sub 1 2`が1つの式であることがわかる また、`1`も式であるし、`add sub 1 2 3`も式である  

## 制御構造とか
`if`や`while`なども式を成します  
例えば`if`の型は`(bool,.x,.x)->.x`となる  
`if`では任意に`then`や`else`を挿入できる (不正な位置への挿入は不可 然るべき位置に挿入できる)  
`while`の型は`(bool,())->()`
制御構造ではないもの  
`let name`や`let mut name`や`set name`は`(.x)->()` (`let`ではなく`let name`までで一塊であり、`let name`が`(.x)->()`)  
letやlet mutで型推論によって変数の型`.x`を確定する  
setではletやlet mutで定義した`.x`に則る (`.label`の説明でおこなった処理と同一)


## オフサイドルール

オフサイドルールはブロック式か引数の2種類に分けられる

### ブロック式 オフサイドルール
ブロック式とは、複数の式を纏めて一つの式を成すものである  
ブロックのオフサイドルールを用いて改行した次の行ではインデントが1つ増える  
`block:`を書いた行のインデントになった時点でそのブロックが終了し、ブロックは1つの式を成す  
`;`は`block:`の直下の式で使えるスタック復帰の確認命令である  
インデントの不正はエラーになります  
`block:`は任意の行末で使用できます  
`block:`ブロックの`block:`の後ろには空白とコメントしか使えません  
`block:`ブロックは式であるため、他の式と同様に関数呼び出しの引数などに使うことができます 

`block:` が1つの式となるのは、通常のブロックと、`while`の`cond``do`、および`if`の`cond``then``else`などに適用される  
`if`や`struct`、`enum`などはブロック式を成すものではない  

### 引数 オフサイドルール
関数の引数は改行して並べることができる
引数のオフサイドルールを用いて改行した次の行ではインデントが1つ増える
その関数の引数の全ては同じインデントレベルで並べて書く必要がある

## 型注釈
`<T>`のように`<``>`で囲まれた型名は型注釈である  
型注釈`<T>`は何もしない関数`(.T)->.T`と見做し、型推論で関数と纏めて処理される  
つまり、型注釈は続く「式」に対して、関数呼び出しと同じように振舞う  

### 例
`let mut neg <bool> lt n 0;`
negという名前の変数を宣言し、その値は`<bool> lt n 0`である
式 `<bool> lt n 0` は、 式 `lt n 0` はboolであるという型注釈
式 `lt n 0`は、nと0の大小比較

## 型推論
型推論は読んでいる時点で既に判明している情報のみを用いて行う  
そのために型注釈や関数名などあらゆるものを前置している  
型推論では全ての式にたいする具体的な型を決定する  
`.label`を用いて書かれた関数定義などには具体的な型は決定できないが、`.label`を含めた状態で決定しておく  
ただ、これは試作なので、定義での多相は扱わないことにする  
entryに指定された関数は、`.label`を含まない、完全に具体的な型として決定できるはずである  
決定できなかった場合、型推論の失敗であり、エラーメッセージを出す  
また、矛盾が発生した場合などにも、エラーメッセージを出す  

## `#`

`#`の行は特別な意味をもつ行である  
`#entry`はプログラムの起点を指定する entryのないライブラリなどでは指定しません  
`#indent`はインデントの仕方を示す 規定はspace4つである
`#target`はプログラムのターゲットを指定する  
`#import`は標準ライブラリやライブラリなどで解決されるプログラムを読み込む  
`#use`はネストされた名前のエイリアスを作成する  
`#if[]`は特定の条件でのみ有効となるコードを表す  
`#wasm`は生WASMの命令をWATを用いて埋め込めます target=wasm の中でしか使えません `#wasm`でもスタックの検査だけは行います  

## コメント
`//`の後ろがコメントになる


## 処理
前置記法を採用し、オフサイドルールを採用し、全てのコードを前から読むことができます  
トークナイズ、パース、型推論などの全てを、前から一回読んでいくだけで行うことができるはずです  
但し、これでは定義の巻き上げが行えません  
オフサイドルールによってスコープ内の定義を全て探せるはずなので、適切に順番に処理していけば定義の巻き上げにも対応できます  
定義の巻き上げはmutでないletのみに適用できます fnもletの糖衣構文なので定義の巻き上げが行えます

## 糖衣構文
`fn name`は`let name`の糖衣構文である ただし、nameの型`.x`は`a->b`か`a*>b`であるという制限を設ける  
`then:`や`else:`は`block:`の糖衣構文である ただしこれはifのみで用いれるという制限を設ける

## リテラルなど
`i32`は小数点を含まない数字です`1` `2` `3`など
`f32`は小数点を含む数字です`1.0` `1.3`など
関数定義は`(args) expr`です
型注釈は`<T>`です



## 書き方例

### if

ベースが`if true 0 1`,`if true 0 if true 1 2`だとして
これに
「`:`つけたら改行してもいいよ」と
「`if`には`cond`と`then`と`else`つけてもいいよ」
を追加したらこうなりました

`"if" "cond"? <cond_expr> "then"? <then_expr> "else"? <else_expr>`  
"cond"キーワードと"then"キーワードと"else"キーワードは省略可能 (というよりは追加可能) であるが、 cond_exprとthen_exprとelse_exprは省略不可能  
それぞれで`:`による改行が適用可能になる  

ベースは`"if" <cond_expr> <then_expr> <else_expr>`
ここに、cond then else などのキーワードを適切に追加することができる
具体的には`<cond_expr>`を`"cond" <cond_expr>`のようにキーワードを付与できる
また、`if`に対する`:` つまり `if:` については、ブロックを成すものではなく、cond_expr then_expr else_expr を改行して表示できるようにするものである これは関数の引数に対する改行の扱いと同じである
`if:`は、具体的には、その次の行から式3つ分だけインデントを1つふやしてcond_expr then_expr else_expr とする 3行分ではなく式3つ分であるのは、cond_expr then_expr else_exprのそれぞれで通常の`:`ブロックを使用して複数行となる可能性があるためである
`cond:`や`then:`や`else:`は、通常の`block:`である ただし、順番にcond,then,elseの制約がある これはcond,then,elseのキーワードを`block`に置換することで意味が変わるのを防ぐためである
`cond:` は 通常の`block:`と同じであり、1つのブロック式である
また、`"if" <cond_expr>`の後ろの`:`、`"if" <cond_expr> :`では、then_exprとelse_exprを改行して表示できるようにする
`"if" <cond_expr> :`は、具体的には、その次の行から式2つ分だけインデントを1つふやしてthen_expr else_expr とする
この`<cond_expr>`にもcondキーワードを付与できるようにするが、実用上は不要であろう

```
// 1行
if <cond_expr> <then_expr> <else_expr>
// cond_expr then_expr else_expr にはそれぞれキーワードを付与可能
if cond <cond_expr> then <then_expr> else <else_expr>
// 改行 `if:`では続くcond then elseをインデント付きで改行して記述可能
if: // これは引数の方
    <cond_expr>
    <then_expr>
    <else_expr>
// cond_expr then_expr else_expr にはそれぞれキーワードを付与可能
if: // これは引数の方
    cond <cond_expr>
    then <then_expr>
    else <else_expr>
if <cond_expr>: // これは引数の方
    then <then_expr>
    else <else_expr>
if cond <cond_expr>: // これは引数の方
    then <then_expr>
    else <else_expr>
// cond: then: else: は block: の特別な書き方
if: // cond,then,else exprが複数行のときの推奨の書き方
    cond: // これはブロックの方
        <cond_expr>
    then: // これはブロックの方
        <then_expr>
    else: // これはブロックの方
        <else_expr>
if: // cond,then,else exprが1行のときの推奨の書き方
    cond <cond_expr>
    then <then_expr>
    else <else_expr>
```

```neplg2

// 1行 if
if true 0 1

// 1行 if then else
if true then 0 else 1

// 複数行 if then else
if: // これは引数の方
    true
    0
    1

// 複数行 if then else
if: // これは引数の方
    true
    then: // これはブロックの方
        0
    else: // これはブロックの方
        1

if: // これは引数の方
    cond: // これはブロックの方
        true
    then: // これはブロックの方
        0
    else: // これはブロックの方
        1

// 複数行 if then else
if: // これは引数の方
    true
    then 0
    else 1

// 1行 if 組み合わせ
if true 0 if true 1 2
if true 0 else if true 1 else 2
if true then 0 else if true then 1 else 2

// 複数行 if else 組み合わせ

if: // これは引数の方
    true
    then: // これはブロックの方
        0
    else: // これはブロックの方
        if: // これは引数の方
            cond: // これはブロックの方
                true
            then: // これはブロックの方
                1
            else: // これはブロックの方
                2

if: // これは引数の方
    true
    then: // これはブロックの方
        0
    else if: // これは引数の方
        cond:
            true
        then: // これはブロックの方
            1
        else: // これはブロックの方
            2

```

### while

ifと同様
cond:,do:はblock:の特別な場合 順番は固定
breakを追加
```
while false set i add i 1;
while cond false do set i add i 1;
while false: // これは引数の方
    set i add i 1
while false: // これは引数の方
    do: // これはブロックの方
        set i add i 1
while: // これは引数の方
    cond false
    do: // これはブロックの方
        set i add i 1
while: // これは引数の方
    cond: // これはブロックの方
        false
    do: // これはブロックの方
        set i add i 1
while: // これは引数の方
    false
    set i add i 1
```

### tuple
```
Tuple:
    a
    b
```


### VecとかListとかSetのリテラル

```
Vec<i32>:
    5
    4
    3
    6
    7
```

## 関数
関数リテラルは、`():`による、引数付きのブロック式である
他の型注釈と同様、`<type>`で型注釈を前置できる
関数型は純粋と非純粋に分けられ、`->`が純粋、`*>`が非純粋
関数のみ`let`の代わりに`fn`キーワードを使える
`fn`はimmutableなletの糖衣構文として扱われる

```
// ただの何もしない関数リテラル
():
    ()

// 何もしない関数リテラルに型注釈
<()->()> ():
    ()

// 何もしない関数リテラルに型注釈を宣言
let nop1 <()->() ():
    ()

// 関数なのでfnを使える
fn nop2 nop1;

// 型推論が成功するなら注釈は省略できる
fn main ():
    nop1
    nop2
```


### ブロック 文 セミコロン

`block:`によってインデントでまとめられた複数の式をブロックという
ブロック自体は一つの式になり、一つの値を返す

ブロック直下の式を文という
ブロック直下でない式は単に式という

```
// ブロック
block:
    <文>;
    <文>;
    <文>
block:
    <文>
    <文>
    <文>
```

ブロックの値および型は、ブロックの最後の文によって決まる  
最後の文以外の結果は捨てる これは後述する`;`の存在に関係ない  
ブロックに3つの文があったとき、前2つの文は、その文の評価が終わった時点で結果の値を捨てる  

`;`は、その直前で、スタックがブロックの基準から値1つぶんだけ成長していることを確認する  
`;`は構文上、1行のみからなる文にしかつけることができない  
複数行からなる文、つまりブロックなどを含む文では、代わりにそのインデントルールが同様のことを確認することになる  
`;`は専らスタックの確認のみに用いられるものであり、省略することができる  


`block:`に入った時点のスタックを`[ X ]`として説明する  

```
block:
    // この時点で`[ X ]`
    add 1 2; // ok
    add 1 2 // ok
    add 1 2 3; // エラー
```

`block:`の直下の式`add 1 2;`では、`;`の直前で`[ X, i32 ]`であり、`;`の直後で`[ X ]`となる  
`add 1 2 3;`では、`;`の直前で`[ X, i32, i32 ]`であり、スタックが長すぎるのでエラーである  

ブロックの値は、その最後の文の値になる  
最後の文の末尾に`;`がある場合、便宜上そのブロックの値は`()`とする  

```
// このブロックの値は11
<i32> block:
    add 1 2; // ここで3をスタックから捨てる
    add 3 4  // ここで7をスタックから捨てる
    add 5 6 // これがブロックの値
```
```
// このブロックの値は()
<()> block:
    add 1 2; // ここで3をスタックから捨てる
    add 3 4  // ここで7をスタックから捨てる
    add 5 6; // ここで11をスタックから捨てて、()がブロックの値
```

ブロック内に n 個の文があるとき：
1〜n-1 番目の文の結果は 必ず破棄
n 番目（最後の文）だけがブロックの値を決める
最後の文が ;付きなら、ブロックの値は ()
;なしなら、その文の値がブロックの値
```
// 1行に2つの文を入れるのはエラー
<()> block:
    add 1 2 add 3 4 // エラー
    add 5 6;
// ブロックの中にifを入れられる
<i32> block:
    if false:
        then:
            add 1 2
        else:
            add 3 4
    ();
    if true:
        then:
            add 1 2
        else:
            add 3 4
// 1つの文に複数回`;`があっても問題はない
<()> :
    add 1 2;;;
    add 3 4;
```

### 単行ブロック
インデント無しの、1行のみのブロック記法を追加する
現状
```
add:
    block:
        let a add 1 2;
        add a 3
    block:
        let a add 4 5;
        add a 6
```
のように書いていたものを、
```
add:
    block let a add 1 2; add a 3
    block let a add 4 5; add a 6
```
ののようにも書けるように変更
ブロックの終了判定が、`block:`のインデント付きブロックのときインデントによって終了判定、`block `のインデント無しブロックのとき行の終わりまでがブロックの終了
インデント付きブロックを複行ブロック、新たに追加する1行のみのブロック式を単行ブロックと呼ぶ
単行ブロックでは、複行ブロックと同様に、`;`の追加はオプションであり、ブロック直下の式がそこで終了していることを確認するのに用いる
ブロック式は複数の式を纏めて、最後の式の値や型がそのブロック式の値や型となる
単行ブロックは単行であり行末までが範囲であるため、単行ブロックの中に複行ブロックなどを置くことはできない
行末までが範囲であるため、`block block block 1\n`のような書き方、括弧を用いて表すと`(block (block (block 1)))\n`となるような書き方は許容される
しかし途中でブロックが終了するような書き方、例えば`add (block 1) (block 2)\n`このような解釈を期待する書き方`add block 1 block 2\n`のような書き方は不可能、`add 1 block 2\n`これは可能
これはブロックを使いたいときに徒に行が増える問題を解消する
ifやwhileの`cond`や`then`や`else`や`do`に`:`を付けた場合は現状複行ブロックとして解釈されるが、付けなかった場合に単行ブロックとして解釈することはしない 単行ブロックとする場合には`cond block let a 1; eq a 0\n`のように明示的に書く必要がある


### パイプ演算子
直前のスタックトップの値を第一引数として続く関数呼び出しの1つめの引数とする記法
```
let result add 1 add 2 3 |> add 4 |> add 5
```
パイプ演算子`|>`の手前で改行を許可するが、インデントは増やさない
```
let result:
    add 1 add 2 3
    |> add 4
    |> add 5
```

## 処理の流れ

AST生成
lexerは最初にできるハズです
ast構築、parser loader typecheck これらはごちゃまぜの順番で動かす、つまり、解決できるところから解決していく という戦略を取らないと正しく処理できないと思います
型や名前解決などが完了したastを作った後の処理、未使用コード警告の生成や、コンパイルエラーの整理など、